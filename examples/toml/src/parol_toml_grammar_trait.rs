// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::too_many_arguments)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolTomlGrammarTrait<'t> {
    /// Semantic action for non-terminal 'ParolToml'
    fn parol_toml(&mut self, _arg: &ParolToml<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Newline'
    fn newline(&mut self, _arg: &Newline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WsNewline'
    fn ws_newline(&mut self, _arg: &WsNewline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonAscii'
    fn non_ascii(&mut self, _arg: &NonAscii<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyVal'
    fn key_val(&mut self, _arg: &KeyVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleKey'
    fn simple_key(&mut self, _arg: &SimpleKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotedKey'
    fn quoted_key(&mut self, _arg: &QuotedKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyValSep'
    fn key_val_sep(&mut self, _arg: &KeyValSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Val'
    fn val(&mut self, _arg: &Val<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Numeric'
    fn numeric(&mut self, _arg: &Numeric<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicString'
    fn basic_string(&mut self, _arg: &BasicString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicChar'
    fn basic_char(&mut self, _arg: &BasicChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicUnescaped'
    fn basic_unescaped(&mut self, _arg: &BasicUnescaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escaped'
    fn escaped(&mut self, _arg: &Escaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escape'
    fn escape(&mut self, _arg: &Escape<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapeSeqChar'
    fn escape_seq_char(&mut self, _arg: &EscapeSeqChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode4'
    fn unicode4(&mut self, _arg: &Unicode4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode8'
    fn unicode8(&mut self, _arg: &Unicode8<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicString'
    fn m_l_basic_string(&mut self, _arg: &MLBasicString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicBody'
    fn m_l_basic_body(&mut self, _arg: &MLBasicBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContentList'
    fn m_l_b_content_list(&mut self, _arg: &MLBContentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContentList1'
    fn m_l_b_content_list1(&mut self, _arg: &MLBContentList1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContent'
    fn m_l_b_content(&mut self, _arg: &MLBContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBChar'
    fn m_l_b_char(&mut self, _arg: &MLBChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBUnescaped'
    fn m_l_b_unescaped(&mut self, _arg: &MLBUnescaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBEscapedNL'
    fn m_l_b_escaped_n_l(&mut self, _arg: &MLBEscapedNL<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralString'
    fn literal_string(&mut self, _arg: &LiteralString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralChar'
    fn literal_char(&mut self, _arg: &LiteralChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralCharNoApostrophe'
    fn literal_char_no_apostrophe(&mut self, _arg: &LiteralCharNoApostrophe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralString'
    fn m_l_literal_string(&mut self, _arg: &MLLiteralString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralBody'
    fn m_l_literal_body(&mut self, _arg: &MLLiteralBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContentList'
    fn m_l_l_content_list(&mut self, _arg: &MLLContentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContentList1'
    fn m_l_l_content_list1(&mut self, _arg: &MLLContentList1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContent'
    fn m_l_l_content(&mut self, _arg: &MLLContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexPrefix'
    fn hex_prefix(&mut self, _arg: &HexPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctPrefix'
    fn oct_prefix(&mut self, _arg: &OctPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinPrefix'
    fn bin_prefix(&mut self, _arg: &BinPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DecInt'
    fn dec_int(&mut self, _arg: &DecInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexInt'
    fn hex_int(&mut self, _arg: &HexInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexIntContent'
    fn hex_int_content(&mut self, _arg: &HexIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctInt'
    fn oct_int(&mut self, _arg: &OctInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctIntContent'
    fn oct_int_content(&mut self, _arg: &OctIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinInt'
    fn bin_int(&mut self, _arg: &BinInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinIntContent'
    fn bin_int_content(&mut self, _arg: &BinIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NormalFloat'
    fn normal_float(&mut self, _arg: &NormalFloat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SpecialFloat'
    fn special_float(&mut self, _arg: &SpecialFloat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DateTime'
    fn date_time(&mut self, _arg: &DateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OffsetDateTime'
    fn offset_date_time(&mut self, _arg: &OffsetDateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalDateTime'
    fn local_date_time(&mut self, _arg: &LocalDateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalDate'
    fn local_date(&mut self, _arg: &LocalDate<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalTime'
    fn local_time(&mut self, _arg: &LocalTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayValues'
    fn array_values(&mut self, _arg: &ArrayValues<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArraySep'
    fn array_sep(&mut self, _arg: &ArraySep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Table'
    fn table(&mut self, _arg: &Table<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTable'
    fn std_table(&mut self, _arg: &StdTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTableOpen'
    fn array_table_open(&mut self, _arg: &ArrayTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTableClose'
    fn array_table_close(&mut self, _arg: &ArrayTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayOpen'
    fn array_open(&mut self, _arg: &ArrayOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayClose'
    fn array_close(&mut self, _arg: &ArrayClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTableOpen'
    fn std_table_open(&mut self, _arg: &StdTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTableClose'
    fn std_table_close(&mut self, _arg: &StdTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTable'
    fn inline_table(&mut self, _arg: &InlineTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableOpen'
    fn inline_table_open(&mut self, _arg: &InlineTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableClose'
    fn inline_table_close(&mut self, _arg: &InlineTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableSep'
    fn inline_table_sep(&mut self, _arg: &InlineTableSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableKeyVals'
    fn inline_table_key_vals(&mut self, _arg: &InlineTableKeyVals<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTable'
    fn array_table(&mut self, _arg: &ArrayTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnsignedDecInt'
    fn unsigned_dec_int(&mut self, _arg: &UnsignedDecInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnquotedKey'
    fn unquoted_key(&mut self, _arg: &UnquotedKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotSep'
    fn dot_sep(&mut self, _arg: &DotSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicStringStart'
    fn m_l_basic_string_start(&mut self, _arg: &MLBasicStringStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicStringEnd'
    fn m_l_basic_string_end(&mut self, _arg: &MLBasicStringEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBQuotes'
    fn m_l_b_quotes(&mut self, _arg: &MLBQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotationMark'
    fn quotation_mark(&mut self, _arg: &QuotationMark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralStringStart'
    fn m_l_literal_string_start(&mut self, _arg: &MLLiteralStringStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralStringEnd'
    fn m_l_literal_string_end(&mut self, _arg: &MLLiteralStringEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLQuotes'
    fn m_l_l_quotes(&mut self, _arg: &MLLQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Apostrophe'
    fn apostrophe(&mut self, _arg: &Apostrophe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsciiNoEscape'
    fn ascii_no_escape(&mut self, _arg: &AsciiNoEscape<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 3
///
/// `Expression: KeyVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionKeyVal<'t> {
    pub key_val: KeyVal<'t>,
}

///
/// Type derived for production 4
///
/// `Expression: Table;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionTable<'t> {
    pub table: Table<'t>,
}

///
/// Type derived for production 10
///
/// `KeySuffix: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeySuffixKeySuffixEmpty {}

///
/// Type derived for production 11
///
/// `KeySuffix: DotSep SimpleKey KeyList /* Vec */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeySuffixDotSepSimpleKeyKeyList<'t> {
    pub dot_sep: DotSep<'t>,
    pub simple_key: SimpleKey<'t>,
    pub key_list: Vec<KeyList<'t>>,
}

///
/// Type derived for production 14
///
/// `SimpleKey: QuotedKey;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleKeyQuotedKey<'t> {
    pub quoted_key: QuotedKey<'t>,
}

///
/// Type derived for production 15
///
/// `SimpleKey: UnquotedKey;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleKeyUnquotedKey<'t> {
    pub unquoted_key: UnquotedKey<'t>,
}

///
/// Type derived for production 16
///
/// `QuotedKey: BasicString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotedKeyBasicString<'t> {
    pub basic_string: BasicString<'t>,
}

///
/// Type derived for production 17
///
/// `QuotedKey: LiteralString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotedKeyLiteralString<'t> {
    pub literal_string: LiteralString<'t>,
}

///
/// Type derived for production 19
///
/// `Val: Boolean;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValBoolean<'t> {
    pub boolean: Boolean<'t>,
}

///
/// Type derived for production 20
///
/// `Val: Array;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValArray<'t> {
    pub array: Box<Array<'t>>,
}

///
/// Type derived for production 21
///
/// `Val: InlineTable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValInlineTable<'t> {
    pub inline_table: Box<InlineTable<'t>>,
}

///
/// Type derived for production 22
///
/// `Val: DateTime;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValDateTime<'t> {
    pub date_time: DateTime<'t>,
}

///
/// Type derived for production 23
///
/// `Val: Numeric;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValNumeric<'t> {
    pub numeric: Numeric<'t>,
}

///
/// Type derived for production 24
///
/// `Val: BasicString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValBasicString<'t> {
    pub basic_string: BasicString<'t>,
}

///
/// Type derived for production 25
///
/// `Val: MLBasicString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValMLBasicString<'t> {
    pub m_l_basic_string: MLBasicString<'t>,
}

///
/// Type derived for production 26
///
/// `Val: LiteralString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValLiteralString<'t> {
    pub literal_string: LiteralString<'t>,
}

///
/// Type derived for production 27
///
/// `Val: MLLiteralString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValMLLiteralString<'t> {
    pub m_l_literal_string: MLLiteralString<'t>,
}

///
/// Type derived for production 28
///
/// `Numeric: Float;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumericFloat<'t> {
    pub float: Float<'t>,
}

///
/// Type derived for production 29
///
/// `Numeric: Integer;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumericInteger<'t> {
    pub integer: Integer<'t>,
}

///
/// Type derived for production 33
///
/// `BasicChar: BasicUnescaped;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicCharBasicUnescaped<'t> {
    pub basic_unescaped: BasicUnescaped<'t>,
}

///
/// Type derived for production 34
///
/// `BasicChar: %push(Esc) Escaped %pop();`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicCharEscaped<'t> {
    pub escaped: Escaped<'t>,
}

///
/// Type derived for production 35
///
/// `BasicUnescaped: AsciiNoEscape;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicUnescapedAsciiNoEscape<'t> {
    pub ascii_no_escape: AsciiNoEscape<'t>,
}

///
/// Type derived for production 36
///
/// `BasicUnescaped: NonAscii;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicUnescapedNonAscii<'t> {
    pub non_ascii: NonAscii<'t>,
}

///
/// Type derived for production 39
///
/// `EscapeSeqChar: QuotationMark;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharQuotationMark<'t> {
    pub quotation_mark: QuotationMark<'t>,
}

///
/// Type derived for production 40
///
/// `EscapeSeqChar: Escape;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharEscape<'t> {
    pub escape: Escape<'t>,
}

///
/// Type derived for production 41
///
/// `EscapeSeqChar: <Esc>"b";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharB<'t> {
    pub b: Token<'t>, /* b */
}

///
/// Type derived for production 42
///
/// `EscapeSeqChar: <Esc>"f";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharF<'t> {
    pub f: Token<'t>, /* f */
}

///
/// Type derived for production 43
///
/// `EscapeSeqChar: <Esc>"n";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharN<'t> {
    pub n: Token<'t>, /* n */
}

///
/// Type derived for production 44
///
/// `EscapeSeqChar: <Esc>"r";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharR<'t> {
    pub r: Token<'t>, /* r */
}

///
/// Type derived for production 45
///
/// `EscapeSeqChar: <Esc>"t";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharT<'t> {
    pub t: Token<'t>, /* t */
}

///
/// Type derived for production 46
///
/// `EscapeSeqChar: Unicode4;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharUnicode4<'t> {
    pub unicode4: Unicode4<'t>,
}

///
/// Type derived for production 47
///
/// `EscapeSeqChar: Unicode8;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharUnicode8<'t> {
    pub unicode8: Unicode8<'t>,
}

///
/// Type derived for production 48
///
/// `EscapeSeqChar: WsNewline;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharWsNewline<'t> {
    pub ws_newline: WsNewline<'t>,
}

///
/// Type derived for production 49
///
/// `EscapeSeqChar: AsciiNoEscape;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharAsciiNoEscape<'t> {
    pub ascii_no_escape: AsciiNoEscape<'t>,
}

///
/// Type derived for production 56
///
/// `MLBContentList: MLBContent MLBContentList;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentListMLBContentMLBContentList<'t> {
    pub m_l_b_content: MLBContent<'t>,
    pub m_l_b_content_list: Box<MLBContentList<'t>>,
}

///
/// Type derived for production 57
///
/// `MLBContentList: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentListMLBContentListEmpty {}

///
/// Type derived for production 59
///
/// `MLBContent: MLBChar;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentMLBChar<'t> {
    pub m_l_b_char: MLBChar<'t>,
}

///
/// Type derived for production 60
///
/// `MLBContent: Newline;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentNewline<'t> {
    pub newline: Newline<'t>,
}

///
/// Type derived for production 61
///
/// `MLBContent: MLBEscapedNL;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentMLBEscapedNL<'t> {
    pub m_l_b_escaped_n_l: MLBEscapedNL<'t>,
}

///
/// Type derived for production 62
///
/// `MLBChar: MLBUnescaped;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBCharMLBUnescaped<'t> {
    pub m_l_b_unescaped: MLBUnescaped<'t>,
}

///
/// Type derived for production 63
///
/// `MLBChar: %push(Esc) Escaped %pop();`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBCharEscaped<'t> {
    pub escaped: Escaped<'t>,
}

///
/// Type derived for production 64
///
/// `MLBUnescaped: AsciiNoEscape;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBUnescapedAsciiNoEscape<'t> {
    pub ascii_no_escape: AsciiNoEscape<'t>,
}

///
/// Type derived for production 65
///
/// `MLBUnescaped: NonAscii;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBUnescapedNonAscii<'t> {
    pub non_ascii: NonAscii<'t>,
}

///
/// Type derived for production 70
///
/// `LiteralChar: LiteralCharNoApostrophe;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharLiteralCharNoApostrophe<'t> {
    pub literal_char_no_apostrophe: LiteralCharNoApostrophe<'t>,
}

///
/// Type derived for production 71
///
/// `LiteralChar: NonAscii;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharNonAscii<'t> {
    pub non_ascii: NonAscii<'t>,
}

///
/// Type derived for production 77
///
/// `MLLContentList: MLLContent MLLContentList;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentListMLLContentMLLContentList<'t> {
    pub m_l_l_content: MLLContent<'t>,
    pub m_l_l_content_list: Box<MLLContentList<'t>>,
}

///
/// Type derived for production 78
///
/// `MLLContentList: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentListMLLContentListEmpty {}

///
/// Type derived for production 80
///
/// `MLLContent: LiteralChar;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentLiteralChar<'t> {
    pub literal_char: LiteralChar<'t>,
}

///
/// Type derived for production 81
///
/// `MLLContent: Newline;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentNewline<'t> {
    pub newline: Newline<'t>,
}

///
/// Type derived for production 82
///
/// `Integer: DecInt;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerDecInt<'t> {
    pub dec_int: DecInt<'t>,
}

///
/// Type derived for production 83
///
/// `Integer: HexInt;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerHexInt<'t> {
    pub hex_int: HexInt<'t>,
}

///
/// Type derived for production 84
///
/// `Integer: OctInt;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerOctInt<'t> {
    pub oct_int: OctInt<'t>,
}

///
/// Type derived for production 85
///
/// `Integer: BinInt;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerBinInt<'t> {
    pub bin_int: BinInt<'t>,
}

///
/// Type derived for production 91
///
/// `DecIntOptGroup: Plus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOptGroupPlus<'t> {
    pub plus: Plus<'t>,
}

///
/// Type derived for production 92
///
/// `DecIntOptGroup: Minus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOptGroupMinus<'t> {
    pub minus: Minus<'t>,
}

///
/// Type derived for production 100
///
/// `Boolean: <Val>"true";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanTrue<'t> {
    pub r#true: Token<'t>, /* true */
}

///
/// Type derived for production 101
///
/// `Boolean: <Val>"false";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanFalse<'t> {
    pub r#false: Token<'t>, /* false */
}

///
/// Type derived for production 102
///
/// `Float: NormalFloat;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatNormalFloat<'t> {
    pub normal_float: NormalFloat<'t>,
}

///
/// Type derived for production 103
///
/// `Float: SpecialFloat;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatSpecialFloat<'t> {
    pub special_float: SpecialFloat<'t>,
}

///
/// Type derived for production 106
///
/// `DateTime: OffsetDateTime;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeOffsetDateTime<'t> {
    pub offset_date_time: OffsetDateTime<'t>,
}

///
/// Type derived for production 107
///
/// `DateTime: LocalDateTime;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalDateTime<'t> {
    pub local_date_time: LocalDateTime<'t>,
}

///
/// Type derived for production 108
///
/// `DateTime: LocalDate;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalDate<'t> {
    pub local_date: LocalDate<'t>,
}

///
/// Type derived for production 109
///
/// `DateTime: LocalTime;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalTime<'t> {
    pub local_time: LocalTime<'t>,
}

///
/// Type derived for production 118
///
/// `ArrayValuesSuffix0: ArraySep^ /* Clipped */ ArrayValuesSuffix;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffix0ArraySepArrayValuesSuffix<'t> {
    pub array_values_suffix: Box<ArrayValuesSuffix<'t>>,
}

///
/// Type derived for production 119
///
/// `ArrayValuesSuffix0: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffix0ArrayValuesSuffix0Empty {}

///
/// Type derived for production 120
///
/// `ArrayValuesSuffix: ArrayValues;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffixArrayValues<'t> {
    pub array_values: ArrayValues<'t>,
}

///
/// Type derived for production 121
///
/// `ArrayValuesSuffix: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffixArrayValuesSuffixEmpty {}

///
/// Type derived for production 123
///
/// `Table: StdTable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableStdTable<'t> {
    pub std_table: StdTable<'t>,
}

///
/// Type derived for production 124
///
/// `Table: ArrayTable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableArrayTable<'t> {
    pub array_table: ArrayTable<'t>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Apostrophe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Apostrophe<'t> {
    pub apostrophe: Token<'t>, /* \u{27} */
}

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Array<'t> {
    pub array_opt: Option<ArrayOpt<'t>>,
}

///
/// Type derived for non-terminal ArrayClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayClose<'t> {
    pub array_close: Token<'t>, /* \u{5D} */
}

///
/// Type derived for non-terminal ArrayOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayOpen<'t> {
    pub array_open: Token<'t>, /* \u{5B} */
}

///
/// Type derived for non-terminal ArrayOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayOpt<'t> {
    pub array_values: ArrayValues<'t>,
}

///
/// Type derived for non-terminal ArraySep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySep<'t> {
    pub array_sep: Token<'t>, /* , */
}

///
/// Type derived for non-terminal ArrayTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTable<'t> {
    pub key: Key<'t>,
}

///
/// Type derived for non-terminal ArrayTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTableClose<'t> {
    pub array_table_close: Token<'t>, /* \u{5D}\u{5D} */
}

///
/// Type derived for non-terminal ArrayTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTableOpen<'t> {
    pub array_table_open: Token<'t>, /* \u{5B}\u{5B} */
}

///
/// Type derived for non-terminal ArrayValues
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValues<'t> {
    pub val: Val<'t>,
    pub array_values_suffix0: ArrayValuesSuffix0<'t>,
}

///
/// Type derived for non-terminal ArrayValuesSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayValuesSuffix<'t> {
    ArrayValues(ArrayValuesSuffixArrayValues<'t>),
    ArrayValuesSuffixEmpty(ArrayValuesSuffixArrayValuesSuffixEmpty),
}

///
/// Type derived for non-terminal ArrayValuesSuffix0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayValuesSuffix0<'t> {
    ArraySepArrayValuesSuffix(ArrayValuesSuffix0ArraySepArrayValuesSuffix<'t>),
    ArrayValuesSuffix0Empty(ArrayValuesSuffix0ArrayValuesSuffix0Empty),
}

///
/// Type derived for non-terminal AsciiNoEscape
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsciiNoEscape<'t> {
    pub ascii_no_escape: Token<'t>, /* [ \t\u{21}\u{23}-\u{5B}\u{5D}-\u{7E}]+ */
}

///
/// Type derived for non-terminal BasicChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicChar<'t> {
    BasicUnescaped(BasicCharBasicUnescaped<'t>),
    Escaped(BasicCharEscaped<'t>),
}

///
/// Type derived for non-terminal BasicString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicString<'t> {
    pub quotation_mark: QuotationMark<'t>,
    pub basic_string_list: Vec<BasicStringList<'t>>,
    pub quotation_mark0: QuotationMark<'t>,
}

///
/// Type derived for non-terminal BasicStringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicStringList<'t> {
    pub basic_char: BasicChar<'t>,
}

///
/// Type derived for non-terminal BasicUnescaped
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicUnescaped<'t> {
    AsciiNoEscape(BasicUnescapedAsciiNoEscape<'t>),
    NonAscii(BasicUnescapedNonAscii<'t>),
}

///
/// Type derived for non-terminal BinInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinInt<'t> {
    pub bin_int_content: BinIntContent<'t>,
}

///
/// Type derived for non-terminal BinIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinIntContent<'t> {
    pub bin_int_content: Token<'t>, /* [01]([01]|_[01])* */
}

///
/// Type derived for non-terminal BinPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinPrefix<'t> {
    pub bin_prefix: Token<'t>, /* 0b */
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

///
/// Type derived for non-terminal DateTime
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DateTime<'t> {
    OffsetDateTime(DateTimeOffsetDateTime<'t>),
    LocalDateTime(DateTimeLocalDateTime<'t>),
    LocalDate(DateTimeLocalDate<'t>),
    LocalTime(DateTimeLocalTime<'t>),
}

///
/// Type derived for non-terminal DecInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecInt<'t> {
    pub dec_int_opt: Option<DecIntOpt<'t>>,
    pub unsigned_dec_int: UnsignedDecInt<'t>,
}

///
/// Type derived for non-terminal DecIntOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOpt<'t> {
    pub dec_int_opt_group: DecIntOptGroup<'t>,
}

///
/// Type derived for non-terminal DecIntOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DecIntOptGroup<'t> {
    Plus(DecIntOptGroupPlus<'t>),
    Minus(DecIntOptGroupMinus<'t>),
}

///
/// Type derived for non-terminal DotSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotSep<'t> {
    pub dot_sep: Token<'t>, /* \. */
}

///
/// Type derived for non-terminal Escape
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escape<'t> {
    pub escape: Token<'t>, /* \u{5C} */
}

///
/// Type derived for non-terminal EscapeSeqChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EscapeSeqChar<'t> {
    QuotationMark(EscapeSeqCharQuotationMark<'t>),
    Escape(EscapeSeqCharEscape<'t>),
    B(EscapeSeqCharB<'t>),
    F(EscapeSeqCharF<'t>),
    N(EscapeSeqCharN<'t>),
    R(EscapeSeqCharR<'t>),
    T(EscapeSeqCharT<'t>),
    Unicode4(EscapeSeqCharUnicode4<'t>),
    Unicode8(EscapeSeqCharUnicode8<'t>),
    WsNewline(EscapeSeqCharWsNewline<'t>),
    AsciiNoEscape(EscapeSeqCharAsciiNoEscape<'t>),
}

///
/// Type derived for non-terminal Escaped
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escaped<'t> {
    pub escape: Escape<'t>,
    pub escape_seq_char: EscapeSeqChar<'t>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression<'t> {
    KeyVal(ExpressionKeyVal<'t>),
    Table(ExpressionTable<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    NormalFloat(FloatNormalFloat<'t>),
    SpecialFloat(FloatSpecialFloat<'t>),
}

///
/// Type derived for non-terminal HexInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexInt<'t> {
    pub hex_int_content: HexIntContent<'t>,
}

///
/// Type derived for non-terminal HexIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexIntContent<'t> {
    pub hex_int_content: Token<'t>, /* [0-9a-fA-F]([0-9a-fA-F]|_[0-9a-fA-F])* */
}

///
/// Type derived for non-terminal HexPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexPrefix<'t> {
    pub hex_prefix: Token<'t>, /* 0x */
}

///
/// Type derived for non-terminal InlineTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTable<'t> {
    pub inline_table_opt: Option<InlineTableOpt<'t>>,
    pub inline_table_opt0: Option<InlineTableOpt0<'t>>,
}

///
/// Type derived for non-terminal InlineTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableClose<'t> {
    pub inline_table_close: Token<'t>, /* \u{7D} */
}

///
/// Type derived for non-terminal InlineTableKeyVals
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableKeyVals<'t> {
    pub key_val: KeyVal<'t>,
    pub inline_table_key_vals_opt: Option<Box<InlineTableKeyValsOpt<'t>>>,
}

///
/// Type derived for non-terminal InlineTableKeyValsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableKeyValsOpt<'t> {
    pub inline_table_key_vals: InlineTableKeyVals<'t>,
}

///
/// Type derived for non-terminal InlineTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableOpen<'t> {
    pub inline_table_open: Token<'t>, /* \u{7B} */
}

///
/// Type derived for non-terminal InlineTableOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableOpt<'t> {
    pub inline_table_key_vals: InlineTableKeyVals<'t>,
}

///
/// Type derived for non-terminal InlineTableOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableOpt0<'t> {
    pub inline_table_sep: InlineTableSep<'t>,
}

///
/// Type derived for non-terminal InlineTableSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableSep<'t> {
    pub array_sep: ArraySep<'t>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Integer<'t> {
    DecInt(IntegerDecInt<'t>),
    HexInt(IntegerHexInt<'t>),
    OctInt(IntegerOctInt<'t>),
    BinInt(IntegerBinInt<'t>),
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Key<'t> {
    pub simple_key: SimpleKey<'t>,
    pub key_suffix: KeySuffix<'t>,
}

///
/// Type derived for non-terminal KeyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyList<'t> {
    pub dot_sep: DotSep<'t>,
    pub simple_key: SimpleKey<'t>,
}

///
/// Type derived for non-terminal KeySuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeySuffix<'t> {
    KeySuffixEmpty(KeySuffixKeySuffixEmpty),
    DotSepSimpleKeyKeyList(KeySuffixDotSepSimpleKeyKeyList<'t>),
}

///
/// Type derived for non-terminal KeyVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyVal<'t> {
    pub key: Key<'t>,
    pub key_val_sep: KeyValSep<'t>,
    pub val: Val<'t>,
}

///
/// Type derived for non-terminal KeyValSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyValSep<'t> {
    pub key_val_sep: Token<'t>, /* = */
}

///
/// Type derived for non-terminal LiteralChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LiteralChar<'t> {
    LiteralCharNoApostrophe(LiteralCharLiteralCharNoApostrophe<'t>),
    NonAscii(LiteralCharNonAscii<'t>),
}

///
/// Type derived for non-terminal LiteralCharNoApostrophe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharNoApostrophe<'t> {
    pub literal_char_no_apostrophe: Token<'t>, /* [\t\u{20}-\u{26}\u{28}-\u{7E}]+ */
}

///
/// Type derived for non-terminal LiteralString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralString<'t> {
    pub literal_string_list: Vec<LiteralStringList<'t>>,
}

///
/// Type derived for non-terminal LiteralStringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralStringList<'t> {
    pub literal_char: LiteralChar<'t>,
}

///
/// Type derived for non-terminal LocalDate
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalDate<'t> {
    pub local_date: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2} */
}

///
/// Type derived for non-terminal LocalDateTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalDateTime<'t> {
    pub local_date_time: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)?[Zz]? */
}

///
/// Type derived for non-terminal LocalTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalTime<'t> {
    pub local_time: Token<'t>, /* [0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)? */
}

///
/// Type derived for non-terminal MLBChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBChar<'t> {
    MLBUnescaped(MLBCharMLBUnescaped<'t>),
    Escaped(MLBCharEscaped<'t>),
}

///
/// Type derived for non-terminal MLBContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBContent<'t> {
    MLBChar(MLBContentMLBChar<'t>),
    Newline(MLBContentNewline<'t>),
    MLBEscapedNL(MLBContentMLBEscapedNL<'t>),
}

///
/// Type derived for non-terminal MLBContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBContentList<'t> {
    MLBContentMLBContentList(MLBContentListMLBContentMLBContentList<'t>),
    MLBContentListEmpty(MLBContentListMLBContentListEmpty),
}

///
/// Type derived for non-terminal MLBContentList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentList1<'t> {
    pub m_l_b_content: MLBContent<'t>,
    pub m_l_b_content_list: MLBContentList<'t>,
}

///
/// Type derived for non-terminal MLBEscapedNL
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBEscapedNL<'t> {
    pub m_l_b_escaped_n_l: Token<'t>, /* \u{5C}[ \t]*\r?\n([ \t]|\r?\n)* */
}

///
/// Type derived for non-terminal MLBQuotes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBQuotes<'t> {
    pub m_l_b_quotes: Token<'t>, /* \u{22}{1,2} */
}

///
/// Type derived for non-terminal MLBUnescaped
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBUnescaped<'t> {
    AsciiNoEscape(MLBUnescapedAsciiNoEscape<'t>),
    NonAscii(MLBUnescapedNonAscii<'t>),
}

///
/// Type derived for non-terminal MLBasicBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicBody<'t> {
    pub m_l_b_content_list: MLBContentList<'t>,
    pub m_l_basic_body_list: Vec<MLBasicBodyList<'t>>,
}

///
/// Type derived for non-terminal MLBasicBodyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicBodyList<'t> {
    pub m_l_b_quotes: MLBQuotes<'t>,
    pub m_l_b_content_list1: MLBContentList1<'t>,
}

///
/// Type derived for non-terminal MLBasicString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicString<'t> {
    pub m_l_basic_string_start: MLBasicStringStart<'t>,
    pub m_l_basic_body: MLBasicBody<'t>,
    pub m_l_basic_string_end: MLBasicStringEnd<'t>,
}

///
/// Type derived for non-terminal MLBasicStringEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicStringEnd<'t> {
    pub m_l_basic_string_end: Token<'t>, /* \u{22}{3,5} */
}

///
/// Type derived for non-terminal MLBasicStringStart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicStringStart<'t> {
    pub m_l_basic_string_start: Token<'t>, /* \u{22}{3} */
}

///
/// Type derived for non-terminal MLLContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLLContent<'t> {
    LiteralChar(MLLContentLiteralChar<'t>),
    Newline(MLLContentNewline<'t>),
}

///
/// Type derived for non-terminal MLLContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLLContentList<'t> {
    MLLContentMLLContentList(MLLContentListMLLContentMLLContentList<'t>),
    MLLContentListEmpty(MLLContentListMLLContentListEmpty),
}

///
/// Type derived for non-terminal MLLContentList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentList1<'t> {
    pub m_l_l_content: MLLContent<'t>,
    pub m_l_l_content_list: MLLContentList<'t>,
}

///
/// Type derived for non-terminal MLLQuotes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLQuotes<'t> {
    pub m_l_l_quotes: Token<'t>, /* \u{27}{1,2} */
}

///
/// Type derived for non-terminal MLLiteralBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralBody<'t> {
    pub m_l_l_content_list: MLLContentList<'t>,
    pub m_l_literal_body_list: Vec<MLLiteralBodyList<'t>>,
}

///
/// Type derived for non-terminal MLLiteralBodyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralBodyList<'t> {
    pub m_l_l_quotes: MLLQuotes<'t>,
    pub m_l_l_content_list1: MLLContentList1<'t>,
}

///
/// Type derived for non-terminal MLLiteralString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralString<'t> {
    pub m_l_literal_body: MLLiteralBody<'t>,
}

///
/// Type derived for non-terminal MLLiteralStringEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralStringEnd<'t> {
    pub m_l_literal_string_end: Token<'t>, /* \u{27}{3,5}(?:\r?\n)? */
}

///
/// Type derived for non-terminal MLLiteralStringStart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralStringStart<'t> {
    pub m_l_literal_string_start: Token<'t>, /* \u{27}{3} */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* \u{2D} */
}

///
/// Type derived for non-terminal Newline
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Newline<'t> {
    pub newline: Token<'t>, /* \r?\n */
}

///
/// Type derived for non-terminal NonAscii
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonAscii<'t> {
    pub non_ascii: Token<'t>, /* [\u{80}-\u{D7FF}\u{E000}-\u{10FFFF}] */
}

///
/// Type derived for non-terminal NormalFloat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NormalFloat<'t> {
    pub normal_float: Token<'t>, /* [-+]?(?:0|[1-9](?:[0-9]|_[0-9])*)(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*|(?:\.[0-9](?:[0-9]|_[0-9])*(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*)?)) */
}

///
/// Type derived for non-terminal Numeric
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Numeric<'t> {
    Float(NumericFloat<'t>),
    Integer(NumericInteger<'t>),
}

///
/// Type derived for non-terminal OctInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctInt<'t> {
    pub oct_int_content: OctIntContent<'t>,
}

///
/// Type derived for non-terminal OctIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctIntContent<'t> {
    pub oct_int_content: Token<'t>, /* [0-7]([0-7]|_[0-7])* */
}

///
/// Type derived for non-terminal OctPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctPrefix<'t> {
    pub oct_prefix: Token<'t>, /* 0o */
}

///
/// Type derived for non-terminal OffsetDateTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OffsetDateTime<'t> {
    pub offset_date_time: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)?([Zz]|[-+][0-9]{2}(:[0-9]{2})?)? */
}

///
/// Type derived for non-terminal ParolToml
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParolToml<'t> {
    pub parol_toml_list: Vec<ParolTomlList<'t>>,
}

///
/// Type derived for non-terminal ParolTomlList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParolTomlList<'t> {
    pub expression: Expression<'t>,
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* \u{2B} */
}

///
/// Type derived for non-terminal QuotationMark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotationMark<'t> {
    pub quotation_mark: Token<'t>, /* \u{22} */
}

///
/// Type derived for non-terminal QuotedKey
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QuotedKey<'t> {
    BasicString(QuotedKeyBasicString<'t>),
    LiteralString(QuotedKeyLiteralString<'t>),
}

///
/// Type derived for non-terminal SimpleKey
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SimpleKey<'t> {
    QuotedKey(SimpleKeyQuotedKey<'t>),
    UnquotedKey(SimpleKeyUnquotedKey<'t>),
}

///
/// Type derived for non-terminal SpecialFloat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SpecialFloat<'t> {
    pub special_float: Token<'t>, /* [-+]?(nan|inf) */
}

///
/// Type derived for non-terminal StdTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTable<'t> {
    pub key: Key<'t>,
}

///
/// Type derived for non-terminal StdTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTableClose<'t> {
    pub array_close: ArrayClose<'t>,
}

///
/// Type derived for non-terminal StdTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTableOpen<'t> {
    pub array_open: ArrayOpen<'t>,
}

///
/// Type derived for non-terminal Table
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Table<'t> {
    StdTable(TableStdTable<'t>),
    ArrayTable(TableArrayTable<'t>),
}

///
/// Type derived for non-terminal Unicode4
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode4<'t> {
    pub unicode4: Token<'t>, /* u[0-9a-fA-F]{4} */
}

///
/// Type derived for non-terminal Unicode8
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode8<'t> {
    pub unicode8: Token<'t>, /* U[0-9a-fA-F]{8} */
}

///
/// Type derived for non-terminal UnquotedKey
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnquotedKey<'t> {
    pub unquoted_key: Token<'t>, /* [-_A-Za-z0-9\u{B2}\u{B3}\u{B9}\u{BC}-\u{BE}\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{203F}-\u{2040}\u{2070}-\u{218F}\u{2460}-\u{24FF}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}]+ */
}

///
/// Type derived for non-terminal UnsignedDecInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedDecInt<'t> {
    pub unsigned_dec_int: Token<'t>, /* 0|[1-9]([0-9]|_[0-9])* */
}

///
/// Type derived for non-terminal Val
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Val<'t> {
    Boolean(ValBoolean<'t>),
    Array(ValArray<'t>),
    InlineTable(ValInlineTable<'t>),
    DateTime(ValDateTime<'t>),
    Numeric(ValNumeric<'t>),
    BasicString(ValBasicString<'t>),
    MLBasicString(ValMLBasicString<'t>),
    LiteralString(ValLiteralString<'t>),
    MLLiteralString(ValMLLiteralString<'t>),
}

///
/// Type derived for non-terminal WsNewline
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WsNewline<'t> {
    pub ws_newline: Token<'t>, /* [ \t]*\r?\n */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Apostrophe(Apostrophe<'t>),
    Array(Array<'t>),
    ArrayClose(ArrayClose<'t>),
    ArrayOpen(ArrayOpen<'t>),
    ArrayOpt(Option<ArrayOpt<'t>>),
    ArraySep(ArraySep<'t>),
    ArrayTable(ArrayTable<'t>),
    ArrayTableClose(ArrayTableClose<'t>),
    ArrayTableOpen(ArrayTableOpen<'t>),
    ArrayValues(ArrayValues<'t>),
    ArrayValuesSuffix(ArrayValuesSuffix<'t>),
    ArrayValuesSuffix0(ArrayValuesSuffix0<'t>),
    AsciiNoEscape(AsciiNoEscape<'t>),
    BasicChar(BasicChar<'t>),
    BasicString(BasicString<'t>),
    BasicStringList(Vec<BasicStringList<'t>>),
    BasicUnescaped(BasicUnescaped<'t>),
    BinInt(BinInt<'t>),
    BinIntContent(BinIntContent<'t>),
    BinPrefix(BinPrefix<'t>),
    Boolean(Boolean<'t>),
    DateTime(DateTime<'t>),
    DecInt(DecInt<'t>),
    DecIntOpt(Option<DecIntOpt<'t>>),
    DecIntOptGroup(DecIntOptGroup<'t>),
    DotSep(DotSep<'t>),
    Escape(Escape<'t>),
    EscapeSeqChar(EscapeSeqChar<'t>),
    Escaped(Escaped<'t>),
    Expression(Expression<'t>),
    Float(Float<'t>),
    HexInt(HexInt<'t>),
    HexIntContent(HexIntContent<'t>),
    HexPrefix(HexPrefix<'t>),
    InlineTable(InlineTable<'t>),
    InlineTableClose(InlineTableClose<'t>),
    InlineTableKeyVals(InlineTableKeyVals<'t>),
    InlineTableKeyValsOpt(Option<InlineTableKeyValsOpt<'t>>),
    InlineTableOpen(InlineTableOpen<'t>),
    InlineTableOpt(Option<InlineTableOpt<'t>>),
    InlineTableOpt0(Option<InlineTableOpt0<'t>>),
    InlineTableSep(InlineTableSep<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyList(Vec<KeyList<'t>>),
    KeySuffix(KeySuffix<'t>),
    KeyVal(KeyVal<'t>),
    KeyValSep(KeyValSep<'t>),
    LiteralChar(LiteralChar<'t>),
    LiteralCharNoApostrophe(LiteralCharNoApostrophe<'t>),
    LiteralString(LiteralString<'t>),
    LiteralStringList(Vec<LiteralStringList<'t>>),
    LocalDate(LocalDate<'t>),
    LocalDateTime(LocalDateTime<'t>),
    LocalTime(LocalTime<'t>),
    MLBChar(MLBChar<'t>),
    MLBContent(MLBContent<'t>),
    MLBContentList(MLBContentList<'t>),
    MLBContentList1(MLBContentList1<'t>),
    MLBEscapedNL(MLBEscapedNL<'t>),
    MLBQuotes(MLBQuotes<'t>),
    MLBUnescaped(MLBUnescaped<'t>),
    MLBasicBody(MLBasicBody<'t>),
    MLBasicBodyList(Vec<MLBasicBodyList<'t>>),
    MLBasicString(MLBasicString<'t>),
    MLBasicStringEnd(MLBasicStringEnd<'t>),
    MLBasicStringStart(MLBasicStringStart<'t>),
    MLLContent(MLLContent<'t>),
    MLLContentList(MLLContentList<'t>),
    MLLContentList1(MLLContentList1<'t>),
    MLLQuotes(MLLQuotes<'t>),
    MLLiteralBody(MLLiteralBody<'t>),
    MLLiteralBodyList(Vec<MLLiteralBodyList<'t>>),
    MLLiteralString(MLLiteralString<'t>),
    MLLiteralStringEnd(MLLiteralStringEnd<'t>),
    MLLiteralStringStart(MLLiteralStringStart<'t>),
    Minus(Minus<'t>),
    Newline(Newline<'t>),
    NonAscii(NonAscii<'t>),
    NormalFloat(NormalFloat<'t>),
    Numeric(Numeric<'t>),
    OctInt(OctInt<'t>),
    OctIntContent(OctIntContent<'t>),
    OctPrefix(OctPrefix<'t>),
    OffsetDateTime(OffsetDateTime<'t>),
    ParolToml(ParolToml<'t>),
    ParolTomlList(Vec<ParolTomlList<'t>>),
    Plus(Plus<'t>),
    QuotationMark(QuotationMark<'t>),
    QuotedKey(QuotedKey<'t>),
    SimpleKey(SimpleKey<'t>),
    SpecialFloat(SpecialFloat<'t>),
    StdTable(StdTable<'t>),
    StdTableClose(StdTableClose<'t>),
    StdTableOpen(StdTableOpen<'t>),
    Table(Table<'t>),
    Unicode4(Unicode4<'t>),
    Unicode8(Unicode8<'t>),
    UnquotedKey(UnquotedKey<'t>),
    UnsignedDecInt(UnsignedDecInt<'t>),
    Val(Val<'t>),
    WsNewline(WsNewline<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolTomlGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolTomlGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolTomlGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolTomlGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolTomlGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `ParolToml: ParolTomlList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml(&mut self, _parol_toml_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_toml_list = pop_and_reverse_item!(self, parol_toml_list, ParolTomlList, context);
        let parol_toml_built = ParolToml { parol_toml_list };
        // Calling user action here
        self.user_grammar.parol_toml(&parol_toml_built)?;
        self.push(ASTType::ParolToml(parol_toml_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `ParolTomlList /* Vec<T>::Push */: Expression ParolTomlList;`
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml_list_0(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _parol_toml_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut parol_toml_list = pop_item!(self, parol_toml_list, ParolTomlList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let parol_toml_list_0_built = ParolTomlList { expression };
        // Add an element to the vector
        parol_toml_list.push(parol_toml_list_0_built);
        self.push(ASTType::ParolTomlList(parol_toml_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `ParolTomlList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_toml_list_1_built = Vec::new();
        self.push(ASTType::ParolTomlList(parol_toml_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `Expression: KeyVal;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_0(&mut self, _key_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_val = pop_item!(self, key_val, KeyVal, context);
        let expression_0_built = ExpressionKeyVal { key_val };
        let expression_0_built = Expression::KeyVal(expression_0_built);
        // Calling user action here
        self.user_grammar.expression(&expression_0_built)?;
        self.push(ASTType::Expression(expression_0_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `Expression: Table;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_1(&mut self, _table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table = pop_item!(self, table, Table, context);
        let expression_1_built = ExpressionTable { table };
        let expression_1_built = Expression::Table(expression_1_built);
        // Calling user action here
        self.user_grammar.expression(&expression_1_built)?;
        self.push(ASTType::Expression(expression_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Newline: <MLBString, MLLString>"\r?\n";`
    ///
    #[parol_runtime::function_name::named]
    fn newline(&mut self, newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = newline.token()?.clone();
        let newline_built = Newline { newline };
        // Calling user action here
        self.user_grammar.newline(&newline_built)?;
        self.push(ASTType::Newline(newline_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `WsNewline: <Esc>"[ \t]*\r?\n";`
    ///
    #[parol_runtime::function_name::named]
    fn ws_newline(&mut self, ws_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws_newline = ws_newline.token()?.clone();
        let ws_newline_built = WsNewline { ws_newline };
        // Calling user action here
        self.user_grammar.ws_newline(&ws_newline_built)?;
        self.push(ASTType::WsNewline(ws_newline_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `NonAscii: <BString, MLBString, LString, MLLString>"[\u{80}-\u{D7FF}\u{E000}-\u{10FFFF}]";`
    ///
    #[parol_runtime::function_name::named]
    fn non_ascii(&mut self, non_ascii: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = non_ascii.token()?.clone();
        let non_ascii_built = NonAscii { non_ascii };
        // Calling user action here
        self.user_grammar.non_ascii(&non_ascii_built)?;
        self.push(ASTType::NonAscii(non_ascii_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `KeyVal: Key KeyValSep %push(Val) Val %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn key_val(
        &mut self,
        _key: &ParseTreeType<'t>,
        _key_val_sep: &ParseTreeType<'t>,
        _val: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let val = pop_item!(self, val, Val, context);
        let key_val_sep = pop_item!(self, key_val_sep, KeyValSep, context);
        let key = pop_item!(self, key, Key, context);
        let key_val_built = KeyVal {
            key,
            key_val_sep,
            val,
        };
        // Calling user action here
        self.user_grammar.key_val(&key_val_built)?;
        self.push(ASTType::KeyVal(key_val_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Key: SimpleKey KeySuffix;`
    ///
    #[parol_runtime::function_name::named]
    fn key(
        &mut self,
        _simple_key: &ParseTreeType<'t>,
        _key_suffix: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_suffix = pop_item!(self, key_suffix, KeySuffix, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let key_built = Key {
            simple_key,
            key_suffix,
        };
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `KeySuffix: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_suffix_0(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_suffix_0_built = KeySuffixKeySuffixEmpty {};
        let key_suffix_0_built = KeySuffix::KeySuffixEmpty(key_suffix_0_built);
        self.push(ASTType::KeySuffix(key_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `KeySuffix: DotSep SimpleKey KeyList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn key_suffix_1(
        &mut self,
        _dot_sep: &ParseTreeType<'t>,
        _simple_key: &ParseTreeType<'t>,
        _key_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_list = pop_and_reverse_item!(self, key_list, KeyList, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let dot_sep = pop_item!(self, dot_sep, DotSep, context);
        let key_suffix_1_built = KeySuffixDotSepSimpleKeyKeyList {
            dot_sep,
            simple_key,
            key_list,
        };
        let key_suffix_1_built = KeySuffix::DotSepSimpleKeyKeyList(key_suffix_1_built);
        self.push(ASTType::KeySuffix(key_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `KeyList /* Vec<T>::Push */: DotSep SimpleKey KeyList;`
    ///
    #[parol_runtime::function_name::named]
    fn key_list_0(
        &mut self,
        _dot_sep: &ParseTreeType<'t>,
        _simple_key: &ParseTreeType<'t>,
        _key_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut key_list = pop_item!(self, key_list, KeyList, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let dot_sep = pop_item!(self, dot_sep, DotSep, context);
        let key_list_0_built = KeyList {
            simple_key,
            dot_sep,
        };
        // Add an element to the vector
        key_list.push(key_list_0_built);
        self.push(ASTType::KeyList(key_list), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `KeyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_list_1_built = Vec::new();
        self.push(ASTType::KeyList(key_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `SimpleKey: QuotedKey;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_key_0(&mut self, _quoted_key: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_key = pop_item!(self, quoted_key, QuotedKey, context);
        let simple_key_0_built = SimpleKeyQuotedKey { quoted_key };
        let simple_key_0_built = SimpleKey::QuotedKey(simple_key_0_built);
        // Calling user action here
        self.user_grammar.simple_key(&simple_key_0_built)?;
        self.push(ASTType::SimpleKey(simple_key_0_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `SimpleKey: UnquotedKey;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_key_1(&mut self, _unquoted_key: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unquoted_key = pop_item!(self, unquoted_key, UnquotedKey, context);
        let simple_key_1_built = SimpleKeyUnquotedKey { unquoted_key };
        let simple_key_1_built = SimpleKey::UnquotedKey(simple_key_1_built);
        // Calling user action here
        self.user_grammar.simple_key(&simple_key_1_built)?;
        self.push(ASTType::SimpleKey(simple_key_1_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `QuotedKey: BasicString;`
    ///
    #[parol_runtime::function_name::named]
    fn quoted_key_0(&mut self, _basic_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string = pop_item!(self, basic_string, BasicString, context);
        let quoted_key_0_built = QuotedKeyBasicString { basic_string };
        let quoted_key_0_built = QuotedKey::BasicString(quoted_key_0_built);
        // Calling user action here
        self.user_grammar.quoted_key(&quoted_key_0_built)?;
        self.push(ASTType::QuotedKey(quoted_key_0_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `QuotedKey: LiteralString;`
    ///
    #[parol_runtime::function_name::named]
    fn quoted_key_1(&mut self, _literal_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = pop_item!(self, literal_string, LiteralString, context);
        let quoted_key_1_built = QuotedKeyLiteralString { literal_string };
        let quoted_key_1_built = QuotedKey::LiteralString(quoted_key_1_built);
        // Calling user action here
        self.user_grammar.quoted_key(&quoted_key_1_built)?;
        self.push(ASTType::QuotedKey(quoted_key_1_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `KeyValSep: <INITIAL, Val>"=";`
    ///
    #[parol_runtime::function_name::named]
    fn key_val_sep(&mut self, key_val_sep: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_val_sep = key_val_sep.token()?.clone();
        let key_val_sep_built = KeyValSep { key_val_sep };
        // Calling user action here
        self.user_grammar.key_val_sep(&key_val_sep_built)?;
        self.push(ASTType::KeyValSep(key_val_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `Val: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn val_0(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let val_0_built = ValBoolean { boolean };
        let val_0_built = Val::Boolean(val_0_built);
        // Calling user action here
        self.user_grammar.val(&val_0_built)?;
        self.push(ASTType::Val(val_0_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `Val: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn val_1(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let val_1_built = ValArray {
            array: Box::new(array),
        };
        let val_1_built = Val::Array(val_1_built);
        // Calling user action here
        self.user_grammar.val(&val_1_built)?;
        self.push(ASTType::Val(val_1_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `Val: InlineTable;`
    ///
    #[parol_runtime::function_name::named]
    fn val_2(&mut self, _inline_table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table = pop_item!(self, inline_table, InlineTable, context);
        let val_2_built = ValInlineTable {
            inline_table: Box::new(inline_table),
        };
        let val_2_built = Val::InlineTable(val_2_built);
        // Calling user action here
        self.user_grammar.val(&val_2_built)?;
        self.push(ASTType::Val(val_2_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Val: DateTime;`
    ///
    #[parol_runtime::function_name::named]
    fn val_3(&mut self, _date_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let date_time = pop_item!(self, date_time, DateTime, context);
        let val_3_built = ValDateTime { date_time };
        let val_3_built = Val::DateTime(val_3_built);
        // Calling user action here
        self.user_grammar.val(&val_3_built)?;
        self.push(ASTType::Val(val_3_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `Val: Numeric;`
    ///
    #[parol_runtime::function_name::named]
    fn val_4(&mut self, _numeric: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let numeric = pop_item!(self, numeric, Numeric, context);
        let val_4_built = ValNumeric { numeric };
        let val_4_built = Val::Numeric(val_4_built);
        // Calling user action here
        self.user_grammar.val(&val_4_built)?;
        self.push(ASTType::Val(val_4_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `Val: BasicString;`
    ///
    #[parol_runtime::function_name::named]
    fn val_5(&mut self, _basic_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string = pop_item!(self, basic_string, BasicString, context);
        let val_5_built = ValBasicString { basic_string };
        let val_5_built = Val::BasicString(val_5_built);
        // Calling user action here
        self.user_grammar.val(&val_5_built)?;
        self.push(ASTType::Val(val_5_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `Val: MLBasicString;`
    ///
    #[parol_runtime::function_name::named]
    fn val_6(&mut self, _m_l_basic_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string = pop_item!(self, m_l_basic_string, MLBasicString, context);
        let val_6_built = ValMLBasicString { m_l_basic_string };
        let val_6_built = Val::MLBasicString(val_6_built);
        // Calling user action here
        self.user_grammar.val(&val_6_built)?;
        self.push(ASTType::Val(val_6_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `Val: LiteralString;`
    ///
    #[parol_runtime::function_name::named]
    fn val_7(&mut self, _literal_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = pop_item!(self, literal_string, LiteralString, context);
        let val_7_built = ValLiteralString { literal_string };
        let val_7_built = Val::LiteralString(val_7_built);
        // Calling user action here
        self.user_grammar.val(&val_7_built)?;
        self.push(ASTType::Val(val_7_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `Val: MLLiteralString;`
    ///
    #[parol_runtime::function_name::named]
    fn val_8(&mut self, _m_l_literal_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string = pop_item!(self, m_l_literal_string, MLLiteralString, context);
        let val_8_built = ValMLLiteralString { m_l_literal_string };
        let val_8_built = Val::MLLiteralString(val_8_built);
        // Calling user action here
        self.user_grammar.val(&val_8_built)?;
        self.push(ASTType::Val(val_8_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `Numeric: Float;`
    ///
    #[parol_runtime::function_name::named]
    fn numeric_0(&mut self, _float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = pop_item!(self, float, Float, context);
        let numeric_0_built = NumericFloat { float };
        let numeric_0_built = Numeric::Float(numeric_0_built);
        // Calling user action here
        self.user_grammar.numeric(&numeric_0_built)?;
        self.push(ASTType::Numeric(numeric_0_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `Numeric: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn numeric_1(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let numeric_1_built = NumericInteger { integer };
        let numeric_1_built = Numeric::Integer(numeric_1_built);
        // Calling user action here
        self.user_grammar.numeric(&numeric_1_built)?;
        self.push(ASTType::Numeric(numeric_1_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `BasicString: QuotationMark %push(BString) BasicStringList /* Vec */ %pop() QuotationMark;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_string(
        &mut self,
        _quotation_mark: &ParseTreeType<'t>,
        _basic_string_list: &ParseTreeType<'t>,
        _quotation_mark0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark0 = pop_item!(self, quotation_mark0, QuotationMark, context);
        let basic_string_list =
            pop_and_reverse_item!(self, basic_string_list, BasicStringList, context);
        let quotation_mark = pop_item!(self, quotation_mark, QuotationMark, context);
        let basic_string_built = BasicString {
            quotation_mark,
            basic_string_list,
            quotation_mark0,
        };
        // Calling user action here
        self.user_grammar.basic_string(&basic_string_built)?;
        self.push(ASTType::BasicString(basic_string_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `BasicStringList /* Vec<T>::Push */: BasicChar BasicStringList;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_string_list_0(
        &mut self,
        _basic_char: &ParseTreeType<'t>,
        _basic_string_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut basic_string_list = pop_item!(self, basic_string_list, BasicStringList, context);
        let basic_char = pop_item!(self, basic_char, BasicChar, context);
        let basic_string_list_0_built = BasicStringList { basic_char };
        // Add an element to the vector
        basic_string_list.push(basic_string_list_0_built);
        self.push(ASTType::BasicStringList(basic_string_list), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `BasicStringList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_string_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string_list_1_built = Vec::new();
        self.push(ASTType::BasicStringList(basic_string_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `BasicChar: BasicUnescaped;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_char_0(&mut self, _basic_unescaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_unescaped = pop_item!(self, basic_unescaped, BasicUnescaped, context);
        let basic_char_0_built = BasicCharBasicUnescaped { basic_unescaped };
        let basic_char_0_built = BasicChar::BasicUnescaped(basic_char_0_built);
        // Calling user action here
        self.user_grammar.basic_char(&basic_char_0_built)?;
        self.push(ASTType::BasicChar(basic_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `BasicChar: %push(Esc) Escaped %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn basic_char_1(&mut self, _escaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = pop_item!(self, escaped, Escaped, context);
        let basic_char_1_built = BasicCharEscaped { escaped };
        let basic_char_1_built = BasicChar::Escaped(basic_char_1_built);
        // Calling user action here
        self.user_grammar.basic_char(&basic_char_1_built)?;
        self.push(ASTType::BasicChar(basic_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `BasicUnescaped: AsciiNoEscape;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_unescaped_0(&mut self, _ascii_no_escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let basic_unescaped_0_built = BasicUnescapedAsciiNoEscape { ascii_no_escape };
        let basic_unescaped_0_built = BasicUnescaped::AsciiNoEscape(basic_unescaped_0_built);
        // Calling user action here
        self.user_grammar
            .basic_unescaped(&basic_unescaped_0_built)?;
        self.push(ASTType::BasicUnescaped(basic_unescaped_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `BasicUnescaped: NonAscii;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_unescaped_1(&mut self, _non_ascii: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let basic_unescaped_1_built = BasicUnescapedNonAscii { non_ascii };
        let basic_unescaped_1_built = BasicUnescaped::NonAscii(basic_unescaped_1_built);
        // Calling user action here
        self.user_grammar
            .basic_unescaped(&basic_unescaped_1_built)?;
        self.push(ASTType::BasicUnescaped(basic_unescaped_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `Escaped: Escape EscapeSeqChar;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped(
        &mut self,
        _escape: &ParseTreeType<'t>,
        _escape_seq_char: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape_seq_char = pop_item!(self, escape_seq_char, EscapeSeqChar, context);
        let escape = pop_item!(self, escape, Escape, context);
        let escaped_built = Escaped {
            escape,
            escape_seq_char,
        };
        // Calling user action here
        self.user_grammar.escaped(&escaped_built)?;
        self.push(ASTType::Escaped(escaped_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `Escape: <Esc, BString, MLBString>"\u{5C}";`
    ///
    #[parol_runtime::function_name::named]
    fn escape(&mut self, escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape = escape.token()?.clone();
        let escape_built = Escape { escape };
        // Calling user action here
        self.user_grammar.escape(&escape_built)?;
        self.push(ASTType::Escape(escape_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `EscapeSeqChar: QuotationMark;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_0(&mut self, _quotation_mark: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark = pop_item!(self, quotation_mark, QuotationMark, context);
        let escape_seq_char_0_built = EscapeSeqCharQuotationMark { quotation_mark };
        let escape_seq_char_0_built = EscapeSeqChar::QuotationMark(escape_seq_char_0_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_0_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `EscapeSeqChar: Escape;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_1(&mut self, _escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape = pop_item!(self, escape, Escape, context);
        let escape_seq_char_1_built = EscapeSeqCharEscape { escape };
        let escape_seq_char_1_built = EscapeSeqChar::Escape(escape_seq_char_1_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_1_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `EscapeSeqChar: <Esc>"b";`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_2(&mut self, b: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = b.token()?.clone();
        let escape_seq_char_2_built = EscapeSeqCharB { b };
        let escape_seq_char_2_built = EscapeSeqChar::B(escape_seq_char_2_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_2_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_2_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `EscapeSeqChar: <Esc>"f";`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_3(&mut self, f: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f = f.token()?.clone();
        let escape_seq_char_3_built = EscapeSeqCharF { f };
        let escape_seq_char_3_built = EscapeSeqChar::F(escape_seq_char_3_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_3_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_3_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `EscapeSeqChar: <Esc>"n";`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_4(&mut self, n: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let n = n.token()?.clone();
        let escape_seq_char_4_built = EscapeSeqCharN { n };
        let escape_seq_char_4_built = EscapeSeqChar::N(escape_seq_char_4_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_4_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_4_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `EscapeSeqChar: <Esc>"r";`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_5(&mut self, r: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r = r.token()?.clone();
        let escape_seq_char_5_built = EscapeSeqCharR { r };
        let escape_seq_char_5_built = EscapeSeqChar::R(escape_seq_char_5_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_5_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_5_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `EscapeSeqChar: <Esc>"t";`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_6(&mut self, t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t = t.token()?.clone();
        let escape_seq_char_6_built = EscapeSeqCharT { t };
        let escape_seq_char_6_built = EscapeSeqChar::T(escape_seq_char_6_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_6_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_6_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `EscapeSeqChar: Unicode4;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_7(&mut self, _unicode4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = pop_item!(self, unicode4, Unicode4, context);
        let escape_seq_char_7_built = EscapeSeqCharUnicode4 { unicode4 };
        let escape_seq_char_7_built = EscapeSeqChar::Unicode4(escape_seq_char_7_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_7_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_7_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `EscapeSeqChar: Unicode8;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_8(&mut self, _unicode8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = pop_item!(self, unicode8, Unicode8, context);
        let escape_seq_char_8_built = EscapeSeqCharUnicode8 { unicode8 };
        let escape_seq_char_8_built = EscapeSeqChar::Unicode8(escape_seq_char_8_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_8_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_8_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `EscapeSeqChar: WsNewline;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_9(&mut self, _ws_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws_newline = pop_item!(self, ws_newline, WsNewline, context);
        let escape_seq_char_9_built = EscapeSeqCharWsNewline { ws_newline };
        let escape_seq_char_9_built = EscapeSeqChar::WsNewline(escape_seq_char_9_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_9_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_9_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `EscapeSeqChar: AsciiNoEscape;`
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_10(&mut self, _ascii_no_escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let escape_seq_char_10_built = EscapeSeqCharAsciiNoEscape { ascii_no_escape };
        let escape_seq_char_10_built = EscapeSeqChar::AsciiNoEscape(escape_seq_char_10_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_10_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_10_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `Unicode4: <Esc>"u[0-9a-fA-F]{4}";`
    ///
    #[parol_runtime::function_name::named]
    fn unicode4(&mut self, unicode4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = unicode4.token()?.clone();
        let unicode4_built = Unicode4 { unicode4 };
        // Calling user action here
        self.user_grammar.unicode4(&unicode4_built)?;
        self.push(ASTType::Unicode4(unicode4_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `Unicode8: <Esc>"U[0-9a-fA-F]{8}";`
    ///
    #[parol_runtime::function_name::named]
    fn unicode8(&mut self, unicode8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = unicode8.token()?.clone();
        let unicode8_built = Unicode8 { unicode8 };
        // Calling user action here
        self.user_grammar.unicode8(&unicode8_built)?;
        self.push(ASTType::Unicode8(unicode8_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `MLBasicString: MLBasicStringStart %push(MLBString) MLBasicBody MLBasicStringEnd %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string(
        &mut self,
        _m_l_basic_string_start: &ParseTreeType<'t>,
        _m_l_basic_body: &ParseTreeType<'t>,
        _m_l_basic_string_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_end = pop_item!(self, m_l_basic_string_end, MLBasicStringEnd, context);
        let m_l_basic_body = pop_item!(self, m_l_basic_body, MLBasicBody, context);
        let m_l_basic_string_start =
            pop_item!(self, m_l_basic_string_start, MLBasicStringStart, context);
        let m_l_basic_string_built = MLBasicString {
            m_l_basic_string_start,
            m_l_basic_body,
            m_l_basic_string_end,
        };
        // Calling user action here
        self.user_grammar
            .m_l_basic_string(&m_l_basic_string_built)?;
        self.push(ASTType::MLBasicString(m_l_basic_string_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `MLBasicBody: MLBContentList MLBasicBodyList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body(
        &mut self,
        _m_l_b_content_list: &ParseTreeType<'t>,
        _m_l_basic_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_body_list =
            pop_and_reverse_item!(self, m_l_basic_body_list, MLBasicBodyList, context);
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_basic_body_built = MLBasicBody {
            m_l_b_content_list,
            m_l_basic_body_list,
        };
        // Calling user action here
        self.user_grammar.m_l_basic_body(&m_l_basic_body_built)?;
        self.push(ASTType::MLBasicBody(m_l_basic_body_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `MLBasicBodyList /* Vec<T>::Push */: MLBQuotes MLBContentList1 MLBasicBodyList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body_list_0(
        &mut self,
        _m_l_b_quotes: &ParseTreeType<'t>,
        _m_l_b_content_list1: &ParseTreeType<'t>,
        _m_l_basic_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut m_l_basic_body_list =
            pop_item!(self, m_l_basic_body_list, MLBasicBodyList, context);
        let m_l_b_content_list1 = pop_item!(self, m_l_b_content_list1, MLBContentList1, context);
        let m_l_b_quotes = pop_item!(self, m_l_b_quotes, MLBQuotes, context);
        let m_l_basic_body_list_0_built = MLBasicBodyList {
            m_l_b_content_list1,
            m_l_b_quotes,
        };
        // Add an element to the vector
        m_l_basic_body_list.push(m_l_basic_body_list_0_built);
        self.push(ASTType::MLBasicBodyList(m_l_basic_body_list), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `MLBasicBodyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_body_list_1_built = Vec::new();
        self.push(
            ASTType::MLBasicBodyList(m_l_basic_body_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `MLBContentList: MLBContent MLBContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list_0(
        &mut self,
        _m_l_b_content: &ParseTreeType<'t>,
        _m_l_b_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_b_content = pop_item!(self, m_l_b_content, MLBContent, context);
        let m_l_b_content_list_0_built = MLBContentListMLBContentMLBContentList {
            m_l_b_content,
            m_l_b_content_list: Box::new(m_l_b_content_list),
        };
        let m_l_b_content_list_0_built =
            MLBContentList::MLBContentMLBContentList(m_l_b_content_list_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list(&m_l_b_content_list_0_built)?;
        self.push(ASTType::MLBContentList(m_l_b_content_list_0_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `MLBContentList: ;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list_1_built = MLBContentListMLBContentListEmpty {};
        let m_l_b_content_list_1_built =
            MLBContentList::MLBContentListEmpty(m_l_b_content_list_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list(&m_l_b_content_list_1_built)?;
        self.push(ASTType::MLBContentList(m_l_b_content_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `MLBContentList1: MLBContent MLBContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list1(
        &mut self,
        _m_l_b_content: &ParseTreeType<'t>,
        _m_l_b_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_b_content = pop_item!(self, m_l_b_content, MLBContent, context);
        let m_l_b_content_list1_built = MLBContentList1 {
            m_l_b_content,
            m_l_b_content_list,
        };
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list1(&m_l_b_content_list1_built)?;
        self.push(ASTType::MLBContentList1(m_l_b_content_list1_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `MLBContent: MLBChar;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_0(&mut self, _m_l_b_char: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_char = pop_item!(self, m_l_b_char, MLBChar, context);
        let m_l_b_content_0_built = MLBContentMLBChar { m_l_b_char };
        let m_l_b_content_0_built = MLBContent::MLBChar(m_l_b_content_0_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_0_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_0_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `MLBContent: Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_1(&mut self, _newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let m_l_b_content_1_built = MLBContentNewline { newline };
        let m_l_b_content_1_built = MLBContent::Newline(m_l_b_content_1_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_1_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `MLBContent: MLBEscapedNL;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_2(&mut self, _m_l_b_escaped_n_l: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_escaped_n_l = pop_item!(self, m_l_b_escaped_n_l, MLBEscapedNL, context);
        let m_l_b_content_2_built = MLBContentMLBEscapedNL { m_l_b_escaped_n_l };
        let m_l_b_content_2_built = MLBContent::MLBEscapedNL(m_l_b_content_2_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_2_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_2_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `MLBChar: MLBUnescaped;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_char_0(&mut self, _m_l_b_unescaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_unescaped = pop_item!(self, m_l_b_unescaped, MLBUnescaped, context);
        let m_l_b_char_0_built = MLBCharMLBUnescaped { m_l_b_unescaped };
        let m_l_b_char_0_built = MLBChar::MLBUnescaped(m_l_b_char_0_built);
        // Calling user action here
        self.user_grammar.m_l_b_char(&m_l_b_char_0_built)?;
        self.push(ASTType::MLBChar(m_l_b_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `MLBChar: %push(Esc) Escaped %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_char_1(&mut self, _escaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = pop_item!(self, escaped, Escaped, context);
        let m_l_b_char_1_built = MLBCharEscaped { escaped };
        let m_l_b_char_1_built = MLBChar::Escaped(m_l_b_char_1_built);
        // Calling user action here
        self.user_grammar.m_l_b_char(&m_l_b_char_1_built)?;
        self.push(ASTType::MLBChar(m_l_b_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `MLBUnescaped: AsciiNoEscape;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_unescaped_0(&mut self, _ascii_no_escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let m_l_b_unescaped_0_built = MLBUnescapedAsciiNoEscape { ascii_no_escape };
        let m_l_b_unescaped_0_built = MLBUnescaped::AsciiNoEscape(m_l_b_unescaped_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_unescaped(&m_l_b_unescaped_0_built)?;
        self.push(ASTType::MLBUnescaped(m_l_b_unescaped_0_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `MLBUnescaped: NonAscii;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_unescaped_1(&mut self, _non_ascii: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let m_l_b_unescaped_1_built = MLBUnescapedNonAscii { non_ascii };
        let m_l_b_unescaped_1_built = MLBUnescaped::NonAscii(m_l_b_unescaped_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_unescaped(&m_l_b_unescaped_1_built)?;
        self.push(ASTType::MLBUnescaped(m_l_b_unescaped_1_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `MLBEscapedNL: <MLBString>"\u{5C}[ \t]*\r?\n([ \t]|\r?\n)*";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_escaped_n_l(&mut self, m_l_b_escaped_n_l: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_escaped_n_l = m_l_b_escaped_n_l.token()?.clone();
        let m_l_b_escaped_n_l_built = MLBEscapedNL { m_l_b_escaped_n_l };
        // Calling user action here
        self.user_grammar
            .m_l_b_escaped_n_l(&m_l_b_escaped_n_l_built)?;
        self.push(ASTType::MLBEscapedNL(m_l_b_escaped_n_l_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `LiteralString: Apostrophe^ /* Clipped */ %push(LString) LiteralStringList /* Vec */ %pop() Apostrophe^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn literal_string(
        &mut self,
        _apostrophe: &ParseTreeType<'t>,
        _literal_string_list: &ParseTreeType<'t>,
        _apostrophe0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let literal_string_list =
            pop_and_reverse_item!(self, literal_string_list, LiteralStringList, context);
        self.pop(context);
        let literal_string_built = LiteralString {
            literal_string_list,
        };
        // Calling user action here
        self.user_grammar.literal_string(&literal_string_built)?;
        self.push(ASTType::LiteralString(literal_string_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `LiteralStringList /* Vec<T>::Push */: LiteralChar LiteralStringList;`
    ///
    #[parol_runtime::function_name::named]
    fn literal_string_list_0(
        &mut self,
        _literal_char: &ParseTreeType<'t>,
        _literal_string_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut literal_string_list =
            pop_item!(self, literal_string_list, LiteralStringList, context);
        let literal_char = pop_item!(self, literal_char, LiteralChar, context);
        let literal_string_list_0_built = LiteralStringList { literal_char };
        // Add an element to the vector
        literal_string_list.push(literal_string_list_0_built);
        self.push(ASTType::LiteralStringList(literal_string_list), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `LiteralStringList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn literal_string_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string_list_1_built = Vec::new();
        self.push(
            ASTType::LiteralStringList(literal_string_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `LiteralChar: LiteralCharNoApostrophe;`
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_0(&mut self, _literal_char_no_apostrophe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char_no_apostrophe = pop_item!(
            self,
            literal_char_no_apostrophe,
            LiteralCharNoApostrophe,
            context
        );
        let literal_char_0_built = LiteralCharLiteralCharNoApostrophe {
            literal_char_no_apostrophe,
        };
        let literal_char_0_built = LiteralChar::LiteralCharNoApostrophe(literal_char_0_built);
        // Calling user action here
        self.user_grammar.literal_char(&literal_char_0_built)?;
        self.push(ASTType::LiteralChar(literal_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `LiteralChar: NonAscii;`
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_1(&mut self, _non_ascii: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let literal_char_1_built = LiteralCharNonAscii { non_ascii };
        let literal_char_1_built = LiteralChar::NonAscii(literal_char_1_built);
        // Calling user action here
        self.user_grammar.literal_char(&literal_char_1_built)?;
        self.push(ASTType::LiteralChar(literal_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `LiteralCharNoApostrophe: <LString, MLLString>"[\t\u{20}-\u{26}\u{28}-\u{7E}]+";`
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_no_apostrophe(
        &mut self,
        literal_char_no_apostrophe: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char_no_apostrophe = literal_char_no_apostrophe.token()?.clone();
        let literal_char_no_apostrophe_built = LiteralCharNoApostrophe {
            literal_char_no_apostrophe,
        };
        // Calling user action here
        self.user_grammar
            .literal_char_no_apostrophe(&literal_char_no_apostrophe_built)?;
        self.push(
            ASTType::LiteralCharNoApostrophe(literal_char_no_apostrophe_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `MLLiteralString: MLLiteralStringStart^ /* Clipped */ %push(MLLString) MLLiteralBody %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string(
        &mut self,
        _m_l_literal_string_start: &ParseTreeType<'t>,
        _m_l_literal_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_body = pop_item!(self, m_l_literal_body, MLLiteralBody, context);
        self.pop(context);
        let m_l_literal_string_built = MLLiteralString { m_l_literal_body };
        // Calling user action here
        self.user_grammar
            .m_l_literal_string(&m_l_literal_string_built)?;
        self.push(ASTType::MLLiteralString(m_l_literal_string_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `MLLiteralBody: MLLContentList MLLiteralBodyList /* Vec */ MLLiteralStringEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body(
        &mut self,
        _m_l_l_content_list: &ParseTreeType<'t>,
        _m_l_literal_body_list: &ParseTreeType<'t>,
        _m_l_literal_string_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let m_l_literal_body_list =
            pop_and_reverse_item!(self, m_l_literal_body_list, MLLiteralBodyList, context);
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_literal_body_built = MLLiteralBody {
            m_l_l_content_list,
            m_l_literal_body_list,
        };
        // Calling user action here
        self.user_grammar
            .m_l_literal_body(&m_l_literal_body_built)?;
        self.push(ASTType::MLLiteralBody(m_l_literal_body_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `MLLiteralBodyList /* Vec<T>::Push */: MLLQuotes MLLContentList1 MLLiteralBodyList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body_list_0(
        &mut self,
        _m_l_l_quotes: &ParseTreeType<'t>,
        _m_l_l_content_list1: &ParseTreeType<'t>,
        _m_l_literal_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut m_l_literal_body_list =
            pop_item!(self, m_l_literal_body_list, MLLiteralBodyList, context);
        let m_l_l_content_list1 = pop_item!(self, m_l_l_content_list1, MLLContentList1, context);
        let m_l_l_quotes = pop_item!(self, m_l_l_quotes, MLLQuotes, context);
        let m_l_literal_body_list_0_built = MLLiteralBodyList {
            m_l_l_content_list1,
            m_l_l_quotes,
        };
        // Add an element to the vector
        m_l_literal_body_list.push(m_l_literal_body_list_0_built);
        self.push(ASTType::MLLiteralBodyList(m_l_literal_body_list), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `MLLiteralBodyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_body_list_1_built = Vec::new();
        self.push(
            ASTType::MLLiteralBodyList(m_l_literal_body_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `MLLContentList: MLLContent MLLContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list_0(
        &mut self,
        _m_l_l_content: &ParseTreeType<'t>,
        _m_l_l_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_l_content = pop_item!(self, m_l_l_content, MLLContent, context);
        let m_l_l_content_list_0_built = MLLContentListMLLContentMLLContentList {
            m_l_l_content,
            m_l_l_content_list: Box::new(m_l_l_content_list),
        };
        let m_l_l_content_list_0_built =
            MLLContentList::MLLContentMLLContentList(m_l_l_content_list_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list(&m_l_l_content_list_0_built)?;
        self.push(ASTType::MLLContentList(m_l_l_content_list_0_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `MLLContentList: ;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list_1_built = MLLContentListMLLContentListEmpty {};
        let m_l_l_content_list_1_built =
            MLLContentList::MLLContentListEmpty(m_l_l_content_list_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list(&m_l_l_content_list_1_built)?;
        self.push(ASTType::MLLContentList(m_l_l_content_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `MLLContentList1: MLLContent MLLContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list1(
        &mut self,
        _m_l_l_content: &ParseTreeType<'t>,
        _m_l_l_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_l_content = pop_item!(self, m_l_l_content, MLLContent, context);
        let m_l_l_content_list1_built = MLLContentList1 {
            m_l_l_content,
            m_l_l_content_list,
        };
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list1(&m_l_l_content_list1_built)?;
        self.push(ASTType::MLLContentList1(m_l_l_content_list1_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `MLLContent: LiteralChar;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_0(&mut self, _literal_char: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char = pop_item!(self, literal_char, LiteralChar, context);
        let m_l_l_content_0_built = MLLContentLiteralChar { literal_char };
        let m_l_l_content_0_built = MLLContent::LiteralChar(m_l_l_content_0_built);
        // Calling user action here
        self.user_grammar.m_l_l_content(&m_l_l_content_0_built)?;
        self.push(ASTType::MLLContent(m_l_l_content_0_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `MLLContent: Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_1(&mut self, _newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let m_l_l_content_1_built = MLLContentNewline { newline };
        let m_l_l_content_1_built = MLLContent::Newline(m_l_l_content_1_built);
        // Calling user action here
        self.user_grammar.m_l_l_content(&m_l_l_content_1_built)?;
        self.push(ASTType::MLLContent(m_l_l_content_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `Integer: DecInt;`
    ///
    #[parol_runtime::function_name::named]
    fn integer_0(&mut self, _dec_int: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dec_int = pop_item!(self, dec_int, DecInt, context);
        let integer_0_built = IntegerDecInt { dec_int };
        let integer_0_built = Integer::DecInt(integer_0_built);
        // Calling user action here
        self.user_grammar.integer(&integer_0_built)?;
        self.push(ASTType::Integer(integer_0_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `Integer: HexInt;`
    ///
    #[parol_runtime::function_name::named]
    fn integer_1(&mut self, _hex_int: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int = pop_item!(self, hex_int, HexInt, context);
        let integer_1_built = IntegerHexInt { hex_int };
        let integer_1_built = Integer::HexInt(integer_1_built);
        // Calling user action here
        self.user_grammar.integer(&integer_1_built)?;
        self.push(ASTType::Integer(integer_1_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `Integer: OctInt;`
    ///
    #[parol_runtime::function_name::named]
    fn integer_2(&mut self, _oct_int: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int = pop_item!(self, oct_int, OctInt, context);
        let integer_2_built = IntegerOctInt { oct_int };
        let integer_2_built = Integer::OctInt(integer_2_built);
        // Calling user action here
        self.user_grammar.integer(&integer_2_built)?;
        self.push(ASTType::Integer(integer_2_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `Integer: BinInt;`
    ///
    #[parol_runtime::function_name::named]
    fn integer_3(&mut self, _bin_int: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int = pop_item!(self, bin_int, BinInt, context);
        let integer_3_built = IntegerBinInt { bin_int };
        let integer_3_built = Integer::BinInt(integer_3_built);
        // Calling user action here
        self.user_grammar.integer(&integer_3_built)?;
        self.push(ASTType::Integer(integer_3_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `HexPrefix: <Val>"0x";`
    ///
    #[parol_runtime::function_name::named]
    fn hex_prefix(&mut self, hex_prefix: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_prefix = hex_prefix.token()?.clone();
        let hex_prefix_built = HexPrefix { hex_prefix };
        // Calling user action here
        self.user_grammar.hex_prefix(&hex_prefix_built)?;
        self.push(ASTType::HexPrefix(hex_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `OctPrefix: <Val>"0o";`
    ///
    #[parol_runtime::function_name::named]
    fn oct_prefix(&mut self, oct_prefix: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_prefix = oct_prefix.token()?.clone();
        let oct_prefix_built = OctPrefix { oct_prefix };
        // Calling user action here
        self.user_grammar.oct_prefix(&oct_prefix_built)?;
        self.push(ASTType::OctPrefix(oct_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `BinPrefix: <Val>"0b";`
    ///
    #[parol_runtime::function_name::named]
    fn bin_prefix(&mut self, bin_prefix: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_prefix = bin_prefix.token()?.clone();
        let bin_prefix_built = BinPrefix { bin_prefix };
        // Calling user action here
        self.user_grammar.bin_prefix(&bin_prefix_built)?;
        self.push(ASTType::BinPrefix(bin_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `DecInt: DecIntOpt /* Option */ UnsignedDecInt;`
    ///
    #[parol_runtime::function_name::named]
    fn dec_int(
        &mut self,
        _dec_int_opt: &ParseTreeType<'t>,
        _unsigned_dec_int: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_dec_int = pop_item!(self, unsigned_dec_int, UnsignedDecInt, context);
        let dec_int_opt = pop_item!(self, dec_int_opt, DecIntOpt, context);
        let dec_int_built = DecInt {
            dec_int_opt,
            unsigned_dec_int,
        };
        // Calling user action here
        self.user_grammar.dec_int(&dec_int_built)?;
        self.push(ASTType::DecInt(dec_int_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `DecIntOpt /* Option<T>::Some */: DecIntOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_0(&mut self, _dec_int_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dec_int_opt_group = pop_item!(self, dec_int_opt_group, DecIntOptGroup, context);
        let dec_int_opt_0_built = DecIntOpt { dec_int_opt_group };
        self.push(ASTType::DecIntOpt(Some(dec_int_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `DecIntOptGroup: Plus;`
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_group_0(&mut self, _plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let dec_int_opt_group_0_built = DecIntOptGroupPlus { plus };
        let dec_int_opt_group_0_built = DecIntOptGroup::Plus(dec_int_opt_group_0_built);
        self.push(ASTType::DecIntOptGroup(dec_int_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `DecIntOptGroup: Minus;`
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_group_1(&mut self, _minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let dec_int_opt_group_1_built = DecIntOptGroupMinus { minus };
        let dec_int_opt_group_1_built = DecIntOptGroup::Minus(dec_int_opt_group_1_built);
        self.push(ASTType::DecIntOptGroup(dec_int_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `DecIntOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DecIntOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `HexInt: HexPrefix^ /* Clipped */ %push(HexInt) HexIntContent %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn hex_int(
        &mut self,
        _hex_prefix: &ParseTreeType<'t>,
        _hex_int_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int_content = pop_item!(self, hex_int_content, HexIntContent, context);
        self.pop(context);
        let hex_int_built = HexInt { hex_int_content };
        // Calling user action here
        self.user_grammar.hex_int(&hex_int_built)?;
        self.push(ASTType::HexInt(hex_int_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `HexIntContent: <HexInt>"[0-9a-fA-F]([0-9a-fA-F]|_[0-9a-fA-F])*";`
    ///
    #[parol_runtime::function_name::named]
    fn hex_int_content(&mut self, hex_int_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int_content = hex_int_content.token()?.clone();
        let hex_int_content_built = HexIntContent { hex_int_content };
        // Calling user action here
        self.user_grammar.hex_int_content(&hex_int_content_built)?;
        self.push(ASTType::HexIntContent(hex_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `OctInt: OctPrefix^ /* Clipped */ %push(OctInt) OctIntContent %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn oct_int(
        &mut self,
        _oct_prefix: &ParseTreeType<'t>,
        _oct_int_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int_content = pop_item!(self, oct_int_content, OctIntContent, context);
        self.pop(context);
        let oct_int_built = OctInt { oct_int_content };
        // Calling user action here
        self.user_grammar.oct_int(&oct_int_built)?;
        self.push(ASTType::OctInt(oct_int_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `OctIntContent: <OctInt>"[0-7]([0-7]|_[0-7])*";`
    ///
    #[parol_runtime::function_name::named]
    fn oct_int_content(&mut self, oct_int_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int_content = oct_int_content.token()?.clone();
        let oct_int_content_built = OctIntContent { oct_int_content };
        // Calling user action here
        self.user_grammar.oct_int_content(&oct_int_content_built)?;
        self.push(ASTType::OctIntContent(oct_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `BinInt: BinPrefix^ /* Clipped */ %push(BinInt) BinIntContent %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn bin_int(
        &mut self,
        _bin_prefix: &ParseTreeType<'t>,
        _bin_int_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int_content = pop_item!(self, bin_int_content, BinIntContent, context);
        self.pop(context);
        let bin_int_built = BinInt { bin_int_content };
        // Calling user action here
        self.user_grammar.bin_int(&bin_int_built)?;
        self.push(ASTType::BinInt(bin_int_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `BinIntContent: <BinInt>"[01]([01]|_[01])*";`
    ///
    #[parol_runtime::function_name::named]
    fn bin_int_content(&mut self, bin_int_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int_content = bin_int_content.token()?.clone();
        let bin_int_content_built = BinIntContent { bin_int_content };
        // Calling user action here
        self.user_grammar.bin_int_content(&bin_int_content_built)?;
        self.push(ASTType::BinIntContent(bin_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `Boolean: <Val>"true";`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token()?.clone();
        let boolean_0_built = BooleanTrue { r#true };
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `Boolean: <Val>"false";`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token()?.clone();
        let boolean_1_built = BooleanFalse { r#false };
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `Float: NormalFloat;`
    ///
    #[parol_runtime::function_name::named]
    fn float_0(&mut self, _normal_float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let normal_float = pop_item!(self, normal_float, NormalFloat, context);
        let float_0_built = FloatNormalFloat { normal_float };
        let float_0_built = Float::NormalFloat(float_0_built);
        // Calling user action here
        self.user_grammar.float(&float_0_built)?;
        self.push(ASTType::Float(float_0_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `Float: SpecialFloat;`
    ///
    #[parol_runtime::function_name::named]
    fn float_1(&mut self, _special_float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let special_float = pop_item!(self, special_float, SpecialFloat, context);
        let float_1_built = FloatSpecialFloat { special_float };
        let float_1_built = Float::SpecialFloat(float_1_built);
        // Calling user action here
        self.user_grammar.float(&float_1_built)?;
        self.push(ASTType::Float(float_1_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `NormalFloat: <Val>"[-+]?(?:0|[1-9](?:[0-9]|_[0-9])*)(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*|(?:\.[0-9](?:[0-9]|_[0-9])*(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*)?))";`
    ///
    #[parol_runtime::function_name::named]
    fn normal_float(&mut self, normal_float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let normal_float = normal_float.token()?.clone();
        let normal_float_built = NormalFloat { normal_float };
        // Calling user action here
        self.user_grammar.normal_float(&normal_float_built)?;
        self.push(ASTType::NormalFloat(normal_float_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `SpecialFloat: <Val>"[-+]?(nan|inf)";`
    ///
    #[parol_runtime::function_name::named]
    fn special_float(&mut self, special_float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let special_float = special_float.token()?.clone();
        let special_float_built = SpecialFloat { special_float };
        // Calling user action here
        self.user_grammar.special_float(&special_float_built)?;
        self.push(ASTType::SpecialFloat(special_float_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `DateTime: OffsetDateTime;`
    ///
    #[parol_runtime::function_name::named]
    fn date_time_0(&mut self, _offset_date_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let offset_date_time = pop_item!(self, offset_date_time, OffsetDateTime, context);
        let date_time_0_built = DateTimeOffsetDateTime { offset_date_time };
        let date_time_0_built = DateTime::OffsetDateTime(date_time_0_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_0_built)?;
        self.push(ASTType::DateTime(date_time_0_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `DateTime: LocalDateTime;`
    ///
    #[parol_runtime::function_name::named]
    fn date_time_1(&mut self, _local_date_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date_time = pop_item!(self, local_date_time, LocalDateTime, context);
        let date_time_1_built = DateTimeLocalDateTime { local_date_time };
        let date_time_1_built = DateTime::LocalDateTime(date_time_1_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_1_built)?;
        self.push(ASTType::DateTime(date_time_1_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `DateTime: LocalDate;`
    ///
    #[parol_runtime::function_name::named]
    fn date_time_2(&mut self, _local_date: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date = pop_item!(self, local_date, LocalDate, context);
        let date_time_2_built = DateTimeLocalDate { local_date };
        let date_time_2_built = DateTime::LocalDate(date_time_2_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_2_built)?;
        self.push(ASTType::DateTime(date_time_2_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `DateTime: LocalTime;`
    ///
    #[parol_runtime::function_name::named]
    fn date_time_3(&mut self, _local_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_time = pop_item!(self, local_time, LocalTime, context);
        let date_time_3_built = DateTimeLocalTime { local_time };
        let date_time_3_built = DateTime::LocalTime(date_time_3_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_3_built)?;
        self.push(ASTType::DateTime(date_time_3_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `OffsetDateTime: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)?([Zz]|[-+][0-9]{2}(:[0-9]{2})?)?";`
    ///
    #[parol_runtime::function_name::named]
    fn offset_date_time(&mut self, offset_date_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let offset_date_time = offset_date_time.token()?.clone();
        let offset_date_time_built = OffsetDateTime { offset_date_time };
        // Calling user action here
        self.user_grammar
            .offset_date_time(&offset_date_time_built)?;
        self.push(ASTType::OffsetDateTime(offset_date_time_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `LocalDateTime: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)?[Zz]?";`
    ///
    #[parol_runtime::function_name::named]
    fn local_date_time(&mut self, local_date_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date_time = local_date_time.token()?.clone();
        let local_date_time_built = LocalDateTime { local_date_time };
        // Calling user action here
        self.user_grammar.local_date_time(&local_date_time_built)?;
        self.push(ASTType::LocalDateTime(local_date_time_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `LocalDate: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}";`
    ///
    #[parol_runtime::function_name::named]
    fn local_date(&mut self, local_date: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date = local_date.token()?.clone();
        let local_date_built = LocalDate { local_date };
        // Calling user action here
        self.user_grammar.local_date(&local_date_built)?;
        self.push(ASTType::LocalDate(local_date_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `LocalTime: <Val>"[0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]+)?)?";`
    ///
    #[parol_runtime::function_name::named]
    fn local_time(&mut self, local_time: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_time = local_time.token()?.clone();
        let local_time_built = LocalTime { local_time };
        // Calling user action here
        self.user_grammar.local_time(&local_time_built)?;
        self.push(ASTType::LocalTime(local_time_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `Array: ArrayOpen^ /* Clipped */ %push(Val) ArrayOpt /* Option */ %pop() ArrayClose^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_open: &ParseTreeType<'t>,
        _array_opt: &ParseTreeType<'t>,
        _array_close: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let array_opt = pop_item!(self, array_opt, ArrayOpt, context);
        self.pop(context);
        let array_built = Array { array_opt };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `ArrayOpt /* Option<T>::Some */: ArrayValues;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_0(&mut self, _array_values: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values = pop_item!(self, array_values, ArrayValues, context);
        let array_opt_0_built = ArrayOpt { array_values };
        self.push(ASTType::ArrayOpt(Some(array_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `ArrayOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `ArrayValues: Val ArrayValuesSuffix0;`
    ///
    #[parol_runtime::function_name::named]
    fn array_values(
        &mut self,
        _val: &ParseTreeType<'t>,
        _array_values_suffix0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix0 =
            pop_item!(self, array_values_suffix0, ArrayValuesSuffix0, context);
        let val = pop_item!(self, val, Val, context);
        let array_values_built = ArrayValues {
            val,
            array_values_suffix0,
        };
        // Calling user action here
        self.user_grammar.array_values(&array_values_built)?;
        self.push(ASTType::ArrayValues(array_values_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `ArrayValuesSuffix0: ArraySep^ /* Clipped */ ArrayValuesSuffix;`
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix0_0(
        &mut self,
        _array_sep: &ParseTreeType<'t>,
        _array_values_suffix: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix = pop_item!(self, array_values_suffix, ArrayValuesSuffix, context);
        self.pop(context);
        let array_values_suffix0_0_built = ArrayValuesSuffix0ArraySepArrayValuesSuffix {
            array_values_suffix: Box::new(array_values_suffix),
        };
        let array_values_suffix0_0_built =
            ArrayValuesSuffix0::ArraySepArrayValuesSuffix(array_values_suffix0_0_built);
        self.push(
            ASTType::ArrayValuesSuffix0(array_values_suffix0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `ArrayValuesSuffix0: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix0_1_built = ArrayValuesSuffix0ArrayValuesSuffix0Empty {};
        let array_values_suffix0_1_built =
            ArrayValuesSuffix0::ArrayValuesSuffix0Empty(array_values_suffix0_1_built);
        self.push(
            ASTType::ArrayValuesSuffix0(array_values_suffix0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `ArrayValuesSuffix: ArrayValues;`
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix_0(&mut self, _array_values: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values = pop_item!(self, array_values, ArrayValues, context);
        let array_values_suffix_0_built = ArrayValuesSuffixArrayValues { array_values };
        let array_values_suffix_0_built =
            ArrayValuesSuffix::ArrayValues(array_values_suffix_0_built);
        self.push(
            ASTType::ArrayValuesSuffix(array_values_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `ArrayValuesSuffix: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix_1_built = ArrayValuesSuffixArrayValuesSuffixEmpty {};
        let array_values_suffix_1_built =
            ArrayValuesSuffix::ArrayValuesSuffixEmpty(array_values_suffix_1_built);
        self.push(
            ASTType::ArrayValuesSuffix(array_values_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `ArraySep: <INITIAL, Val>",";`
    ///
    #[parol_runtime::function_name::named]
    fn array_sep(&mut self, array_sep: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_sep = array_sep.token()?.clone();
        let array_sep_built = ArraySep { array_sep };
        // Calling user action here
        self.user_grammar.array_sep(&array_sep_built)?;
        self.push(ASTType::ArraySep(array_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `Table: StdTable;`
    ///
    #[parol_runtime::function_name::named]
    fn table_0(&mut self, _std_table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let std_table = pop_item!(self, std_table, StdTable, context);
        let table_0_built = TableStdTable { std_table };
        let table_0_built = Table::StdTable(table_0_built);
        // Calling user action here
        self.user_grammar.table(&table_0_built)?;
        self.push(ASTType::Table(table_0_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `Table: ArrayTable;`
    ///
    #[parol_runtime::function_name::named]
    fn table_1(&mut self, _array_table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table = pop_item!(self, array_table, ArrayTable, context);
        let table_1_built = TableArrayTable { array_table };
        let table_1_built = Table::ArrayTable(table_1_built);
        // Calling user action here
        self.user_grammar.table(&table_1_built)?;
        self.push(ASTType::Table(table_1_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `StdTable: StdTableOpen^ /* Clipped */ Key StdTableClose^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn std_table(
        &mut self,
        _std_table_open: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _std_table_close: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let key = pop_item!(self, key, Key, context);
        self.pop(context);
        let std_table_built = StdTable { key };
        // Calling user action here
        self.user_grammar.std_table(&std_table_built)?;
        self.push(ASTType::StdTable(std_table_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `ArrayTableOpen: "\u{5B}\u{5B}";`
    ///
    #[parol_runtime::function_name::named]
    fn array_table_open(&mut self, array_table_open: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table_open = array_table_open.token()?.clone();
        let array_table_open_built = ArrayTableOpen { array_table_open };
        // Calling user action here
        self.user_grammar
            .array_table_open(&array_table_open_built)?;
        self.push(ASTType::ArrayTableOpen(array_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `ArrayTableClose: "\u{5D}\u{5D}";`
    ///
    #[parol_runtime::function_name::named]
    fn array_table_close(&mut self, array_table_close: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table_close = array_table_close.token()?.clone();
        let array_table_close_built = ArrayTableClose { array_table_close };
        // Calling user action here
        self.user_grammar
            .array_table_close(&array_table_close_built)?;
        self.push(ASTType::ArrayTableClose(array_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `ArrayOpen: <INITIAL, Val>"\u{5B}";`
    ///
    #[parol_runtime::function_name::named]
    fn array_open(&mut self, array_open: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_open = array_open.token()?.clone();
        let array_open_built = ArrayOpen { array_open };
        // Calling user action here
        self.user_grammar.array_open(&array_open_built)?;
        self.push(ASTType::ArrayOpen(array_open_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `ArrayClose: <INITIAL, Val>"\u{5D}";`
    ///
    #[parol_runtime::function_name::named]
    fn array_close(&mut self, array_close: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_close = array_close.token()?.clone();
        let array_close_built = ArrayClose { array_close };
        // Calling user action here
        self.user_grammar.array_close(&array_close_built)?;
        self.push(ASTType::ArrayClose(array_close_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `StdTableOpen: ArrayOpen;`
    ///
    #[parol_runtime::function_name::named]
    fn std_table_open(&mut self, _array_open: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_open = pop_item!(self, array_open, ArrayOpen, context);
        let std_table_open_built = StdTableOpen { array_open };
        // Calling user action here
        self.user_grammar.std_table_open(&std_table_open_built)?;
        self.push(ASTType::StdTableOpen(std_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `StdTableClose: ArrayClose;`
    ///
    #[parol_runtime::function_name::named]
    fn std_table_close(&mut self, _array_close: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_close = pop_item!(self, array_close, ArrayClose, context);
        let std_table_close_built = StdTableClose { array_close };
        // Calling user action here
        self.user_grammar.std_table_close(&std_table_close_built)?;
        self.push(ASTType::StdTableClose(std_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `InlineTable: InlineTableOpen^ /* Clipped */ %push(INITIAL) InlineTableOpt /* Option */ %pop() InlineTableOpt0 /* Option */ InlineTableClose^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table(
        &mut self,
        _inline_table_open: &ParseTreeType<'t>,
        _inline_table_opt: &ParseTreeType<'t>,
        _inline_table_opt0: &ParseTreeType<'t>,
        _inline_table_close: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let inline_table_opt0 = pop_item!(self, inline_table_opt0, InlineTableOpt0, context);
        let inline_table_opt = pop_item!(self, inline_table_opt, InlineTableOpt, context);
        self.pop(context);
        let inline_table_built = InlineTable {
            inline_table_opt,
            inline_table_opt0,
        };
        // Calling user action here
        self.user_grammar.inline_table(&inline_table_built)?;
        self.push(ASTType::InlineTable(inline_table_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `InlineTableOpt0 /* Option<T>::Some */: InlineTableSep;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt0_0(&mut self, _inline_table_sep: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_sep = pop_item!(self, inline_table_sep, InlineTableSep, context);
        let inline_table_opt0_0_built = InlineTableOpt0 { inline_table_sep };
        self.push(
            ASTType::InlineTableOpt0(Some(inline_table_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `InlineTableOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InlineTableOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `InlineTableOpt /* Option<T>::Some */: InlineTableKeyVals;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt_0(&mut self, _inline_table_key_vals: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals =
            pop_item!(self, inline_table_key_vals, InlineTableKeyVals, context);
        let inline_table_opt_0_built = InlineTableOpt {
            inline_table_key_vals,
        };
        self.push(
            ASTType::InlineTableOpt(Some(inline_table_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `InlineTableOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InlineTableOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `InlineTableOpen: <INITIAL, Val>"\u{7B}";`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_open(&mut self, inline_table_open: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_open = inline_table_open.token()?.clone();
        let inline_table_open_built = InlineTableOpen { inline_table_open };
        // Calling user action here
        self.user_grammar
            .inline_table_open(&inline_table_open_built)?;
        self.push(ASTType::InlineTableOpen(inline_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `InlineTableClose: <INITIAL, Val>"\u{7D}";`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_close(&mut self, inline_table_close: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_close = inline_table_close.token()?.clone();
        let inline_table_close_built = InlineTableClose { inline_table_close };
        // Calling user action here
        self.user_grammar
            .inline_table_close(&inline_table_close_built)?;
        self.push(ASTType::InlineTableClose(inline_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `InlineTableSep: ArraySep;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_sep(&mut self, _array_sep: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_sep = pop_item!(self, array_sep, ArraySep, context);
        let inline_table_sep_built = InlineTableSep { array_sep };
        // Calling user action here
        self.user_grammar
            .inline_table_sep(&inline_table_sep_built)?;
        self.push(ASTType::InlineTableSep(inline_table_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `InlineTableKeyVals: KeyVal InlineTableKeyValsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals(
        &mut self,
        _key_val: &ParseTreeType<'t>,
        _inline_table_key_vals_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals_opt = pop_item!(
            self,
            inline_table_key_vals_opt,
            InlineTableKeyValsOpt,
            context
        );
        let key_val = pop_item!(self, key_val, KeyVal, context);
        let inline_table_key_vals_built = InlineTableKeyVals {
            key_val,
            inline_table_key_vals_opt: inline_table_key_vals_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .inline_table_key_vals(&inline_table_key_vals_built)?;
        self.push(
            ASTType::InlineTableKeyVals(inline_table_key_vals_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `InlineTableKeyValsOpt /* Option<T>::Some */: InlineTableSep^ /* Clipped */ InlineTableKeyVals;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals_opt_0(
        &mut self,
        _inline_table_sep: &ParseTreeType<'t>,
        _inline_table_key_vals: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals =
            pop_item!(self, inline_table_key_vals, InlineTableKeyVals, context);
        self.pop(context);
        let inline_table_key_vals_opt_0_built = InlineTableKeyValsOpt {
            inline_table_key_vals,
        };
        self.push(
            ASTType::InlineTableKeyValsOpt(Some(inline_table_key_vals_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `InlineTableKeyValsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InlineTableKeyValsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `ArrayTable: ArrayTableOpen^ /* Clipped */ Key ArrayTableClose^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_table(
        &mut self,
        _array_table_open: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _array_table_close: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let key = pop_item!(self, key, Key, context);
        self.pop(context);
        let array_table_built = ArrayTable { key };
        // Calling user action here
        self.user_grammar.array_table(&array_table_built)?;
        self.push(ASTType::ArrayTable(array_table_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `UnsignedDecInt: <Val>"0|[1-9]([0-9]|_[0-9])*";`
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_dec_int(&mut self, unsigned_dec_int: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_dec_int = unsigned_dec_int.token()?.clone();
        let unsigned_dec_int_built = UnsignedDecInt { unsigned_dec_int };
        // Calling user action here
        self.user_grammar
            .unsigned_dec_int(&unsigned_dec_int_built)?;
        self.push(ASTType::UnsignedDecInt(unsigned_dec_int_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `UnquotedKey: "[-_A-Za-z0-9\u{B2}\u{B3}\u{B9}\u{BC}-\u{BE}\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{203F}-\u{2040}\u{2070}-\u{218F}\u{2460}-\u{24FF}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}]+";`
    ///
    #[parol_runtime::function_name::named]
    fn unquoted_key(&mut self, unquoted_key: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unquoted_key = unquoted_key.token()?.clone();
        let unquoted_key_built = UnquotedKey { unquoted_key };
        // Calling user action here
        self.user_grammar.unquoted_key(&unquoted_key_built)?;
        self.push(ASTType::UnquotedKey(unquoted_key_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `DotSep: <INITIAL, Val>"\.";`
    ///
    #[parol_runtime::function_name::named]
    fn dot_sep(&mut self, dot_sep: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_sep = dot_sep.token()?.clone();
        let dot_sep_built = DotSep { dot_sep };
        // Calling user action here
        self.user_grammar.dot_sep(&dot_sep_built)?;
        self.push(ASTType::DotSep(dot_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `MLBasicStringStart: <INITIAL, Val>"\u{22}{3}";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string_start(&mut self, m_l_basic_string_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_start = m_l_basic_string_start.token()?.clone();
        let m_l_basic_string_start_built = MLBasicStringStart {
            m_l_basic_string_start,
        };
        // Calling user action here
        self.user_grammar
            .m_l_basic_string_start(&m_l_basic_string_start_built)?;
        self.push(
            ASTType::MLBasicStringStart(m_l_basic_string_start_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `MLBasicStringEnd: <MLBString>"\u{22}{3,5}";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string_end(&mut self, m_l_basic_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_end = m_l_basic_string_end.token()?.clone();
        let m_l_basic_string_end_built = MLBasicStringEnd {
            m_l_basic_string_end,
        };
        // Calling user action here
        self.user_grammar
            .m_l_basic_string_end(&m_l_basic_string_end_built)?;
        self.push(
            ASTType::MLBasicStringEnd(m_l_basic_string_end_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `MLBQuotes: <MLBString>"\u{22}{1,2}";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_quotes(&mut self, m_l_b_quotes: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_quotes = m_l_b_quotes.token()?.clone();
        let m_l_b_quotes_built = MLBQuotes { m_l_b_quotes };
        // Calling user action here
        self.user_grammar.m_l_b_quotes(&m_l_b_quotes_built)?;
        self.push(ASTType::MLBQuotes(m_l_b_quotes_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `QuotationMark: <INITIAL, Esc, Val, BString>"\u{22}";`
    ///
    #[parol_runtime::function_name::named]
    fn quotation_mark(&mut self, quotation_mark: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark = quotation_mark.token()?.clone();
        let quotation_mark_built = QuotationMark { quotation_mark };
        // Calling user action here
        self.user_grammar.quotation_mark(&quotation_mark_built)?;
        self.push(ASTType::QuotationMark(quotation_mark_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `MLLiteralStringStart: <INITIAL, Val>"\u{27}{3}";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string_start(
        &mut self,
        m_l_literal_string_start: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string_start = m_l_literal_string_start.token()?.clone();
        let m_l_literal_string_start_built = MLLiteralStringStart {
            m_l_literal_string_start,
        };
        // Calling user action here
        self.user_grammar
            .m_l_literal_string_start(&m_l_literal_string_start_built)?;
        self.push(
            ASTType::MLLiteralStringStart(m_l_literal_string_start_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `MLLiteralStringEnd: <MLLString>"\u{27}{3,5}(?:\r?\n)?";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string_end(&mut self, m_l_literal_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string_end = m_l_literal_string_end.token()?.clone();
        let m_l_literal_string_end_built = MLLiteralStringEnd {
            m_l_literal_string_end,
        };
        // Calling user action here
        self.user_grammar
            .m_l_literal_string_end(&m_l_literal_string_end_built)?;
        self.push(
            ASTType::MLLiteralStringEnd(m_l_literal_string_end_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `MLLQuotes: <MLLString>"\u{27}{1,2}";`
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_quotes(&mut self, m_l_l_quotes: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_quotes = m_l_l_quotes.token()?.clone();
        let m_l_l_quotes_built = MLLQuotes { m_l_l_quotes };
        // Calling user action here
        self.user_grammar.m_l_l_quotes(&m_l_l_quotes_built)?;
        self.push(ASTType::MLLQuotes(m_l_l_quotes_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `Apostrophe: <INITIAL, Val, LString>"\u{27}";`
    ///
    #[parol_runtime::function_name::named]
    fn apostrophe(&mut self, apostrophe: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let apostrophe = apostrophe.token()?.clone();
        let apostrophe_built = Apostrophe { apostrophe };
        // Calling user action here
        self.user_grammar.apostrophe(&apostrophe_built)?;
        self.push(ASTType::Apostrophe(apostrophe_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `AsciiNoEscape: <Esc, BString, MLBString>"[ \t\u{21}\u{23}-\u{5B}\u{5D}-\u{7E}]+";`
    ///
    #[parol_runtime::function_name::named]
    fn ascii_no_escape(&mut self, ascii_no_escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = ascii_no_escape.token()?.clone();
        let ascii_no_escape_built = AsciiNoEscape { ascii_no_escape };
        // Calling user action here
        self.user_grammar.ascii_no_escape(&ascii_no_escape_built)?;
        self.push(ASTType::AsciiNoEscape(ascii_no_escape_built), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `Minus: <Val>"\u{2D}";`
    ///
    #[parol_runtime::function_name::named]
    fn minus(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let minus_built = Minus { minus };
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `Plus: <Val>"\u{2B}";`
    ///
    #[parol_runtime::function_name::named]
    fn plus(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let plus_built = Plus { plus };
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolTomlGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolTomlGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_toml(&children[0]),
            1 => self.parol_toml_list_0(&children[0], &children[1]),
            2 => self.parol_toml_list_1(),
            3 => self.expression_0(&children[0]),
            4 => self.expression_1(&children[0]),
            5 => self.newline(&children[0]),
            6 => self.ws_newline(&children[0]),
            7 => self.non_ascii(&children[0]),
            8 => self.key_val(&children[0], &children[1], &children[2]),
            9 => self.key(&children[0], &children[1]),
            10 => self.key_suffix_0(),
            11 => self.key_suffix_1(&children[0], &children[1], &children[2]),
            12 => self.key_list_0(&children[0], &children[1], &children[2]),
            13 => self.key_list_1(),
            14 => self.simple_key_0(&children[0]),
            15 => self.simple_key_1(&children[0]),
            16 => self.quoted_key_0(&children[0]),
            17 => self.quoted_key_1(&children[0]),
            18 => self.key_val_sep(&children[0]),
            19 => self.val_0(&children[0]),
            20 => self.val_1(&children[0]),
            21 => self.val_2(&children[0]),
            22 => self.val_3(&children[0]),
            23 => self.val_4(&children[0]),
            24 => self.val_5(&children[0]),
            25 => self.val_6(&children[0]),
            26 => self.val_7(&children[0]),
            27 => self.val_8(&children[0]),
            28 => self.numeric_0(&children[0]),
            29 => self.numeric_1(&children[0]),
            30 => self.basic_string(&children[0], &children[1], &children[2]),
            31 => self.basic_string_list_0(&children[0], &children[1]),
            32 => self.basic_string_list_1(),
            33 => self.basic_char_0(&children[0]),
            34 => self.basic_char_1(&children[0]),
            35 => self.basic_unescaped_0(&children[0]),
            36 => self.basic_unescaped_1(&children[0]),
            37 => self.escaped(&children[0], &children[1]),
            38 => self.escape(&children[0]),
            39 => self.escape_seq_char_0(&children[0]),
            40 => self.escape_seq_char_1(&children[0]),
            41 => self.escape_seq_char_2(&children[0]),
            42 => self.escape_seq_char_3(&children[0]),
            43 => self.escape_seq_char_4(&children[0]),
            44 => self.escape_seq_char_5(&children[0]),
            45 => self.escape_seq_char_6(&children[0]),
            46 => self.escape_seq_char_7(&children[0]),
            47 => self.escape_seq_char_8(&children[0]),
            48 => self.escape_seq_char_9(&children[0]),
            49 => self.escape_seq_char_10(&children[0]),
            50 => self.unicode4(&children[0]),
            51 => self.unicode8(&children[0]),
            52 => self.m_l_basic_string(&children[0], &children[1], &children[2]),
            53 => self.m_l_basic_body(&children[0], &children[1]),
            54 => self.m_l_basic_body_list_0(&children[0], &children[1], &children[2]),
            55 => self.m_l_basic_body_list_1(),
            56 => self.m_l_b_content_list_0(&children[0], &children[1]),
            57 => self.m_l_b_content_list_1(),
            58 => self.m_l_b_content_list1(&children[0], &children[1]),
            59 => self.m_l_b_content_0(&children[0]),
            60 => self.m_l_b_content_1(&children[0]),
            61 => self.m_l_b_content_2(&children[0]),
            62 => self.m_l_b_char_0(&children[0]),
            63 => self.m_l_b_char_1(&children[0]),
            64 => self.m_l_b_unescaped_0(&children[0]),
            65 => self.m_l_b_unescaped_1(&children[0]),
            66 => self.m_l_b_escaped_n_l(&children[0]),
            67 => self.literal_string(&children[0], &children[1], &children[2]),
            68 => self.literal_string_list_0(&children[0], &children[1]),
            69 => self.literal_string_list_1(),
            70 => self.literal_char_0(&children[0]),
            71 => self.literal_char_1(&children[0]),
            72 => self.literal_char_no_apostrophe(&children[0]),
            73 => self.m_l_literal_string(&children[0], &children[1]),
            74 => self.m_l_literal_body(&children[0], &children[1], &children[2]),
            75 => self.m_l_literal_body_list_0(&children[0], &children[1], &children[2]),
            76 => self.m_l_literal_body_list_1(),
            77 => self.m_l_l_content_list_0(&children[0], &children[1]),
            78 => self.m_l_l_content_list_1(),
            79 => self.m_l_l_content_list1(&children[0], &children[1]),
            80 => self.m_l_l_content_0(&children[0]),
            81 => self.m_l_l_content_1(&children[0]),
            82 => self.integer_0(&children[0]),
            83 => self.integer_1(&children[0]),
            84 => self.integer_2(&children[0]),
            85 => self.integer_3(&children[0]),
            86 => self.hex_prefix(&children[0]),
            87 => self.oct_prefix(&children[0]),
            88 => self.bin_prefix(&children[0]),
            89 => self.dec_int(&children[0], &children[1]),
            90 => self.dec_int_opt_0(&children[0]),
            91 => self.dec_int_opt_group_0(&children[0]),
            92 => self.dec_int_opt_group_1(&children[0]),
            93 => self.dec_int_opt_1(),
            94 => self.hex_int(&children[0], &children[1]),
            95 => self.hex_int_content(&children[0]),
            96 => self.oct_int(&children[0], &children[1]),
            97 => self.oct_int_content(&children[0]),
            98 => self.bin_int(&children[0], &children[1]),
            99 => self.bin_int_content(&children[0]),
            100 => self.boolean_0(&children[0]),
            101 => self.boolean_1(&children[0]),
            102 => self.float_0(&children[0]),
            103 => self.float_1(&children[0]),
            104 => self.normal_float(&children[0]),
            105 => self.special_float(&children[0]),
            106 => self.date_time_0(&children[0]),
            107 => self.date_time_1(&children[0]),
            108 => self.date_time_2(&children[0]),
            109 => self.date_time_3(&children[0]),
            110 => self.offset_date_time(&children[0]),
            111 => self.local_date_time(&children[0]),
            112 => self.local_date(&children[0]),
            113 => self.local_time(&children[0]),
            114 => self.array(&children[0], &children[1], &children[2]),
            115 => self.array_opt_0(&children[0]),
            116 => self.array_opt_1(),
            117 => self.array_values(&children[0], &children[1]),
            118 => self.array_values_suffix0_0(&children[0], &children[1]),
            119 => self.array_values_suffix0_1(),
            120 => self.array_values_suffix_0(&children[0]),
            121 => self.array_values_suffix_1(),
            122 => self.array_sep(&children[0]),
            123 => self.table_0(&children[0]),
            124 => self.table_1(&children[0]),
            125 => self.std_table(&children[0], &children[1], &children[2]),
            126 => self.array_table_open(&children[0]),
            127 => self.array_table_close(&children[0]),
            128 => self.array_open(&children[0]),
            129 => self.array_close(&children[0]),
            130 => self.std_table_open(&children[0]),
            131 => self.std_table_close(&children[0]),
            132 => self.inline_table(&children[0], &children[1], &children[2], &children[3]),
            133 => self.inline_table_opt0_0(&children[0]),
            134 => self.inline_table_opt0_1(),
            135 => self.inline_table_opt_0(&children[0]),
            136 => self.inline_table_opt_1(),
            137 => self.inline_table_open(&children[0]),
            138 => self.inline_table_close(&children[0]),
            139 => self.inline_table_sep(&children[0]),
            140 => self.inline_table_key_vals(&children[0], &children[1]),
            141 => self.inline_table_key_vals_opt_0(&children[0], &children[1]),
            142 => self.inline_table_key_vals_opt_1(),
            143 => self.array_table(&children[0], &children[1], &children[2]),
            144 => self.unsigned_dec_int(&children[0]),
            145 => self.unquoted_key(&children[0]),
            146 => self.dot_sep(&children[0]),
            147 => self.m_l_basic_string_start(&children[0]),
            148 => self.m_l_basic_string_end(&children[0]),
            149 => self.m_l_b_quotes(&children[0]),
            150 => self.quotation_mark(&children[0]),
            151 => self.m_l_literal_string_start(&children[0]),
            152 => self.m_l_literal_string_end(&children[0]),
            153 => self.m_l_l_quotes(&children[0]),
            154 => self.apostrophe(&children[0]),
            155 => self.ascii_no_escape(&children[0]),
            156 => self.minus(&children[0]),
            157 => self.plus(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
