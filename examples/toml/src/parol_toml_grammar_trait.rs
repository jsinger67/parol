// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Specifically disable clippy warnings that result in the way parol generates names.
// The user can't influence this in its grammar definition.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolTomlGrammarTrait<'t> {
    /// Semantic action for non-terminal 'ParolToml'
    fn parol_toml(&mut self, _arg: &ParolToml<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Newline'
    fn newline(&mut self, _arg: &Newline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WsNewline'
    fn ws_newline(&mut self, _arg: &WsNewline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonAscii'
    fn non_ascii(&mut self, _arg: &NonAscii<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyVal'
    fn key_val(&mut self, _arg: &KeyVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleKey'
    fn simple_key(&mut self, _arg: &SimpleKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotedKey'
    fn quoted_key(&mut self, _arg: &QuotedKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyValSep'
    fn key_val_sep(&mut self, _arg: &KeyValSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Val'
    fn val(&mut self, _arg: &Val<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Numeric'
    fn numeric(&mut self, _arg: &Numeric<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicString'
    fn basic_string(&mut self, _arg: &BasicString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicChar'
    fn basic_char(&mut self, _arg: &BasicChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasicUnescaped'
    fn basic_unescaped(&mut self, _arg: &BasicUnescaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escaped'
    fn escaped(&mut self, _arg: &Escaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escape'
    fn escape(&mut self, _arg: &Escape<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapeSeqChar'
    fn escape_seq_char(&mut self, _arg: &EscapeSeqChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode4'
    fn unicode4(&mut self, _arg: &Unicode4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode8'
    fn unicode8(&mut self, _arg: &Unicode8<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicString'
    fn m_l_basic_string(&mut self, _arg: &MLBasicString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicBody'
    fn m_l_basic_body(&mut self, _arg: &MLBasicBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContentList'
    fn m_l_b_content_list(&mut self, _arg: &MLBContentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContentList1'
    fn m_l_b_content_list1(&mut self, _arg: &MLBContentList1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBContent'
    fn m_l_b_content(&mut self, _arg: &MLBContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBChar'
    fn m_l_b_char(&mut self, _arg: &MLBChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBUnescaped'
    fn m_l_b_unescaped(&mut self, _arg: &MLBUnescaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBEscapedNL'
    fn m_l_b_escaped_n_l(&mut self, _arg: &MLBEscapedNL<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralString'
    fn literal_string(&mut self, _arg: &LiteralString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralChar'
    fn literal_char(&mut self, _arg: &LiteralChar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LiteralCharNoApostrophe'
    fn literal_char_no_apostrophe(&mut self, _arg: &LiteralCharNoApostrophe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralString'
    fn m_l_literal_string(&mut self, _arg: &MLLiteralString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralBody'
    fn m_l_literal_body(&mut self, _arg: &MLLiteralBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContentList'
    fn m_l_l_content_list(&mut self, _arg: &MLLContentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContentList1'
    fn m_l_l_content_list1(&mut self, _arg: &MLLContentList1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLContent'
    fn m_l_l_content(&mut self, _arg: &MLLContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexPrefix'
    fn hex_prefix(&mut self, _arg: &HexPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctPrefix'
    fn oct_prefix(&mut self, _arg: &OctPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinPrefix'
    fn bin_prefix(&mut self, _arg: &BinPrefix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DecInt'
    fn dec_int(&mut self, _arg: &DecInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexInt'
    fn hex_int(&mut self, _arg: &HexInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexIntContent'
    fn hex_int_content(&mut self, _arg: &HexIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctInt'
    fn oct_int(&mut self, _arg: &OctInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctIntContent'
    fn oct_int_content(&mut self, _arg: &OctIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinInt'
    fn bin_int(&mut self, _arg: &BinInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinIntContent'
    fn bin_int_content(&mut self, _arg: &BinIntContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NormalFloat'
    fn normal_float(&mut self, _arg: &NormalFloat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SpecialFloat'
    fn special_float(&mut self, _arg: &SpecialFloat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DateTime'
    fn date_time(&mut self, _arg: &DateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OffsetDateTime'
    fn offset_date_time(&mut self, _arg: &OffsetDateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalDateTime'
    fn local_date_time(&mut self, _arg: &LocalDateTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalDate'
    fn local_date(&mut self, _arg: &LocalDate<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalTime'
    fn local_time(&mut self, _arg: &LocalTime<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayValues'
    fn array_values(&mut self, _arg: &ArrayValues<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArraySep'
    fn array_sep(&mut self, _arg: &ArraySep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Table'
    fn table(&mut self, _arg: &Table<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTable'
    fn std_table(&mut self, _arg: &StdTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTableOpen'
    fn array_table_open(&mut self, _arg: &ArrayTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTableClose'
    fn array_table_close(&mut self, _arg: &ArrayTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayOpen'
    fn array_open(&mut self, _arg: &ArrayOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayClose'
    fn array_close(&mut self, _arg: &ArrayClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTableOpen'
    fn std_table_open(&mut self, _arg: &StdTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StdTableClose'
    fn std_table_close(&mut self, _arg: &StdTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTable'
    fn inline_table(&mut self, _arg: &InlineTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableOpen'
    fn inline_table_open(&mut self, _arg: &InlineTableOpen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableClose'
    fn inline_table_close(&mut self, _arg: &InlineTableClose<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableSep'
    fn inline_table_sep(&mut self, _arg: &InlineTableSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineTableKeyVals'
    fn inline_table_key_vals(&mut self, _arg: &InlineTableKeyVals<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTable'
    fn array_table(&mut self, _arg: &ArrayTable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnsignedDecInt'
    fn unsigned_dec_int(&mut self, _arg: &UnsignedDecInt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnquotedKey'
    fn unquoted_key(&mut self, _arg: &UnquotedKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotSep'
    fn dot_sep(&mut self, _arg: &DotSep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicStringStart'
    fn m_l_basic_string_start(&mut self, _arg: &MLBasicStringStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBasicStringEnd'
    fn m_l_basic_string_end(&mut self, _arg: &MLBasicStringEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLBQuotes'
    fn m_l_b_quotes(&mut self, _arg: &MLBQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotationMark'
    fn quotation_mark(&mut self, _arg: &QuotationMark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralStringStart'
    fn m_l_literal_string_start(&mut self, _arg: &MLLiteralStringStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLiteralStringEnd'
    fn m_l_literal_string_end(&mut self, _arg: &MLLiteralStringEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MLLQuotes'
    fn m_l_l_quotes(&mut self, _arg: &MLLQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Apostrophe'
    fn apostrophe(&mut self, _arg: &Apostrophe<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsciiNoEscape'
    fn ascii_no_escape(&mut self, _arg: &AsciiNoEscape<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 3
///
/// Expression: KeyVal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionKeyVal<'t> {
    pub key_val: Box<KeyVal<'t>>,
}

///
/// Type derived for production 4
///
/// Expression: Table;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionTable<'t> {
    pub table: Box<Table<'t>>,
}

///
/// Type derived for production 10
///
/// KeySuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeySuffixKeySuffixEmpty {}

///
/// Type derived for production 11
///
/// KeySuffix: DotSep SimpleKey KeyList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeySuffixDotSepSimpleKeyKeyList<'t> {
    pub dot_sep: Box<DotSep<'t>>,
    pub simple_key: Box<SimpleKey<'t>>,
    pub key_list: Vec<KeyList<'t>>,
}

///
/// Type derived for production 14
///
/// SimpleKey: QuotedKey;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleKeyQuotedKey<'t> {
    pub quoted_key: Box<QuotedKey<'t>>,
}

///
/// Type derived for production 15
///
/// SimpleKey: UnquotedKey;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleKeyUnquotedKey<'t> {
    pub unquoted_key: Box<UnquotedKey<'t>>,
}

///
/// Type derived for production 16
///
/// QuotedKey: BasicString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotedKeyBasicString<'t> {
    pub basic_string: Box<BasicString<'t>>,
}

///
/// Type derived for production 17
///
/// QuotedKey: LiteralString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotedKeyLiteralString<'t> {
    pub literal_string: Box<LiteralString<'t>>,
}

///
/// Type derived for production 19
///
/// Val: Boolean;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValBoolean<'t> {
    pub boolean: Box<Boolean<'t>>,
}

///
/// Type derived for production 20
///
/// Val: Array;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValArray<'t> {
    pub array: Box<Array<'t>>,
}

///
/// Type derived for production 21
///
/// Val: InlineTable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValInlineTable<'t> {
    pub inline_table: Box<InlineTable<'t>>,
}

///
/// Type derived for production 22
///
/// Val: DateTime;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValDateTime<'t> {
    pub date_time: Box<DateTime<'t>>,
}

///
/// Type derived for production 23
///
/// Val: Numeric;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValNumeric<'t> {
    pub numeric: Box<Numeric<'t>>,
}

///
/// Type derived for production 24
///
/// Val: BasicString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValBasicString<'t> {
    pub basic_string: Box<BasicString<'t>>,
}

///
/// Type derived for production 25
///
/// Val: MLBasicString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValMLBasicString<'t> {
    pub m_l_basic_string: Box<MLBasicString<'t>>,
}

///
/// Type derived for production 26
///
/// Val: LiteralString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValLiteralString<'t> {
    pub literal_string: Box<LiteralString<'t>>,
}

///
/// Type derived for production 27
///
/// Val: MLLiteralString;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValMLLiteralString<'t> {
    pub m_l_literal_string: Box<MLLiteralString<'t>>,
}

///
/// Type derived for production 28
///
/// Numeric: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumericFloat<'t> {
    pub float: Box<Float<'t>>,
}

///
/// Type derived for production 29
///
/// Numeric: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumericInteger<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for production 33
///
/// BasicChar: BasicUnescaped;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicCharBasicUnescaped<'t> {
    pub basic_unescaped: Box<BasicUnescaped<'t>>,
}

///
/// Type derived for production 34
///
/// BasicChar: %push(Esc) Escaped %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicCharEscaped<'t> {
    pub escaped: Box<Escaped<'t>>,
}

///
/// Type derived for production 35
///
/// BasicUnescaped: AsciiNoEscape;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicUnescapedAsciiNoEscape<'t> {
    pub ascii_no_escape: Box<AsciiNoEscape<'t>>,
}

///
/// Type derived for production 36
///
/// BasicUnescaped: NonAscii;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicUnescapedNonAscii<'t> {
    pub non_ascii: Box<NonAscii<'t>>,
}

///
/// Type derived for production 39
///
/// EscapeSeqChar: QuotationMark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharQuotationMark<'t> {
    pub quotation_mark: Box<QuotationMark<'t>>,
}

///
/// Type derived for production 40
///
/// EscapeSeqChar: Escape;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharEscape<'t> {
    pub escape: Box<Escape<'t>>,
}

///
/// Type derived for production 41
///
/// EscapeSeqChar: <Esc>"b";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharB<'t> {
    pub b: Token<'t>, /* b */
}

///
/// Type derived for production 42
///
/// EscapeSeqChar: <Esc>"f";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharF<'t> {
    pub f: Token<'t>, /* f */
}

///
/// Type derived for production 43
///
/// EscapeSeqChar: <Esc>"n";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharN<'t> {
    pub n: Token<'t>, /* n */
}

///
/// Type derived for production 44
///
/// EscapeSeqChar: <Esc>"r";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharR<'t> {
    pub r: Token<'t>, /* r */
}

///
/// Type derived for production 45
///
/// EscapeSeqChar: <Esc>"t";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharT<'t> {
    pub t: Token<'t>, /* t */
}

///
/// Type derived for production 46
///
/// EscapeSeqChar: Unicode4;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharUnicode4<'t> {
    pub unicode4: Box<Unicode4<'t>>,
}

///
/// Type derived for production 47
///
/// EscapeSeqChar: Unicode8;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharUnicode8<'t> {
    pub unicode8: Box<Unicode8<'t>>,
}

///
/// Type derived for production 48
///
/// EscapeSeqChar: WsNewline;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharWsNewline<'t> {
    pub ws_newline: Box<WsNewline<'t>>,
}

///
/// Type derived for production 49
///
/// EscapeSeqChar: AsciiNoEscape;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EscapeSeqCharAsciiNoEscape<'t> {
    pub ascii_no_escape: Box<AsciiNoEscape<'t>>,
}

///
/// Type derived for production 56
///
/// MLBContentList: MLBContent MLBContentList;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentListMLBContentMLBContentList<'t> {
    pub m_l_b_content: Box<MLBContent<'t>>,
    pub m_l_b_content_list: Box<MLBContentList<'t>>,
}

///
/// Type derived for production 57
///
/// MLBContentList: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentListMLBContentListEmpty {}

///
/// Type derived for production 59
///
/// MLBContent: MLBChar;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentMLBChar<'t> {
    pub m_l_b_char: Box<MLBChar<'t>>,
}

///
/// Type derived for production 60
///
/// MLBContent: Newline;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentNewline<'t> {
    pub newline: Box<Newline<'t>>,
}

///
/// Type derived for production 61
///
/// MLBContent: MLBEscapedNL;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentMLBEscapedNL<'t> {
    pub m_l_b_escaped_n_l: Box<MLBEscapedNL<'t>>,
}

///
/// Type derived for production 62
///
/// MLBChar: MLBUnescaped;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBCharMLBUnescaped<'t> {
    pub m_l_b_unescaped: Box<MLBUnescaped<'t>>,
}

///
/// Type derived for production 63
///
/// MLBChar: %push(Esc) Escaped %pop();
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBCharEscaped<'t> {
    pub escaped: Box<Escaped<'t>>,
}

///
/// Type derived for production 64
///
/// MLBUnescaped: AsciiNoEscape;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBUnescapedAsciiNoEscape<'t> {
    pub ascii_no_escape: Box<AsciiNoEscape<'t>>,
}

///
/// Type derived for production 65
///
/// MLBUnescaped: NonAscii;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBUnescapedNonAscii<'t> {
    pub non_ascii: Box<NonAscii<'t>>,
}

///
/// Type derived for production 70
///
/// LiteralChar: LiteralCharNoApostrophe;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharLiteralCharNoApostrophe<'t> {
    pub literal_char_no_apostrophe: Box<LiteralCharNoApostrophe<'t>>,
}

///
/// Type derived for production 71
///
/// LiteralChar: NonAscii;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharNonAscii<'t> {
    pub non_ascii: Box<NonAscii<'t>>,
}

///
/// Type derived for production 77
///
/// MLLContentList: MLLContent MLLContentList;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentListMLLContentMLLContentList<'t> {
    pub m_l_l_content: Box<MLLContent<'t>>,
    pub m_l_l_content_list: Box<MLLContentList<'t>>,
}

///
/// Type derived for production 78
///
/// MLLContentList: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentListMLLContentListEmpty {}

///
/// Type derived for production 80
///
/// MLLContent: LiteralChar;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentLiteralChar<'t> {
    pub literal_char: Box<LiteralChar<'t>>,
}

///
/// Type derived for production 81
///
/// MLLContent: Newline;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentNewline<'t> {
    pub newline: Box<Newline<'t>>,
}

///
/// Type derived for production 82
///
/// Integer: DecInt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerDecInt<'t> {
    pub dec_int: Box<DecInt<'t>>,
}

///
/// Type derived for production 83
///
/// Integer: HexInt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerHexInt<'t> {
    pub hex_int: Box<HexInt<'t>>,
}

///
/// Type derived for production 84
///
/// Integer: OctInt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerOctInt<'t> {
    pub oct_int: Box<OctInt<'t>>,
}

///
/// Type derived for production 85
///
/// Integer: BinInt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegerBinInt<'t> {
    pub bin_int: Box<BinInt<'t>>,
}

///
/// Type derived for production 91
///
/// DecIntOptGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOptGroupPlus<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 92
///
/// DecIntOptGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOptGroupMinus<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 100
///
/// Boolean: <Val>"true";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanTrue<'t> {
    pub r#true: Token<'t>, /* true */
}

///
/// Type derived for production 101
///
/// Boolean: <Val>"false";
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanFalse<'t> {
    pub r#false: Token<'t>, /* false */
}

///
/// Type derived for production 102
///
/// Float: NormalFloat;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatNormalFloat<'t> {
    pub normal_float: Box<NormalFloat<'t>>,
}

///
/// Type derived for production 103
///
/// Float: SpecialFloat;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatSpecialFloat<'t> {
    pub special_float: Box<SpecialFloat<'t>>,
}

///
/// Type derived for production 106
///
/// DateTime: OffsetDateTime;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeOffsetDateTime<'t> {
    pub offset_date_time: Box<OffsetDateTime<'t>>,
}

///
/// Type derived for production 107
///
/// DateTime: LocalDateTime;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalDateTime<'t> {
    pub local_date_time: Box<LocalDateTime<'t>>,
}

///
/// Type derived for production 108
///
/// DateTime: LocalDate;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalDate<'t> {
    pub local_date: Box<LocalDate<'t>>,
}

///
/// Type derived for production 109
///
/// DateTime: LocalTime;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DateTimeLocalTime<'t> {
    pub local_time: Box<LocalTime<'t>>,
}

///
/// Type derived for production 118
///
/// ArrayValuesSuffix0: ArraySep^ /* Clipped */ ArrayValuesSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffix0ArraySepArrayValuesSuffix<'t> {
    pub array_values_suffix: Box<ArrayValuesSuffix<'t>>,
}

///
/// Type derived for production 119
///
/// ArrayValuesSuffix0: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffix0ArrayValuesSuffix0Empty {}

///
/// Type derived for production 120
///
/// ArrayValuesSuffix: ArrayValues;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffixArrayValues<'t> {
    pub array_values: Box<ArrayValues<'t>>,
}

///
/// Type derived for production 121
///
/// ArrayValuesSuffix: ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValuesSuffixArrayValuesSuffixEmpty {}

///
/// Type derived for production 123
///
/// Table: StdTable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableStdTable<'t> {
    pub std_table: Box<StdTable<'t>>,
}

///
/// Type derived for production 124
///
/// Table: ArrayTable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableArrayTable<'t> {
    pub array_table: Box<ArrayTable<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Apostrophe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Apostrophe<'t> {
    pub apostrophe: Token<'t>, /* \u{27} */
}

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Array<'t> {
    pub array_opt: Option<Box<ArrayOpt<'t>>>,
}

///
/// Type derived for non-terminal ArrayClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayClose<'t> {
    pub array_close: Token<'t>, /* \u{5D} */
}

///
/// Type derived for non-terminal ArrayOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayOpen<'t> {
    pub array_open: Token<'t>, /* \u{5B} */
}

///
/// Type derived for non-terminal ArrayOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayOpt<'t> {
    pub array_values: Box<ArrayValues<'t>>,
}

///
/// Type derived for non-terminal ArraySep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArraySep<'t> {
    pub array_sep: Token<'t>, /* , */
}

///
/// Type derived for non-terminal ArrayTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTable<'t> {
    pub key: Box<Key<'t>>,
}

///
/// Type derived for non-terminal ArrayTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTableClose<'t> {
    pub array_table_close: Token<'t>, /* \u{5D}\u{5D} */
}

///
/// Type derived for non-terminal ArrayTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTableOpen<'t> {
    pub array_table_open: Token<'t>, /* \u{5B}\u{5B} */
}

///
/// Type derived for non-terminal ArrayValues
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValues<'t> {
    pub val: Box<Val<'t>>,
    pub array_values_suffix0: Box<ArrayValuesSuffix0<'t>>,
}

///
/// Type derived for non-terminal ArrayValuesSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayValuesSuffix<'t> {
    ArrayValues(ArrayValuesSuffixArrayValues<'t>),
    ArrayValuesSuffixEmpty(ArrayValuesSuffixArrayValuesSuffixEmpty),
}

///
/// Type derived for non-terminal ArrayValuesSuffix0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayValuesSuffix0<'t> {
    ArraySepArrayValuesSuffix(ArrayValuesSuffix0ArraySepArrayValuesSuffix<'t>),
    ArrayValuesSuffix0Empty(ArrayValuesSuffix0ArrayValuesSuffix0Empty),
}

///
/// Type derived for non-terminal AsciiNoEscape
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsciiNoEscape<'t> {
    pub ascii_no_escape: Token<'t>, /* [ \t\u{21}\u{23}-\u{5B}\u{5D}-\u{7E}]+ */
}

///
/// Type derived for non-terminal BasicChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicChar<'t> {
    BasicUnescaped(BasicCharBasicUnescaped<'t>),
    Escaped(BasicCharEscaped<'t>),
}

///
/// Type derived for non-terminal BasicString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicString<'t> {
    pub quotation_mark: Box<QuotationMark<'t>>,
    pub basic_string_list: Vec<BasicStringList<'t>>,
    pub quotation_mark0: Box<QuotationMark<'t>>,
}

///
/// Type derived for non-terminal BasicStringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicStringList<'t> {
    pub basic_char: Box<BasicChar<'t>>,
}

///
/// Type derived for non-terminal BasicUnescaped
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BasicUnescaped<'t> {
    AsciiNoEscape(BasicUnescapedAsciiNoEscape<'t>),
    NonAscii(BasicUnescapedNonAscii<'t>),
}

///
/// Type derived for non-terminal BinInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinInt<'t> {
    pub bin_int_content: Box<BinIntContent<'t>>,
}

///
/// Type derived for non-terminal BinIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinIntContent<'t> {
    pub bin_int_content: Token<'t>, /* [01]([01]|_[01])* */
}

///
/// Type derived for non-terminal BinPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BinPrefix<'t> {
    pub bin_prefix: Token<'t>, /* 0b */
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

///
/// Type derived for non-terminal DateTime
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DateTime<'t> {
    OffsetDateTime(DateTimeOffsetDateTime<'t>),
    LocalDateTime(DateTimeLocalDateTime<'t>),
    LocalDate(DateTimeLocalDate<'t>),
    LocalTime(DateTimeLocalTime<'t>),
}

///
/// Type derived for non-terminal DecInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecInt<'t> {
    pub dec_int_opt: Option<Box<DecIntOpt<'t>>>,
    pub unsigned_dec_int: Box<UnsignedDecInt<'t>>,
}

///
/// Type derived for non-terminal DecIntOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DecIntOpt<'t> {
    pub dec_int_opt_group: Box<DecIntOptGroup<'t>>,
}

///
/// Type derived for non-terminal DecIntOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DecIntOptGroup<'t> {
    Plus(DecIntOptGroupPlus<'t>),
    Minus(DecIntOptGroupMinus<'t>),
}

///
/// Type derived for non-terminal DotSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotSep<'t> {
    pub dot_sep: Token<'t>, /* \. */
}

///
/// Type derived for non-terminal Escape
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escape<'t> {
    pub escape: Token<'t>, /* \u{5C} */
}

///
/// Type derived for non-terminal EscapeSeqChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EscapeSeqChar<'t> {
    QuotationMark(EscapeSeqCharQuotationMark<'t>),
    Escape(EscapeSeqCharEscape<'t>),
    B(EscapeSeqCharB<'t>),
    F(EscapeSeqCharF<'t>),
    N(EscapeSeqCharN<'t>),
    R(EscapeSeqCharR<'t>),
    T(EscapeSeqCharT<'t>),
    Unicode4(EscapeSeqCharUnicode4<'t>),
    Unicode8(EscapeSeqCharUnicode8<'t>),
    WsNewline(EscapeSeqCharWsNewline<'t>),
    AsciiNoEscape(EscapeSeqCharAsciiNoEscape<'t>),
}

///
/// Type derived for non-terminal Escaped
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escaped<'t> {
    pub escape: Box<Escape<'t>>,
    pub escape_seq_char: Box<EscapeSeqChar<'t>>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression<'t> {
    KeyVal(ExpressionKeyVal<'t>),
    Table(ExpressionTable<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float<'t> {
    NormalFloat(FloatNormalFloat<'t>),
    SpecialFloat(FloatSpecialFloat<'t>),
}

///
/// Type derived for non-terminal HexInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexInt<'t> {
    pub hex_int_content: Box<HexIntContent<'t>>,
}

///
/// Type derived for non-terminal HexIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexIntContent<'t> {
    pub hex_int_content: Token<'t>, /* [0-9a-fA-F]([0-9a-fA-F]|_[0-9a-fA-F])* */
}

///
/// Type derived for non-terminal HexPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HexPrefix<'t> {
    pub hex_prefix: Token<'t>, /* 0x */
}

///
/// Type derived for non-terminal InlineTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTable<'t> {
    pub inline_table_opt: Option<Box<InlineTableOpt<'t>>>,
}

///
/// Type derived for non-terminal InlineTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableClose<'t> {
    pub inline_table_close: Token<'t>, /* \u{7D} */
}

///
/// Type derived for non-terminal InlineTableKeyVals
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableKeyVals<'t> {
    pub key_val: Box<KeyVal<'t>>,
    pub inline_table_key_vals_opt: Option<Box<InlineTableKeyValsOpt<'t>>>,
}

///
/// Type derived for non-terminal InlineTableKeyValsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableKeyValsOpt<'t> {
    pub inline_table_key_vals: Box<InlineTableKeyVals<'t>>,
}

///
/// Type derived for non-terminal InlineTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableOpen<'t> {
    pub inline_table_open: Token<'t>, /* \u{7B} */
}

///
/// Type derived for non-terminal InlineTableOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableOpt<'t> {
    pub inline_table_key_vals: Box<InlineTableKeyVals<'t>>,
}

///
/// Type derived for non-terminal InlineTableSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InlineTableSep<'t> {
    pub array_sep: Box<ArraySep<'t>>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Integer<'t> {
    DecInt(IntegerDecInt<'t>),
    HexInt(IntegerHexInt<'t>),
    OctInt(IntegerOctInt<'t>),
    BinInt(IntegerBinInt<'t>),
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Key<'t> {
    pub simple_key: Box<SimpleKey<'t>>,
    pub key_suffix: Box<KeySuffix<'t>>,
}

///
/// Type derived for non-terminal KeyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyList<'t> {
    pub dot_sep: Box<DotSep<'t>>,
    pub simple_key: Box<SimpleKey<'t>>,
}

///
/// Type derived for non-terminal KeySuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeySuffix<'t> {
    KeySuffixEmpty(KeySuffixKeySuffixEmpty),
    DotSepSimpleKeyKeyList(KeySuffixDotSepSimpleKeyKeyList<'t>),
}

///
/// Type derived for non-terminal KeyVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyVal<'t> {
    pub key: Box<Key<'t>>,
    pub key_val_sep: Box<KeyValSep<'t>>,
    pub val: Box<Val<'t>>,
}

///
/// Type derived for non-terminal KeyValSep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyValSep<'t> {
    pub key_val_sep: Token<'t>, /* = */
}

///
/// Type derived for non-terminal LiteralChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LiteralChar<'t> {
    LiteralCharNoApostrophe(LiteralCharLiteralCharNoApostrophe<'t>),
    NonAscii(LiteralCharNonAscii<'t>),
}

///
/// Type derived for non-terminal LiteralCharNoApostrophe
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralCharNoApostrophe<'t> {
    pub literal_char_no_apostrophe: Token<'t>, /* [\t\u{20}-\u{26}\u{28}-\u{7E}]+ */
}

///
/// Type derived for non-terminal LiteralString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralString<'t> {
    pub literal_string_list: Vec<LiteralStringList<'t>>,
}

///
/// Type derived for non-terminal LiteralStringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LiteralStringList<'t> {
    pub literal_char: Box<LiteralChar<'t>>,
}

///
/// Type derived for non-terminal LocalDate
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalDate<'t> {
    pub local_date: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2} */
}

///
/// Type derived for non-terminal LocalDateTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalDateTime<'t> {
    pub local_date_time: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)? */
}

///
/// Type derived for non-terminal LocalTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalTime<'t> {
    pub local_time: Token<'t>, /* [0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)? */
}

///
/// Type derived for non-terminal MLBChar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBChar<'t> {
    MLBUnescaped(MLBCharMLBUnescaped<'t>),
    Escaped(MLBCharEscaped<'t>),
}

///
/// Type derived for non-terminal MLBContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBContent<'t> {
    MLBChar(MLBContentMLBChar<'t>),
    Newline(MLBContentNewline<'t>),
    MLBEscapedNL(MLBContentMLBEscapedNL<'t>),
}

///
/// Type derived for non-terminal MLBContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBContentList<'t> {
    MLBContentMLBContentList(MLBContentListMLBContentMLBContentList<'t>),
    MLBContentListEmpty(MLBContentListMLBContentListEmpty),
}

///
/// Type derived for non-terminal MLBContentList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBContentList1<'t> {
    pub m_l_b_content: Box<MLBContent<'t>>,
    pub m_l_b_content_list: Box<MLBContentList<'t>>,
}

///
/// Type derived for non-terminal MLBEscapedNL
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBEscapedNL<'t> {
    pub m_l_b_escaped_n_l: Token<'t>, /* \u{5C}[ \t]*\r?\n([ \t]|\r?\n)* */
}

///
/// Type derived for non-terminal MLBQuotes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBQuotes<'t> {
    pub m_l_b_quotes: Token<'t>, /* \u{22}{1,2} */
}

///
/// Type derived for non-terminal MLBUnescaped
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLBUnescaped<'t> {
    AsciiNoEscape(MLBUnescapedAsciiNoEscape<'t>),
    NonAscii(MLBUnescapedNonAscii<'t>),
}

///
/// Type derived for non-terminal MLBasicBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicBody<'t> {
    pub m_l_b_content_list: Box<MLBContentList<'t>>,
    pub m_l_basic_body_list: Vec<MLBasicBodyList<'t>>,
}

///
/// Type derived for non-terminal MLBasicBodyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicBodyList<'t> {
    pub m_l_b_quotes: Box<MLBQuotes<'t>>,
    pub m_l_b_content_list1: Box<MLBContentList1<'t>>,
}

///
/// Type derived for non-terminal MLBasicString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicString<'t> {
    pub m_l_basic_string_start: Box<MLBasicStringStart<'t>>,
    pub m_l_basic_body: Box<MLBasicBody<'t>>,
    pub m_l_basic_string_end: Box<MLBasicStringEnd<'t>>,
}

///
/// Type derived for non-terminal MLBasicStringEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicStringEnd<'t> {
    pub m_l_basic_string_end: Token<'t>, /* \u{22}{3,5} */
}

///
/// Type derived for non-terminal MLBasicStringStart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLBasicStringStart<'t> {
    pub m_l_basic_string_start: Token<'t>, /* \u{22}{3} */
}

///
/// Type derived for non-terminal MLLContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLLContent<'t> {
    LiteralChar(MLLContentLiteralChar<'t>),
    Newline(MLLContentNewline<'t>),
}

///
/// Type derived for non-terminal MLLContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MLLContentList<'t> {
    MLLContentMLLContentList(MLLContentListMLLContentMLLContentList<'t>),
    MLLContentListEmpty(MLLContentListMLLContentListEmpty),
}

///
/// Type derived for non-terminal MLLContentList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLContentList1<'t> {
    pub m_l_l_content: Box<MLLContent<'t>>,
    pub m_l_l_content_list: Box<MLLContentList<'t>>,
}

///
/// Type derived for non-terminal MLLQuotes
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLQuotes<'t> {
    pub m_l_l_quotes: Token<'t>, /* \u{27}{1,2} */
}

///
/// Type derived for non-terminal MLLiteralBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralBody<'t> {
    pub m_l_l_content_list: Box<MLLContentList<'t>>,
    pub m_l_literal_body_list: Vec<MLLiteralBodyList<'t>>,
}

///
/// Type derived for non-terminal MLLiteralBodyList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralBodyList<'t> {
    pub m_l_l_quotes: Box<MLLQuotes<'t>>,
    pub m_l_l_content_list1: Box<MLLContentList1<'t>>,
}

///
/// Type derived for non-terminal MLLiteralString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralString<'t> {
    pub m_l_literal_body: Box<MLLiteralBody<'t>>,
}

///
/// Type derived for non-terminal MLLiteralStringEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralStringEnd<'t> {
    pub m_l_literal_string_end: Token<'t>, /* \u{27}{3,5}(?:\r?\n)? */
}

///
/// Type derived for non-terminal MLLiteralStringStart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MLLiteralStringStart<'t> {
    pub m_l_literal_string_start: Token<'t>, /* \u{27}{3} */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* \u{2D} */
}

///
/// Type derived for non-terminal Newline
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Newline<'t> {
    pub newline: Token<'t>, /* \r?\n */
}

///
/// Type derived for non-terminal NonAscii
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonAscii<'t> {
    pub non_ascii: Token<'t>, /* [\u{80}-\u{D7FF}\u{E000}-\u{10FFFF}] */
}

///
/// Type derived for non-terminal NormalFloat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NormalFloat<'t> {
    pub normal_float: Token<'t>, /* [-+]?(?:0|[1-9](?:[0-9]|_[0-9])*)(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*|(?:\.[0-9](?:[0-9]|_[0-9])*(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*)?)) */
}

///
/// Type derived for non-terminal Numeric
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Numeric<'t> {
    Float(NumericFloat<'t>),
    Integer(NumericInteger<'t>),
}

///
/// Type derived for non-terminal OctInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctInt<'t> {
    pub oct_int_content: Box<OctIntContent<'t>>,
}

///
/// Type derived for non-terminal OctIntContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctIntContent<'t> {
    pub oct_int_content: Token<'t>, /* [0-7]([0-7]|_[0-7])* */
}

///
/// Type derived for non-terminal OctPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OctPrefix<'t> {
    pub oct_prefix: Token<'t>, /* 0o */
}

///
/// Type derived for non-terminal OffsetDateTime
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OffsetDateTime<'t> {
    pub offset_date_time: Token<'t>, /* [0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?([Zz]|[-+][0-9]{2}:[0-9]{2}) */
}

///
/// Type derived for non-terminal ParolToml
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParolToml<'t> {
    pub parol_toml_list: Vec<ParolTomlList<'t>>,
}

///
/// Type derived for non-terminal ParolTomlList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParolTomlList<'t> {
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* \u{2B} */
}

///
/// Type derived for non-terminal QuotationMark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotationMark<'t> {
    pub quotation_mark: Token<'t>, /* \u{22} */
}

///
/// Type derived for non-terminal QuotedKey
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QuotedKey<'t> {
    BasicString(QuotedKeyBasicString<'t>),
    LiteralString(QuotedKeyLiteralString<'t>),
}

///
/// Type derived for non-terminal SimpleKey
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SimpleKey<'t> {
    QuotedKey(SimpleKeyQuotedKey<'t>),
    UnquotedKey(SimpleKeyUnquotedKey<'t>),
}

///
/// Type derived for non-terminal SpecialFloat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SpecialFloat<'t> {
    pub special_float: Token<'t>, /* [-+]?(nan|inf) */
}

///
/// Type derived for non-terminal StdTable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTable<'t> {
    pub key: Box<Key<'t>>,
}

///
/// Type derived for non-terminal StdTableClose
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTableClose<'t> {
    pub array_close: Box<ArrayClose<'t>>,
}

///
/// Type derived for non-terminal StdTableOpen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StdTableOpen<'t> {
    pub array_open: Box<ArrayOpen<'t>>,
}

///
/// Type derived for non-terminal Table
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Table<'t> {
    StdTable(TableStdTable<'t>),
    ArrayTable(TableArrayTable<'t>),
}

///
/// Type derived for non-terminal Unicode4
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode4<'t> {
    pub unicode4: Token<'t>, /* u[0-9a-fA-F]{4} */
}

///
/// Type derived for non-terminal Unicode8
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode8<'t> {
    pub unicode8: Token<'t>, /* U[0-9a-fA-F]{8} */
}

///
/// Type derived for non-terminal UnquotedKey
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnquotedKey<'t> {
    pub unquoted_key: Token<'t>, /* [-_A-Za-z0-9]+ */
}

///
/// Type derived for non-terminal UnsignedDecInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnsignedDecInt<'t> {
    pub unsigned_dec_int: Token<'t>, /* 0|[1-9]([0-9]|_[0-9])* */
}

///
/// Type derived for non-terminal Val
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Val<'t> {
    Boolean(ValBoolean<'t>),
    Array(ValArray<'t>),
    InlineTable(ValInlineTable<'t>),
    DateTime(ValDateTime<'t>),
    Numeric(ValNumeric<'t>),
    BasicString(ValBasicString<'t>),
    MLBasicString(ValMLBasicString<'t>),
    LiteralString(ValLiteralString<'t>),
    MLLiteralString(ValMLLiteralString<'t>),
}

///
/// Type derived for non-terminal WsNewline
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WsNewline<'t> {
    pub ws_newline: Token<'t>, /* [ \t]*\r?\n */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Apostrophe(Apostrophe<'t>),
    Array(Array<'t>),
    ArrayClose(ArrayClose<'t>),
    ArrayOpen(ArrayOpen<'t>),
    ArrayOpt(Option<Box<ArrayOpt<'t>>>),
    ArraySep(ArraySep<'t>),
    ArrayTable(ArrayTable<'t>),
    ArrayTableClose(ArrayTableClose<'t>),
    ArrayTableOpen(ArrayTableOpen<'t>),
    ArrayValues(ArrayValues<'t>),
    ArrayValuesSuffix(ArrayValuesSuffix<'t>),
    ArrayValuesSuffix0(ArrayValuesSuffix0<'t>),
    AsciiNoEscape(AsciiNoEscape<'t>),
    BasicChar(BasicChar<'t>),
    BasicString(BasicString<'t>),
    BasicStringList(Vec<BasicStringList<'t>>),
    BasicUnescaped(BasicUnescaped<'t>),
    BinInt(BinInt<'t>),
    BinIntContent(BinIntContent<'t>),
    BinPrefix(BinPrefix<'t>),
    Boolean(Boolean<'t>),
    DateTime(DateTime<'t>),
    DecInt(DecInt<'t>),
    DecIntOpt(Option<Box<DecIntOpt<'t>>>),
    DecIntOptGroup(DecIntOptGroup<'t>),
    DotSep(DotSep<'t>),
    Escape(Escape<'t>),
    EscapeSeqChar(EscapeSeqChar<'t>),
    Escaped(Escaped<'t>),
    Expression(Expression<'t>),
    Float(Float<'t>),
    HexInt(HexInt<'t>),
    HexIntContent(HexIntContent<'t>),
    HexPrefix(HexPrefix<'t>),
    InlineTable(InlineTable<'t>),
    InlineTableClose(InlineTableClose<'t>),
    InlineTableKeyVals(InlineTableKeyVals<'t>),
    InlineTableKeyValsOpt(Option<Box<InlineTableKeyValsOpt<'t>>>),
    InlineTableOpen(InlineTableOpen<'t>),
    InlineTableOpt(Option<Box<InlineTableOpt<'t>>>),
    InlineTableSep(InlineTableSep<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyList(Vec<KeyList<'t>>),
    KeySuffix(KeySuffix<'t>),
    KeyVal(KeyVal<'t>),
    KeyValSep(KeyValSep<'t>),
    LiteralChar(LiteralChar<'t>),
    LiteralCharNoApostrophe(LiteralCharNoApostrophe<'t>),
    LiteralString(LiteralString<'t>),
    LiteralStringList(Vec<LiteralStringList<'t>>),
    LocalDate(LocalDate<'t>),
    LocalDateTime(LocalDateTime<'t>),
    LocalTime(LocalTime<'t>),
    MLBChar(MLBChar<'t>),
    MLBContent(MLBContent<'t>),
    MLBContentList(MLBContentList<'t>),
    MLBContentList1(MLBContentList1<'t>),
    MLBEscapedNL(MLBEscapedNL<'t>),
    MLBQuotes(MLBQuotes<'t>),
    MLBUnescaped(MLBUnescaped<'t>),
    MLBasicBody(MLBasicBody<'t>),
    MLBasicBodyList(Vec<MLBasicBodyList<'t>>),
    MLBasicString(MLBasicString<'t>),
    MLBasicStringEnd(MLBasicStringEnd<'t>),
    MLBasicStringStart(MLBasicStringStart<'t>),
    MLLContent(MLLContent<'t>),
    MLLContentList(MLLContentList<'t>),
    MLLContentList1(MLLContentList1<'t>),
    MLLQuotes(MLLQuotes<'t>),
    MLLiteralBody(MLLiteralBody<'t>),
    MLLiteralBodyList(Vec<MLLiteralBodyList<'t>>),
    MLLiteralString(MLLiteralString<'t>),
    MLLiteralStringEnd(MLLiteralStringEnd<'t>),
    MLLiteralStringStart(MLLiteralStringStart<'t>),
    Minus(Minus<'t>),
    Newline(Newline<'t>),
    NonAscii(NonAscii<'t>),
    NormalFloat(NormalFloat<'t>),
    Numeric(Numeric<'t>),
    OctInt(OctInt<'t>),
    OctIntContent(OctIntContent<'t>),
    OctPrefix(OctPrefix<'t>),
    OffsetDateTime(OffsetDateTime<'t>),
    ParolToml(ParolToml<'t>),
    ParolTomlList(Vec<ParolTomlList<'t>>),
    Plus(Plus<'t>),
    QuotationMark(QuotationMark<'t>),
    QuotedKey(QuotedKey<'t>),
    SimpleKey(SimpleKey<'t>),
    SpecialFloat(SpecialFloat<'t>),
    StdTable(StdTable<'t>),
    StdTableClose(StdTableClose<'t>),
    StdTableOpen(StdTableOpen<'t>),
    Table(Table<'t>),
    Unicode4(Unicode4<'t>),
    Unicode8(Unicode8<'t>),
    UnquotedKey(UnquotedKey<'t>),
    UnsignedDecInt(UnsignedDecInt<'t>),
    Val(Val<'t>),
    WsNewline(WsNewline<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolTomlGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolTomlGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolTomlGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolTomlGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolTomlGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// ParolToml: ParolTomlList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml(
        &mut self,
        _parol_toml_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_toml_list = pop_and_reverse_item!(self, parol_toml_list, ParolTomlList, context);
        let parol_toml_built = ParolTomlBuilder::default()
            .parol_toml_list(parol_toml_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parol_toml(&parol_toml_built)?;
        self.push(ASTType::ParolToml(parol_toml_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ParolTomlList /* Vec<T>::Push */: Expression ParolTomlList;
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml_list_0(
        &mut self,
        _expression: &ParseTreeStackEntry<'t>,
        _parol_toml_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut parol_toml_list = pop_item!(self, parol_toml_list, ParolTomlList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let parol_toml_list_0_built = ParolTomlListBuilder::default()
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        parol_toml_list.push(parol_toml_list_0_built);
        self.push(ASTType::ParolTomlList(parol_toml_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ParolTomlList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn parol_toml_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_toml_list_1_built = Vec::new();
        self.push(ASTType::ParolTomlList(parol_toml_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Expression: KeyVal;
    ///
    #[parol_runtime::function_name::named]
    fn expression_0(
        &mut self,
        _key_val: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_val = pop_item!(self, key_val, KeyVal, context);
        let expression_0_built = ExpressionKeyValBuilder::default()
            .key_val(Box::new(key_val))
            .build()
            .into_diagnostic()?;
        let expression_0_built = Expression::KeyVal(expression_0_built);
        // Calling user action here
        self.user_grammar.expression(&expression_0_built)?;
        self.push(ASTType::Expression(expression_0_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Expression: Table;
    ///
    #[parol_runtime::function_name::named]
    fn expression_1(
        &mut self,
        _table: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table = pop_item!(self, table, Table, context);
        let expression_1_built = ExpressionTableBuilder::default()
            .table(Box::new(table))
            .build()
            .into_diagnostic()?;
        let expression_1_built = Expression::Table(expression_1_built);
        // Calling user action here
        self.user_grammar.expression(&expression_1_built)?;
        self.push(ASTType::Expression(expression_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Newline: <MLBString, MLLString>"\r?\n";
    ///
    #[parol_runtime::function_name::named]
    fn newline(
        &mut self,
        newline: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = newline.token(parse_tree)?.clone();
        let newline_built = NewlineBuilder::default()
            .newline(newline)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.newline(&newline_built)?;
        self.push(ASTType::Newline(newline_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// WsNewline: <Esc>"[ \t]*\r?\n";
    ///
    #[parol_runtime::function_name::named]
    fn ws_newline(
        &mut self,
        ws_newline: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws_newline = ws_newline.token(parse_tree)?.clone();
        let ws_newline_built = WsNewlineBuilder::default()
            .ws_newline(ws_newline)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ws_newline(&ws_newline_built)?;
        self.push(ASTType::WsNewline(ws_newline_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// NonAscii: <BString, MLBString, LString, MLLString>"[\u{80}-\u{D7FF}\u{E000}-\u{10FFFF}]";
    ///
    #[parol_runtime::function_name::named]
    fn non_ascii(
        &mut self,
        non_ascii: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = non_ascii.token(parse_tree)?.clone();
        let non_ascii_built = NonAsciiBuilder::default()
            .non_ascii(non_ascii)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.non_ascii(&non_ascii_built)?;
        self.push(ASTType::NonAscii(non_ascii_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// KeyVal: Key KeyValSep %push(Val) Val %pop();
    ///
    #[parol_runtime::function_name::named]
    fn key_val(
        &mut self,
        _key: &ParseTreeStackEntry<'t>,
        _key_val_sep: &ParseTreeStackEntry<'t>,
        _val: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let val = pop_item!(self, val, Val, context);
        let key_val_sep = pop_item!(self, key_val_sep, KeyValSep, context);
        let key = pop_item!(self, key, Key, context);
        let key_val_built = KeyValBuilder::default()
            .key(Box::new(key))
            .key_val_sep(Box::new(key_val_sep))
            .val(Box::new(val))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.key_val(&key_val_built)?;
        self.push(ASTType::KeyVal(key_val_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Key: SimpleKey KeySuffix;
    ///
    #[parol_runtime::function_name::named]
    fn key(
        &mut self,
        _simple_key: &ParseTreeStackEntry<'t>,
        _key_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_suffix = pop_item!(self, key_suffix, KeySuffix, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let key_built = KeyBuilder::default()
            .simple_key(Box::new(simple_key))
            .key_suffix(Box::new(key_suffix))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// KeySuffix: ;
    ///
    #[parol_runtime::function_name::named]
    fn key_suffix_0(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_suffix_0_built = KeySuffixKeySuffixEmptyBuilder::default()
            .build()
            .into_diagnostic()?;
        let key_suffix_0_built = KeySuffix::KeySuffixEmpty(key_suffix_0_built);
        self.push(ASTType::KeySuffix(key_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// KeySuffix: DotSep SimpleKey KeyList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn key_suffix_1(
        &mut self,
        _dot_sep: &ParseTreeStackEntry<'t>,
        _simple_key: &ParseTreeStackEntry<'t>,
        _key_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_list = pop_and_reverse_item!(self, key_list, KeyList, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let dot_sep = pop_item!(self, dot_sep, DotSep, context);
        let key_suffix_1_built = KeySuffixDotSepSimpleKeyKeyListBuilder::default()
            .dot_sep(Box::new(dot_sep))
            .simple_key(Box::new(simple_key))
            .key_list(key_list)
            .build()
            .into_diagnostic()?;
        let key_suffix_1_built = KeySuffix::DotSepSimpleKeyKeyList(key_suffix_1_built);
        self.push(ASTType::KeySuffix(key_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// KeyList /* Vec<T>::Push */: DotSep SimpleKey KeyList;
    ///
    #[parol_runtime::function_name::named]
    fn key_list_0(
        &mut self,
        _dot_sep: &ParseTreeStackEntry<'t>,
        _simple_key: &ParseTreeStackEntry<'t>,
        _key_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut key_list = pop_item!(self, key_list, KeyList, context);
        let simple_key = pop_item!(self, simple_key, SimpleKey, context);
        let dot_sep = pop_item!(self, dot_sep, DotSep, context);
        let key_list_0_built = KeyListBuilder::default()
            .simple_key(Box::new(simple_key))
            .dot_sep(Box::new(dot_sep))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        key_list.push(key_list_0_built);
        self.push(ASTType::KeyList(key_list), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// KeyList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn key_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_list_1_built = Vec::new();
        self.push(ASTType::KeyList(key_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// SimpleKey: QuotedKey;
    ///
    #[parol_runtime::function_name::named]
    fn simple_key_0(
        &mut self,
        _quoted_key: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_key = pop_item!(self, quoted_key, QuotedKey, context);
        let simple_key_0_built = SimpleKeyQuotedKeyBuilder::default()
            .quoted_key(Box::new(quoted_key))
            .build()
            .into_diagnostic()?;
        let simple_key_0_built = SimpleKey::QuotedKey(simple_key_0_built);
        // Calling user action here
        self.user_grammar.simple_key(&simple_key_0_built)?;
        self.push(ASTType::SimpleKey(simple_key_0_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// SimpleKey: UnquotedKey;
    ///
    #[parol_runtime::function_name::named]
    fn simple_key_1(
        &mut self,
        _unquoted_key: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unquoted_key = pop_item!(self, unquoted_key, UnquotedKey, context);
        let simple_key_1_built = SimpleKeyUnquotedKeyBuilder::default()
            .unquoted_key(Box::new(unquoted_key))
            .build()
            .into_diagnostic()?;
        let simple_key_1_built = SimpleKey::UnquotedKey(simple_key_1_built);
        // Calling user action here
        self.user_grammar.simple_key(&simple_key_1_built)?;
        self.push(ASTType::SimpleKey(simple_key_1_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// QuotedKey: BasicString;
    ///
    #[parol_runtime::function_name::named]
    fn quoted_key_0(
        &mut self,
        _basic_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string = pop_item!(self, basic_string, BasicString, context);
        let quoted_key_0_built = QuotedKeyBasicStringBuilder::default()
            .basic_string(Box::new(basic_string))
            .build()
            .into_diagnostic()?;
        let quoted_key_0_built = QuotedKey::BasicString(quoted_key_0_built);
        // Calling user action here
        self.user_grammar.quoted_key(&quoted_key_0_built)?;
        self.push(ASTType::QuotedKey(quoted_key_0_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// QuotedKey: LiteralString;
    ///
    #[parol_runtime::function_name::named]
    fn quoted_key_1(
        &mut self,
        _literal_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = pop_item!(self, literal_string, LiteralString, context);
        let quoted_key_1_built = QuotedKeyLiteralStringBuilder::default()
            .literal_string(Box::new(literal_string))
            .build()
            .into_diagnostic()?;
        let quoted_key_1_built = QuotedKey::LiteralString(quoted_key_1_built);
        // Calling user action here
        self.user_grammar.quoted_key(&quoted_key_1_built)?;
        self.push(ASTType::QuotedKey(quoted_key_1_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// KeyValSep: <INITIAL, Val>"=";
    ///
    #[parol_runtime::function_name::named]
    fn key_val_sep(
        &mut self,
        key_val_sep: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_val_sep = key_val_sep.token(parse_tree)?.clone();
        let key_val_sep_built = KeyValSepBuilder::default()
            .key_val_sep(key_val_sep)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.key_val_sep(&key_val_sep_built)?;
        self.push(ASTType::KeyValSep(key_val_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Val: Boolean;
    ///
    #[parol_runtime::function_name::named]
    fn val_0(
        &mut self,
        _boolean: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let val_0_built = ValBooleanBuilder::default()
            .boolean(Box::new(boolean))
            .build()
            .into_diagnostic()?;
        let val_0_built = Val::Boolean(val_0_built);
        // Calling user action here
        self.user_grammar.val(&val_0_built)?;
        self.push(ASTType::Val(val_0_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Val: Array;
    ///
    #[parol_runtime::function_name::named]
    fn val_1(
        &mut self,
        _array: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let val_1_built = ValArrayBuilder::default()
            .array(Box::new(array))
            .build()
            .into_diagnostic()?;
        let val_1_built = Val::Array(val_1_built);
        // Calling user action here
        self.user_grammar.val(&val_1_built)?;
        self.push(ASTType::Val(val_1_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Val: InlineTable;
    ///
    #[parol_runtime::function_name::named]
    fn val_2(
        &mut self,
        _inline_table: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table = pop_item!(self, inline_table, InlineTable, context);
        let val_2_built = ValInlineTableBuilder::default()
            .inline_table(Box::new(inline_table))
            .build()
            .into_diagnostic()?;
        let val_2_built = Val::InlineTable(val_2_built);
        // Calling user action here
        self.user_grammar.val(&val_2_built)?;
        self.push(ASTType::Val(val_2_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Val: DateTime;
    ///
    #[parol_runtime::function_name::named]
    fn val_3(
        &mut self,
        _date_time: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let date_time = pop_item!(self, date_time, DateTime, context);
        let val_3_built = ValDateTimeBuilder::default()
            .date_time(Box::new(date_time))
            .build()
            .into_diagnostic()?;
        let val_3_built = Val::DateTime(val_3_built);
        // Calling user action here
        self.user_grammar.val(&val_3_built)?;
        self.push(ASTType::Val(val_3_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Val: Numeric;
    ///
    #[parol_runtime::function_name::named]
    fn val_4(
        &mut self,
        _numeric: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let numeric = pop_item!(self, numeric, Numeric, context);
        let val_4_built = ValNumericBuilder::default()
            .numeric(Box::new(numeric))
            .build()
            .into_diagnostic()?;
        let val_4_built = Val::Numeric(val_4_built);
        // Calling user action here
        self.user_grammar.val(&val_4_built)?;
        self.push(ASTType::Val(val_4_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Val: BasicString;
    ///
    #[parol_runtime::function_name::named]
    fn val_5(
        &mut self,
        _basic_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string = pop_item!(self, basic_string, BasicString, context);
        let val_5_built = ValBasicStringBuilder::default()
            .basic_string(Box::new(basic_string))
            .build()
            .into_diagnostic()?;
        let val_5_built = Val::BasicString(val_5_built);
        // Calling user action here
        self.user_grammar.val(&val_5_built)?;
        self.push(ASTType::Val(val_5_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Val: MLBasicString;
    ///
    #[parol_runtime::function_name::named]
    fn val_6(
        &mut self,
        _m_l_basic_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string = pop_item!(self, m_l_basic_string, MLBasicString, context);
        let val_6_built = ValMLBasicStringBuilder::default()
            .m_l_basic_string(Box::new(m_l_basic_string))
            .build()
            .into_diagnostic()?;
        let val_6_built = Val::MLBasicString(val_6_built);
        // Calling user action here
        self.user_grammar.val(&val_6_built)?;
        self.push(ASTType::Val(val_6_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Val: LiteralString;
    ///
    #[parol_runtime::function_name::named]
    fn val_7(
        &mut self,
        _literal_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string = pop_item!(self, literal_string, LiteralString, context);
        let val_7_built = ValLiteralStringBuilder::default()
            .literal_string(Box::new(literal_string))
            .build()
            .into_diagnostic()?;
        let val_7_built = Val::LiteralString(val_7_built);
        // Calling user action here
        self.user_grammar.val(&val_7_built)?;
        self.push(ASTType::Val(val_7_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Val: MLLiteralString;
    ///
    #[parol_runtime::function_name::named]
    fn val_8(
        &mut self,
        _m_l_literal_string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string = pop_item!(self, m_l_literal_string, MLLiteralString, context);
        let val_8_built = ValMLLiteralStringBuilder::default()
            .m_l_literal_string(Box::new(m_l_literal_string))
            .build()
            .into_diagnostic()?;
        let val_8_built = Val::MLLiteralString(val_8_built);
        // Calling user action here
        self.user_grammar.val(&val_8_built)?;
        self.push(ASTType::Val(val_8_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Numeric: Float;
    ///
    #[parol_runtime::function_name::named]
    fn numeric_0(
        &mut self,
        _float: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = pop_item!(self, float, Float, context);
        let numeric_0_built = NumericFloatBuilder::default()
            .float(Box::new(float))
            .build()
            .into_diagnostic()?;
        let numeric_0_built = Numeric::Float(numeric_0_built);
        // Calling user action here
        self.user_grammar.numeric(&numeric_0_built)?;
        self.push(ASTType::Numeric(numeric_0_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Numeric: Integer;
    ///
    #[parol_runtime::function_name::named]
    fn numeric_1(
        &mut self,
        _integer: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let numeric_1_built = NumericIntegerBuilder::default()
            .integer(Box::new(integer))
            .build()
            .into_diagnostic()?;
        let numeric_1_built = Numeric::Integer(numeric_1_built);
        // Calling user action here
        self.user_grammar.numeric(&numeric_1_built)?;
        self.push(ASTType::Numeric(numeric_1_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// BasicString: QuotationMark %push(BString) BasicStringList /* Vec */ %pop() QuotationMark;
    ///
    #[parol_runtime::function_name::named]
    fn basic_string(
        &mut self,
        _quotation_mark: &ParseTreeStackEntry<'t>,
        _basic_string_list: &ParseTreeStackEntry<'t>,
        _quotation_mark0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark0 = pop_item!(self, quotation_mark0, QuotationMark, context);
        let basic_string_list =
            pop_and_reverse_item!(self, basic_string_list, BasicStringList, context);
        let quotation_mark = pop_item!(self, quotation_mark, QuotationMark, context);
        let basic_string_built = BasicStringBuilder::default()
            .quotation_mark(Box::new(quotation_mark))
            .basic_string_list(basic_string_list)
            .quotation_mark0(Box::new(quotation_mark0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.basic_string(&basic_string_built)?;
        self.push(ASTType::BasicString(basic_string_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// BasicStringList /* Vec<T>::Push */: BasicChar BasicStringList;
    ///
    #[parol_runtime::function_name::named]
    fn basic_string_list_0(
        &mut self,
        _basic_char: &ParseTreeStackEntry<'t>,
        _basic_string_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut basic_string_list = pop_item!(self, basic_string_list, BasicStringList, context);
        let basic_char = pop_item!(self, basic_char, BasicChar, context);
        let basic_string_list_0_built = BasicStringListBuilder::default()
            .basic_char(Box::new(basic_char))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_string_list.push(basic_string_list_0_built);
        self.push(ASTType::BasicStringList(basic_string_list), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// BasicStringList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn basic_string_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_string_list_1_built = Vec::new();
        self.push(ASTType::BasicStringList(basic_string_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// BasicChar: BasicUnescaped;
    ///
    #[parol_runtime::function_name::named]
    fn basic_char_0(
        &mut self,
        _basic_unescaped: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_unescaped = pop_item!(self, basic_unescaped, BasicUnescaped, context);
        let basic_char_0_built = BasicCharBasicUnescapedBuilder::default()
            .basic_unescaped(Box::new(basic_unescaped))
            .build()
            .into_diagnostic()?;
        let basic_char_0_built = BasicChar::BasicUnescaped(basic_char_0_built);
        // Calling user action here
        self.user_grammar.basic_char(&basic_char_0_built)?;
        self.push(ASTType::BasicChar(basic_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// BasicChar: %push(Esc) Escaped %pop();
    ///
    #[parol_runtime::function_name::named]
    fn basic_char_1(
        &mut self,
        _escaped: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = pop_item!(self, escaped, Escaped, context);
        let basic_char_1_built = BasicCharEscapedBuilder::default()
            .escaped(Box::new(escaped))
            .build()
            .into_diagnostic()?;
        let basic_char_1_built = BasicChar::Escaped(basic_char_1_built);
        // Calling user action here
        self.user_grammar.basic_char(&basic_char_1_built)?;
        self.push(ASTType::BasicChar(basic_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// BasicUnescaped: AsciiNoEscape;
    ///
    #[parol_runtime::function_name::named]
    fn basic_unescaped_0(
        &mut self,
        _ascii_no_escape: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let basic_unescaped_0_built = BasicUnescapedAsciiNoEscapeBuilder::default()
            .ascii_no_escape(Box::new(ascii_no_escape))
            .build()
            .into_diagnostic()?;
        let basic_unescaped_0_built = BasicUnescaped::AsciiNoEscape(basic_unescaped_0_built);
        // Calling user action here
        self.user_grammar
            .basic_unescaped(&basic_unescaped_0_built)?;
        self.push(ASTType::BasicUnescaped(basic_unescaped_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// BasicUnescaped: NonAscii;
    ///
    #[parol_runtime::function_name::named]
    fn basic_unescaped_1(
        &mut self,
        _non_ascii: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let basic_unescaped_1_built = BasicUnescapedNonAsciiBuilder::default()
            .non_ascii(Box::new(non_ascii))
            .build()
            .into_diagnostic()?;
        let basic_unescaped_1_built = BasicUnescaped::NonAscii(basic_unescaped_1_built);
        // Calling user action here
        self.user_grammar
            .basic_unescaped(&basic_unescaped_1_built)?;
        self.push(ASTType::BasicUnescaped(basic_unescaped_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Escaped: Escape EscapeSeqChar;
    ///
    #[parol_runtime::function_name::named]
    fn escaped(
        &mut self,
        _escape: &ParseTreeStackEntry<'t>,
        _escape_seq_char: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape_seq_char = pop_item!(self, escape_seq_char, EscapeSeqChar, context);
        let escape = pop_item!(self, escape, Escape, context);
        let escaped_built = EscapedBuilder::default()
            .escape(Box::new(escape))
            .escape_seq_char(Box::new(escape_seq_char))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.escaped(&escaped_built)?;
        self.push(ASTType::Escaped(escaped_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Escape: <Esc, BString, MLBString>"\u{5C}";
    ///
    #[parol_runtime::function_name::named]
    fn escape(
        &mut self,
        escape: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape = escape.token(parse_tree)?.clone();
        let escape_built = EscapeBuilder::default()
            .escape(escape)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.escape(&escape_built)?;
        self.push(ASTType::Escape(escape_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// EscapeSeqChar: QuotationMark;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_0(
        &mut self,
        _quotation_mark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark = pop_item!(self, quotation_mark, QuotationMark, context);
        let escape_seq_char_0_built = EscapeSeqCharQuotationMarkBuilder::default()
            .quotation_mark(Box::new(quotation_mark))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_0_built = EscapeSeqChar::QuotationMark(escape_seq_char_0_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_0_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// EscapeSeqChar: Escape;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_1(
        &mut self,
        _escape: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape = pop_item!(self, escape, Escape, context);
        let escape_seq_char_1_built = EscapeSeqCharEscapeBuilder::default()
            .escape(Box::new(escape))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_1_built = EscapeSeqChar::Escape(escape_seq_char_1_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_1_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// EscapeSeqChar: <Esc>"b";
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_2(
        &mut self,
        b: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = b.token(parse_tree)?.clone();
        let escape_seq_char_2_built = EscapeSeqCharBBuilder::default()
            .b(b)
            .build()
            .into_diagnostic()?;
        let escape_seq_char_2_built = EscapeSeqChar::B(escape_seq_char_2_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_2_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_2_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// EscapeSeqChar: <Esc>"f";
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_3(
        &mut self,
        f: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f = f.token(parse_tree)?.clone();
        let escape_seq_char_3_built = EscapeSeqCharFBuilder::default()
            .f(f)
            .build()
            .into_diagnostic()?;
        let escape_seq_char_3_built = EscapeSeqChar::F(escape_seq_char_3_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_3_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_3_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// EscapeSeqChar: <Esc>"n";
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_4(
        &mut self,
        n: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let n = n.token(parse_tree)?.clone();
        let escape_seq_char_4_built = EscapeSeqCharNBuilder::default()
            .n(n)
            .build()
            .into_diagnostic()?;
        let escape_seq_char_4_built = EscapeSeqChar::N(escape_seq_char_4_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_4_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_4_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// EscapeSeqChar: <Esc>"r";
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_5(
        &mut self,
        r: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r = r.token(parse_tree)?.clone();
        let escape_seq_char_5_built = EscapeSeqCharRBuilder::default()
            .r(r)
            .build()
            .into_diagnostic()?;
        let escape_seq_char_5_built = EscapeSeqChar::R(escape_seq_char_5_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_5_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_5_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// EscapeSeqChar: <Esc>"t";
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_6(
        &mut self,
        t: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t = t.token(parse_tree)?.clone();
        let escape_seq_char_6_built = EscapeSeqCharTBuilder::default()
            .t(t)
            .build()
            .into_diagnostic()?;
        let escape_seq_char_6_built = EscapeSeqChar::T(escape_seq_char_6_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_6_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_6_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// EscapeSeqChar: Unicode4;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_7(
        &mut self,
        _unicode4: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = pop_item!(self, unicode4, Unicode4, context);
        let escape_seq_char_7_built = EscapeSeqCharUnicode4Builder::default()
            .unicode4(Box::new(unicode4))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_7_built = EscapeSeqChar::Unicode4(escape_seq_char_7_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_7_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_7_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// EscapeSeqChar: Unicode8;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_8(
        &mut self,
        _unicode8: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = pop_item!(self, unicode8, Unicode8, context);
        let escape_seq_char_8_built = EscapeSeqCharUnicode8Builder::default()
            .unicode8(Box::new(unicode8))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_8_built = EscapeSeqChar::Unicode8(escape_seq_char_8_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_8_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_8_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// EscapeSeqChar: WsNewline;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_9(
        &mut self,
        _ws_newline: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws_newline = pop_item!(self, ws_newline, WsNewline, context);
        let escape_seq_char_9_built = EscapeSeqCharWsNewlineBuilder::default()
            .ws_newline(Box::new(ws_newline))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_9_built = EscapeSeqChar::WsNewline(escape_seq_char_9_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_9_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_9_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// EscapeSeqChar: AsciiNoEscape;
    ///
    #[parol_runtime::function_name::named]
    fn escape_seq_char_10(
        &mut self,
        _ascii_no_escape: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let escape_seq_char_10_built = EscapeSeqCharAsciiNoEscapeBuilder::default()
            .ascii_no_escape(Box::new(ascii_no_escape))
            .build()
            .into_diagnostic()?;
        let escape_seq_char_10_built = EscapeSeqChar::AsciiNoEscape(escape_seq_char_10_built);
        // Calling user action here
        self.user_grammar
            .escape_seq_char(&escape_seq_char_10_built)?;
        self.push(ASTType::EscapeSeqChar(escape_seq_char_10_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Unicode4: <Esc>"u[0-9a-fA-F]{4}";
    ///
    #[parol_runtime::function_name::named]
    fn unicode4(
        &mut self,
        unicode4: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = unicode4.token(parse_tree)?.clone();
        let unicode4_built = Unicode4Builder::default()
            .unicode4(unicode4)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.unicode4(&unicode4_built)?;
        self.push(ASTType::Unicode4(unicode4_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Unicode8: <Esc>"U[0-9a-fA-F]{8}";
    ///
    #[parol_runtime::function_name::named]
    fn unicode8(
        &mut self,
        unicode8: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = unicode8.token(parse_tree)?.clone();
        let unicode8_built = Unicode8Builder::default()
            .unicode8(unicode8)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.unicode8(&unicode8_built)?;
        self.push(ASTType::Unicode8(unicode8_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// MLBasicString: MLBasicStringStart %push(MLBString) MLBasicBody MLBasicStringEnd %pop();
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string(
        &mut self,
        _m_l_basic_string_start: &ParseTreeStackEntry<'t>,
        _m_l_basic_body: &ParseTreeStackEntry<'t>,
        _m_l_basic_string_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_end = pop_item!(self, m_l_basic_string_end, MLBasicStringEnd, context);
        let m_l_basic_body = pop_item!(self, m_l_basic_body, MLBasicBody, context);
        let m_l_basic_string_start =
            pop_item!(self, m_l_basic_string_start, MLBasicStringStart, context);
        let m_l_basic_string_built = MLBasicStringBuilder::default()
            .m_l_basic_string_start(Box::new(m_l_basic_string_start))
            .m_l_basic_body(Box::new(m_l_basic_body))
            .m_l_basic_string_end(Box::new(m_l_basic_string_end))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_basic_string(&m_l_basic_string_built)?;
        self.push(ASTType::MLBasicString(m_l_basic_string_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// MLBasicBody: MLBContentList MLBasicBodyList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body(
        &mut self,
        _m_l_b_content_list: &ParseTreeStackEntry<'t>,
        _m_l_basic_body_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_body_list =
            pop_and_reverse_item!(self, m_l_basic_body_list, MLBasicBodyList, context);
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_basic_body_built = MLBasicBodyBuilder::default()
            .m_l_b_content_list(Box::new(m_l_b_content_list))
            .m_l_basic_body_list(m_l_basic_body_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.m_l_basic_body(&m_l_basic_body_built)?;
        self.push(ASTType::MLBasicBody(m_l_basic_body_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// MLBasicBodyList /* Vec<T>::Push */: MLBQuotes MLBContentList1 MLBasicBodyList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body_list_0(
        &mut self,
        _m_l_b_quotes: &ParseTreeStackEntry<'t>,
        _m_l_b_content_list1: &ParseTreeStackEntry<'t>,
        _m_l_basic_body_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut m_l_basic_body_list =
            pop_item!(self, m_l_basic_body_list, MLBasicBodyList, context);
        let m_l_b_content_list1 = pop_item!(self, m_l_b_content_list1, MLBContentList1, context);
        let m_l_b_quotes = pop_item!(self, m_l_b_quotes, MLBQuotes, context);
        let m_l_basic_body_list_0_built = MLBasicBodyListBuilder::default()
            .m_l_b_content_list1(Box::new(m_l_b_content_list1))
            .m_l_b_quotes(Box::new(m_l_b_quotes))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        m_l_basic_body_list.push(m_l_basic_body_list_0_built);
        self.push(ASTType::MLBasicBodyList(m_l_basic_body_list), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// MLBasicBodyList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_body_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_body_list_1_built = Vec::new();
        self.push(
            ASTType::MLBasicBodyList(m_l_basic_body_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// MLBContentList: MLBContent MLBContentList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list_0(
        &mut self,
        _m_l_b_content: &ParseTreeStackEntry<'t>,
        _m_l_b_content_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_b_content = pop_item!(self, m_l_b_content, MLBContent, context);
        let m_l_b_content_list_0_built = MLBContentListMLBContentMLBContentListBuilder::default()
            .m_l_b_content(Box::new(m_l_b_content))
            .m_l_b_content_list(Box::new(m_l_b_content_list))
            .build()
            .into_diagnostic()?;
        let m_l_b_content_list_0_built =
            MLBContentList::MLBContentMLBContentList(m_l_b_content_list_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list(&m_l_b_content_list_0_built)?;
        self.push(ASTType::MLBContentList(m_l_b_content_list_0_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// MLBContentList: ;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list_1_built = MLBContentListMLBContentListEmptyBuilder::default()
            .build()
            .into_diagnostic()?;
        let m_l_b_content_list_1_built =
            MLBContentList::MLBContentListEmpty(m_l_b_content_list_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list(&m_l_b_content_list_1_built)?;
        self.push(ASTType::MLBContentList(m_l_b_content_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// MLBContentList1: MLBContent MLBContentList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_list1(
        &mut self,
        _m_l_b_content: &ParseTreeStackEntry<'t>,
        _m_l_b_content_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_content_list = pop_item!(self, m_l_b_content_list, MLBContentList, context);
        let m_l_b_content = pop_item!(self, m_l_b_content, MLBContent, context);
        let m_l_b_content_list1_built = MLBContentList1Builder::default()
            .m_l_b_content(Box::new(m_l_b_content))
            .m_l_b_content_list(Box::new(m_l_b_content_list))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_b_content_list1(&m_l_b_content_list1_built)?;
        self.push(ASTType::MLBContentList1(m_l_b_content_list1_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// MLBContent: MLBChar;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_0(
        &mut self,
        _m_l_b_char: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_char = pop_item!(self, m_l_b_char, MLBChar, context);
        let m_l_b_content_0_built = MLBContentMLBCharBuilder::default()
            .m_l_b_char(Box::new(m_l_b_char))
            .build()
            .into_diagnostic()?;
        let m_l_b_content_0_built = MLBContent::MLBChar(m_l_b_content_0_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_0_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_0_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// MLBContent: Newline;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_1(
        &mut self,
        _newline: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let m_l_b_content_1_built = MLBContentNewlineBuilder::default()
            .newline(Box::new(newline))
            .build()
            .into_diagnostic()?;
        let m_l_b_content_1_built = MLBContent::Newline(m_l_b_content_1_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_1_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// MLBContent: MLBEscapedNL;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_content_2(
        &mut self,
        _m_l_b_escaped_n_l: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_escaped_n_l = pop_item!(self, m_l_b_escaped_n_l, MLBEscapedNL, context);
        let m_l_b_content_2_built = MLBContentMLBEscapedNLBuilder::default()
            .m_l_b_escaped_n_l(Box::new(m_l_b_escaped_n_l))
            .build()
            .into_diagnostic()?;
        let m_l_b_content_2_built = MLBContent::MLBEscapedNL(m_l_b_content_2_built);
        // Calling user action here
        self.user_grammar.m_l_b_content(&m_l_b_content_2_built)?;
        self.push(ASTType::MLBContent(m_l_b_content_2_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// MLBChar: MLBUnescaped;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_char_0(
        &mut self,
        _m_l_b_unescaped: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_unescaped = pop_item!(self, m_l_b_unescaped, MLBUnescaped, context);
        let m_l_b_char_0_built = MLBCharMLBUnescapedBuilder::default()
            .m_l_b_unescaped(Box::new(m_l_b_unescaped))
            .build()
            .into_diagnostic()?;
        let m_l_b_char_0_built = MLBChar::MLBUnescaped(m_l_b_char_0_built);
        // Calling user action here
        self.user_grammar.m_l_b_char(&m_l_b_char_0_built)?;
        self.push(ASTType::MLBChar(m_l_b_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// MLBChar: %push(Esc) Escaped %pop();
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_char_1(
        &mut self,
        _escaped: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = pop_item!(self, escaped, Escaped, context);
        let m_l_b_char_1_built = MLBCharEscapedBuilder::default()
            .escaped(Box::new(escaped))
            .build()
            .into_diagnostic()?;
        let m_l_b_char_1_built = MLBChar::Escaped(m_l_b_char_1_built);
        // Calling user action here
        self.user_grammar.m_l_b_char(&m_l_b_char_1_built)?;
        self.push(ASTType::MLBChar(m_l_b_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// MLBUnescaped: AsciiNoEscape;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_unescaped_0(
        &mut self,
        _ascii_no_escape: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = pop_item!(self, ascii_no_escape, AsciiNoEscape, context);
        let m_l_b_unescaped_0_built = MLBUnescapedAsciiNoEscapeBuilder::default()
            .ascii_no_escape(Box::new(ascii_no_escape))
            .build()
            .into_diagnostic()?;
        let m_l_b_unescaped_0_built = MLBUnescaped::AsciiNoEscape(m_l_b_unescaped_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_unescaped(&m_l_b_unescaped_0_built)?;
        self.push(ASTType::MLBUnescaped(m_l_b_unescaped_0_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// MLBUnescaped: NonAscii;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_unescaped_1(
        &mut self,
        _non_ascii: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let m_l_b_unescaped_1_built = MLBUnescapedNonAsciiBuilder::default()
            .non_ascii(Box::new(non_ascii))
            .build()
            .into_diagnostic()?;
        let m_l_b_unescaped_1_built = MLBUnescaped::NonAscii(m_l_b_unescaped_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_b_unescaped(&m_l_b_unescaped_1_built)?;
        self.push(ASTType::MLBUnescaped(m_l_b_unescaped_1_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// MLBEscapedNL: <MLBString>"\u{5C}[ \t]*\r?\n([ \t]|\r?\n)*";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_escaped_n_l(
        &mut self,
        m_l_b_escaped_n_l: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_escaped_n_l = m_l_b_escaped_n_l.token(parse_tree)?.clone();
        let m_l_b_escaped_n_l_built = MLBEscapedNLBuilder::default()
            .m_l_b_escaped_n_l(m_l_b_escaped_n_l)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_b_escaped_n_l(&m_l_b_escaped_n_l_built)?;
        self.push(ASTType::MLBEscapedNL(m_l_b_escaped_n_l_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// LiteralString: Apostrophe^ /* Clipped */ %push(LString) LiteralStringList /* Vec */ %pop() Apostrophe^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn literal_string(
        &mut self,
        _apostrophe: &ParseTreeStackEntry<'t>,
        _literal_string_list: &ParseTreeStackEntry<'t>,
        _apostrophe0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'apostrophe0'
        self.pop(context);
        let literal_string_list =
            pop_and_reverse_item!(self, literal_string_list, LiteralStringList, context);
        // Ignore clipped member 'apostrophe'
        self.pop(context);
        let literal_string_built = LiteralStringBuilder::default()
            // Ignore clipped member 'apostrophe'
            .literal_string_list(literal_string_list)
            // Ignore clipped member 'apostrophe0'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal_string(&literal_string_built)?;
        self.push(ASTType::LiteralString(literal_string_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// LiteralStringList /* Vec<T>::Push */: LiteralChar LiteralStringList;
    ///
    #[parol_runtime::function_name::named]
    fn literal_string_list_0(
        &mut self,
        _literal_char: &ParseTreeStackEntry<'t>,
        _literal_string_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut literal_string_list =
            pop_item!(self, literal_string_list, LiteralStringList, context);
        let literal_char = pop_item!(self, literal_char, LiteralChar, context);
        let literal_string_list_0_built = LiteralStringListBuilder::default()
            .literal_char(Box::new(literal_char))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        literal_string_list.push(literal_string_list_0_built);
        self.push(ASTType::LiteralStringList(literal_string_list), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// LiteralStringList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn literal_string_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_string_list_1_built = Vec::new();
        self.push(
            ASTType::LiteralStringList(literal_string_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// LiteralChar: LiteralCharNoApostrophe;
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_0(
        &mut self,
        _literal_char_no_apostrophe: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char_no_apostrophe = pop_item!(
            self,
            literal_char_no_apostrophe,
            LiteralCharNoApostrophe,
            context
        );
        let literal_char_0_built = LiteralCharLiteralCharNoApostropheBuilder::default()
            .literal_char_no_apostrophe(Box::new(literal_char_no_apostrophe))
            .build()
            .into_diagnostic()?;
        let literal_char_0_built = LiteralChar::LiteralCharNoApostrophe(literal_char_0_built);
        // Calling user action here
        self.user_grammar.literal_char(&literal_char_0_built)?;
        self.push(ASTType::LiteralChar(literal_char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// LiteralChar: NonAscii;
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_1(
        &mut self,
        _non_ascii: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_ascii = pop_item!(self, non_ascii, NonAscii, context);
        let literal_char_1_built = LiteralCharNonAsciiBuilder::default()
            .non_ascii(Box::new(non_ascii))
            .build()
            .into_diagnostic()?;
        let literal_char_1_built = LiteralChar::NonAscii(literal_char_1_built);
        // Calling user action here
        self.user_grammar.literal_char(&literal_char_1_built)?;
        self.push(ASTType::LiteralChar(literal_char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// LiteralCharNoApostrophe: <LString, MLLString>"[\t\u{20}-\u{26}\u{28}-\u{7E}]+";
    ///
    #[parol_runtime::function_name::named]
    fn literal_char_no_apostrophe(
        &mut self,
        literal_char_no_apostrophe: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char_no_apostrophe = literal_char_no_apostrophe.token(parse_tree)?.clone();
        let literal_char_no_apostrophe_built = LiteralCharNoApostropheBuilder::default()
            .literal_char_no_apostrophe(literal_char_no_apostrophe)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .literal_char_no_apostrophe(&literal_char_no_apostrophe_built)?;
        self.push(
            ASTType::LiteralCharNoApostrophe(literal_char_no_apostrophe_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// MLLiteralString: MLLiteralStringStart^ /* Clipped */ %push(MLLString) MLLiteralBody %pop();
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string(
        &mut self,
        _m_l_literal_string_start: &ParseTreeStackEntry<'t>,
        _m_l_literal_body: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_body = pop_item!(self, m_l_literal_body, MLLiteralBody, context);
        // Ignore clipped member 'm_l_literal_string_start'
        self.pop(context);
        let m_l_literal_string_built = MLLiteralStringBuilder::default()
            // Ignore clipped member 'm_l_literal_string_start'
            .m_l_literal_body(Box::new(m_l_literal_body))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_literal_string(&m_l_literal_string_built)?;
        self.push(ASTType::MLLiteralString(m_l_literal_string_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// MLLiteralBody: MLLContentList MLLiteralBodyList /* Vec */ MLLiteralStringEnd^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body(
        &mut self,
        _m_l_l_content_list: &ParseTreeStackEntry<'t>,
        _m_l_literal_body_list: &ParseTreeStackEntry<'t>,
        _m_l_literal_string_end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'm_l_literal_string_end'
        self.pop(context);
        let m_l_literal_body_list =
            pop_and_reverse_item!(self, m_l_literal_body_list, MLLiteralBodyList, context);
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_literal_body_built = MLLiteralBodyBuilder::default()
            .m_l_l_content_list(Box::new(m_l_l_content_list))
            .m_l_literal_body_list(m_l_literal_body_list)
            // Ignore clipped member 'm_l_literal_string_end'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_literal_body(&m_l_literal_body_built)?;
        self.push(ASTType::MLLiteralBody(m_l_literal_body_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// MLLiteralBodyList /* Vec<T>::Push */: MLLQuotes MLLContentList1 MLLiteralBodyList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body_list_0(
        &mut self,
        _m_l_l_quotes: &ParseTreeStackEntry<'t>,
        _m_l_l_content_list1: &ParseTreeStackEntry<'t>,
        _m_l_literal_body_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut m_l_literal_body_list =
            pop_item!(self, m_l_literal_body_list, MLLiteralBodyList, context);
        let m_l_l_content_list1 = pop_item!(self, m_l_l_content_list1, MLLContentList1, context);
        let m_l_l_quotes = pop_item!(self, m_l_l_quotes, MLLQuotes, context);
        let m_l_literal_body_list_0_built = MLLiteralBodyListBuilder::default()
            .m_l_l_content_list1(Box::new(m_l_l_content_list1))
            .m_l_l_quotes(Box::new(m_l_l_quotes))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        m_l_literal_body_list.push(m_l_literal_body_list_0_built);
        self.push(ASTType::MLLiteralBodyList(m_l_literal_body_list), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// MLLiteralBodyList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_body_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_body_list_1_built = Vec::new();
        self.push(
            ASTType::MLLiteralBodyList(m_l_literal_body_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// MLLContentList: MLLContent MLLContentList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list_0(
        &mut self,
        _m_l_l_content: &ParseTreeStackEntry<'t>,
        _m_l_l_content_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_l_content = pop_item!(self, m_l_l_content, MLLContent, context);
        let m_l_l_content_list_0_built = MLLContentListMLLContentMLLContentListBuilder::default()
            .m_l_l_content(Box::new(m_l_l_content))
            .m_l_l_content_list(Box::new(m_l_l_content_list))
            .build()
            .into_diagnostic()?;
        let m_l_l_content_list_0_built =
            MLLContentList::MLLContentMLLContentList(m_l_l_content_list_0_built);
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list(&m_l_l_content_list_0_built)?;
        self.push(ASTType::MLLContentList(m_l_l_content_list_0_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// MLLContentList: ;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list_1_built = MLLContentListMLLContentListEmptyBuilder::default()
            .build()
            .into_diagnostic()?;
        let m_l_l_content_list_1_built =
            MLLContentList::MLLContentListEmpty(m_l_l_content_list_1_built);
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list(&m_l_l_content_list_1_built)?;
        self.push(ASTType::MLLContentList(m_l_l_content_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// MLLContentList1: MLLContent MLLContentList;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_list1(
        &mut self,
        _m_l_l_content: &ParseTreeStackEntry<'t>,
        _m_l_l_content_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_content_list = pop_item!(self, m_l_l_content_list, MLLContentList, context);
        let m_l_l_content = pop_item!(self, m_l_l_content, MLLContent, context);
        let m_l_l_content_list1_built = MLLContentList1Builder::default()
            .m_l_l_content(Box::new(m_l_l_content))
            .m_l_l_content_list(Box::new(m_l_l_content_list))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_l_content_list1(&m_l_l_content_list1_built)?;
        self.push(ASTType::MLLContentList1(m_l_l_content_list1_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// MLLContent: LiteralChar;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_0(
        &mut self,
        _literal_char: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal_char = pop_item!(self, literal_char, LiteralChar, context);
        let m_l_l_content_0_built = MLLContentLiteralCharBuilder::default()
            .literal_char(Box::new(literal_char))
            .build()
            .into_diagnostic()?;
        let m_l_l_content_0_built = MLLContent::LiteralChar(m_l_l_content_0_built);
        // Calling user action here
        self.user_grammar.m_l_l_content(&m_l_l_content_0_built)?;
        self.push(ASTType::MLLContent(m_l_l_content_0_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// MLLContent: Newline;
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_content_1(
        &mut self,
        _newline: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let m_l_l_content_1_built = MLLContentNewlineBuilder::default()
            .newline(Box::new(newline))
            .build()
            .into_diagnostic()?;
        let m_l_l_content_1_built = MLLContent::Newline(m_l_l_content_1_built);
        // Calling user action here
        self.user_grammar.m_l_l_content(&m_l_l_content_1_built)?;
        self.push(ASTType::MLLContent(m_l_l_content_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// Integer: DecInt;
    ///
    #[parol_runtime::function_name::named]
    fn integer_0(
        &mut self,
        _dec_int: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dec_int = pop_item!(self, dec_int, DecInt, context);
        let integer_0_built = IntegerDecIntBuilder::default()
            .dec_int(Box::new(dec_int))
            .build()
            .into_diagnostic()?;
        let integer_0_built = Integer::DecInt(integer_0_built);
        // Calling user action here
        self.user_grammar.integer(&integer_0_built)?;
        self.push(ASTType::Integer(integer_0_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// Integer: HexInt;
    ///
    #[parol_runtime::function_name::named]
    fn integer_1(
        &mut self,
        _hex_int: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int = pop_item!(self, hex_int, HexInt, context);
        let integer_1_built = IntegerHexIntBuilder::default()
            .hex_int(Box::new(hex_int))
            .build()
            .into_diagnostic()?;
        let integer_1_built = Integer::HexInt(integer_1_built);
        // Calling user action here
        self.user_grammar.integer(&integer_1_built)?;
        self.push(ASTType::Integer(integer_1_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// Integer: OctInt;
    ///
    #[parol_runtime::function_name::named]
    fn integer_2(
        &mut self,
        _oct_int: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int = pop_item!(self, oct_int, OctInt, context);
        let integer_2_built = IntegerOctIntBuilder::default()
            .oct_int(Box::new(oct_int))
            .build()
            .into_diagnostic()?;
        let integer_2_built = Integer::OctInt(integer_2_built);
        // Calling user action here
        self.user_grammar.integer(&integer_2_built)?;
        self.push(ASTType::Integer(integer_2_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// Integer: BinInt;
    ///
    #[parol_runtime::function_name::named]
    fn integer_3(
        &mut self,
        _bin_int: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int = pop_item!(self, bin_int, BinInt, context);
        let integer_3_built = IntegerBinIntBuilder::default()
            .bin_int(Box::new(bin_int))
            .build()
            .into_diagnostic()?;
        let integer_3_built = Integer::BinInt(integer_3_built);
        // Calling user action here
        self.user_grammar.integer(&integer_3_built)?;
        self.push(ASTType::Integer(integer_3_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// HexPrefix: <Val>"0x";
    ///
    #[parol_runtime::function_name::named]
    fn hex_prefix(
        &mut self,
        hex_prefix: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_prefix = hex_prefix.token(parse_tree)?.clone();
        let hex_prefix_built = HexPrefixBuilder::default()
            .hex_prefix(hex_prefix)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hex_prefix(&hex_prefix_built)?;
        self.push(ASTType::HexPrefix(hex_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// OctPrefix: <Val>"0o";
    ///
    #[parol_runtime::function_name::named]
    fn oct_prefix(
        &mut self,
        oct_prefix: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_prefix = oct_prefix.token(parse_tree)?.clone();
        let oct_prefix_built = OctPrefixBuilder::default()
            .oct_prefix(oct_prefix)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.oct_prefix(&oct_prefix_built)?;
        self.push(ASTType::OctPrefix(oct_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// BinPrefix: <Val>"0b";
    ///
    #[parol_runtime::function_name::named]
    fn bin_prefix(
        &mut self,
        bin_prefix: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_prefix = bin_prefix.token(parse_tree)?.clone();
        let bin_prefix_built = BinPrefixBuilder::default()
            .bin_prefix(bin_prefix)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bin_prefix(&bin_prefix_built)?;
        self.push(ASTType::BinPrefix(bin_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// DecInt: DecIntOpt /* Option */ UnsignedDecInt;
    ///
    #[parol_runtime::function_name::named]
    fn dec_int(
        &mut self,
        _dec_int_opt: &ParseTreeStackEntry<'t>,
        _unsigned_dec_int: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_dec_int = pop_item!(self, unsigned_dec_int, UnsignedDecInt, context);
        let dec_int_opt = pop_item!(self, dec_int_opt, DecIntOpt, context);
        let dec_int_built = DecIntBuilder::default()
            .dec_int_opt(dec_int_opt)
            .unsigned_dec_int(Box::new(unsigned_dec_int))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dec_int(&dec_int_built)?;
        self.push(ASTType::DecInt(dec_int_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// DecIntOpt /* Option<T>::Some */: DecIntOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_0(
        &mut self,
        _dec_int_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dec_int_opt_group = pop_item!(self, dec_int_opt_group, DecIntOptGroup, context);
        let dec_int_opt_0_built = DecIntOptBuilder::default()
            .dec_int_opt_group(Box::new(dec_int_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DecIntOpt(Some(Box::new(dec_int_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// DecIntOptGroup: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_group_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let dec_int_opt_group_0_built = DecIntOptGroupPlusBuilder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let dec_int_opt_group_0_built = DecIntOptGroup::Plus(dec_int_opt_group_0_built);
        self.push(ASTType::DecIntOptGroup(dec_int_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// DecIntOptGroup: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_group_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let dec_int_opt_group_1_built = DecIntOptGroupMinusBuilder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let dec_int_opt_group_1_built = DecIntOptGroup::Minus(dec_int_opt_group_1_built);
        self.push(ASTType::DecIntOptGroup(dec_int_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// DecIntOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn dec_int_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DecIntOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// HexInt: HexPrefix^ /* Clipped */ %push(HexInt) HexIntContent %pop();
    ///
    #[parol_runtime::function_name::named]
    fn hex_int(
        &mut self,
        _hex_prefix: &ParseTreeStackEntry<'t>,
        _hex_int_content: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int_content = pop_item!(self, hex_int_content, HexIntContent, context);
        // Ignore clipped member 'hex_prefix'
        self.pop(context);
        let hex_int_built = HexIntBuilder::default()
            // Ignore clipped member 'hex_prefix'
            .hex_int_content(Box::new(hex_int_content))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hex_int(&hex_int_built)?;
        self.push(ASTType::HexInt(hex_int_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// HexIntContent: <HexInt>"[0-9a-fA-F]([0-9a-fA-F]|_[0-9a-fA-F])*";
    ///
    #[parol_runtime::function_name::named]
    fn hex_int_content(
        &mut self,
        hex_int_content: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_int_content = hex_int_content.token(parse_tree)?.clone();
        let hex_int_content_built = HexIntContentBuilder::default()
            .hex_int_content(hex_int_content)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hex_int_content(&hex_int_content_built)?;
        self.push(ASTType::HexIntContent(hex_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// OctInt: OctPrefix^ /* Clipped */ %push(OctInt) OctIntContent %pop();
    ///
    #[parol_runtime::function_name::named]
    fn oct_int(
        &mut self,
        _oct_prefix: &ParseTreeStackEntry<'t>,
        _oct_int_content: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int_content = pop_item!(self, oct_int_content, OctIntContent, context);
        // Ignore clipped member 'oct_prefix'
        self.pop(context);
        let oct_int_built = OctIntBuilder::default()
            // Ignore clipped member 'oct_prefix'
            .oct_int_content(Box::new(oct_int_content))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.oct_int(&oct_int_built)?;
        self.push(ASTType::OctInt(oct_int_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// OctIntContent: <OctInt>"[0-7]([0-7]|_[0-7])*";
    ///
    #[parol_runtime::function_name::named]
    fn oct_int_content(
        &mut self,
        oct_int_content: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let oct_int_content = oct_int_content.token(parse_tree)?.clone();
        let oct_int_content_built = OctIntContentBuilder::default()
            .oct_int_content(oct_int_content)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.oct_int_content(&oct_int_content_built)?;
        self.push(ASTType::OctIntContent(oct_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// BinInt: BinPrefix^ /* Clipped */ %push(BinInt) BinIntContent %pop();
    ///
    #[parol_runtime::function_name::named]
    fn bin_int(
        &mut self,
        _bin_prefix: &ParseTreeStackEntry<'t>,
        _bin_int_content: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int_content = pop_item!(self, bin_int_content, BinIntContent, context);
        // Ignore clipped member 'bin_prefix'
        self.pop(context);
        let bin_int_built = BinIntBuilder::default()
            // Ignore clipped member 'bin_prefix'
            .bin_int_content(Box::new(bin_int_content))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bin_int(&bin_int_built)?;
        self.push(ASTType::BinInt(bin_int_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// BinIntContent: <BinInt>"[01]([01]|_[01])*";
    ///
    #[parol_runtime::function_name::named]
    fn bin_int_content(
        &mut self,
        bin_int_content: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bin_int_content = bin_int_content.token(parse_tree)?.clone();
        let bin_int_content_built = BinIntContentBuilder::default()
            .bin_int_content(bin_int_content)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bin_int_content(&bin_int_content_built)?;
        self.push(ASTType::BinIntContent(bin_int_content_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// Boolean: <Val>"true";
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(
        &mut self,
        r#true: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token(parse_tree)?.clone();
        let boolean_0_built = BooleanTrueBuilder::default()
            .r#true(r#true)
            .build()
            .into_diagnostic()?;
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// Boolean: <Val>"false";
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(
        &mut self,
        r#false: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token(parse_tree)?.clone();
        let boolean_1_built = BooleanFalseBuilder::default()
            .r#false(r#false)
            .build()
            .into_diagnostic()?;
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// Float: NormalFloat;
    ///
    #[parol_runtime::function_name::named]
    fn float_0(
        &mut self,
        _normal_float: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let normal_float = pop_item!(self, normal_float, NormalFloat, context);
        let float_0_built = FloatNormalFloatBuilder::default()
            .normal_float(Box::new(normal_float))
            .build()
            .into_diagnostic()?;
        let float_0_built = Float::NormalFloat(float_0_built);
        // Calling user action here
        self.user_grammar.float(&float_0_built)?;
        self.push(ASTType::Float(float_0_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// Float: SpecialFloat;
    ///
    #[parol_runtime::function_name::named]
    fn float_1(
        &mut self,
        _special_float: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let special_float = pop_item!(self, special_float, SpecialFloat, context);
        let float_1_built = FloatSpecialFloatBuilder::default()
            .special_float(Box::new(special_float))
            .build()
            .into_diagnostic()?;
        let float_1_built = Float::SpecialFloat(float_1_built);
        // Calling user action here
        self.user_grammar.float(&float_1_built)?;
        self.push(ASTType::Float(float_1_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// NormalFloat: <Val>"[-+]?(?:0|[1-9](?:[0-9]|_[0-9])*)(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*|(?:\.[0-9](?:[0-9]|_[0-9])*(?:[eE][-+]?[0-9](?:[0-9]|_[0-9])*)?))";
    ///
    #[parol_runtime::function_name::named]
    fn normal_float(
        &mut self,
        normal_float: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let normal_float = normal_float.token(parse_tree)?.clone();
        let normal_float_built = NormalFloatBuilder::default()
            .normal_float(normal_float)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.normal_float(&normal_float_built)?;
        self.push(ASTType::NormalFloat(normal_float_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// SpecialFloat: <Val>"[-+]?(nan|inf)";
    ///
    #[parol_runtime::function_name::named]
    fn special_float(
        &mut self,
        special_float: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let special_float = special_float.token(parse_tree)?.clone();
        let special_float_built = SpecialFloatBuilder::default()
            .special_float(special_float)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.special_float(&special_float_built)?;
        self.push(ASTType::SpecialFloat(special_float_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// DateTime: OffsetDateTime;
    ///
    #[parol_runtime::function_name::named]
    fn date_time_0(
        &mut self,
        _offset_date_time: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let offset_date_time = pop_item!(self, offset_date_time, OffsetDateTime, context);
        let date_time_0_built = DateTimeOffsetDateTimeBuilder::default()
            .offset_date_time(Box::new(offset_date_time))
            .build()
            .into_diagnostic()?;
        let date_time_0_built = DateTime::OffsetDateTime(date_time_0_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_0_built)?;
        self.push(ASTType::DateTime(date_time_0_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// DateTime: LocalDateTime;
    ///
    #[parol_runtime::function_name::named]
    fn date_time_1(
        &mut self,
        _local_date_time: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date_time = pop_item!(self, local_date_time, LocalDateTime, context);
        let date_time_1_built = DateTimeLocalDateTimeBuilder::default()
            .local_date_time(Box::new(local_date_time))
            .build()
            .into_diagnostic()?;
        let date_time_1_built = DateTime::LocalDateTime(date_time_1_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_1_built)?;
        self.push(ASTType::DateTime(date_time_1_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// DateTime: LocalDate;
    ///
    #[parol_runtime::function_name::named]
    fn date_time_2(
        &mut self,
        _local_date: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date = pop_item!(self, local_date, LocalDate, context);
        let date_time_2_built = DateTimeLocalDateBuilder::default()
            .local_date(Box::new(local_date))
            .build()
            .into_diagnostic()?;
        let date_time_2_built = DateTime::LocalDate(date_time_2_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_2_built)?;
        self.push(ASTType::DateTime(date_time_2_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// DateTime: LocalTime;
    ///
    #[parol_runtime::function_name::named]
    fn date_time_3(
        &mut self,
        _local_time: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_time = pop_item!(self, local_time, LocalTime, context);
        let date_time_3_built = DateTimeLocalTimeBuilder::default()
            .local_time(Box::new(local_time))
            .build()
            .into_diagnostic()?;
        let date_time_3_built = DateTime::LocalTime(date_time_3_built);
        // Calling user action here
        self.user_grammar.date_time(&date_time_3_built)?;
        self.push(ASTType::DateTime(date_time_3_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// OffsetDateTime: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?([Zz]|[-+][0-9]{2}:[0-9]{2})";
    ///
    #[parol_runtime::function_name::named]
    fn offset_date_time(
        &mut self,
        offset_date_time: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let offset_date_time = offset_date_time.token(parse_tree)?.clone();
        let offset_date_time_built = OffsetDateTimeBuilder::default()
            .offset_date_time(offset_date_time)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .offset_date_time(&offset_date_time_built)?;
        self.push(ASTType::OffsetDateTime(offset_date_time_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// LocalDateTime: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}[Tt ][0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?";
    ///
    #[parol_runtime::function_name::named]
    fn local_date_time(
        &mut self,
        local_date_time: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date_time = local_date_time.token(parse_tree)?.clone();
        let local_date_time_built = LocalDateTimeBuilder::default()
            .local_date_time(local_date_time)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.local_date_time(&local_date_time_built)?;
        self.push(ASTType::LocalDateTime(local_date_time_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// LocalDate: <Val>"[0-9]{4}-[0-9]{2}-[0-9]{2}";
    ///
    #[parol_runtime::function_name::named]
    fn local_date(
        &mut self,
        local_date: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_date = local_date.token(parse_tree)?.clone();
        let local_date_built = LocalDateBuilder::default()
            .local_date(local_date)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.local_date(&local_date_built)?;
        self.push(ASTType::LocalDate(local_date_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// LocalTime: <Val>"[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?";
    ///
    #[parol_runtime::function_name::named]
    fn local_time(
        &mut self,
        local_time: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let local_time = local_time.token(parse_tree)?.clone();
        let local_time_built = LocalTimeBuilder::default()
            .local_time(local_time)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.local_time(&local_time_built)?;
        self.push(ASTType::LocalTime(local_time_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// Array: ArrayOpen^ /* Clipped */ %push(Val) ArrayOpt /* Option */ %pop() ArrayClose^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_open: &ParseTreeStackEntry<'t>,
        _array_opt: &ParseTreeStackEntry<'t>,
        _array_close: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'array_close'
        self.pop(context);
        let array_opt = pop_item!(self, array_opt, ArrayOpt, context);
        // Ignore clipped member 'array_open'
        self.pop(context);
        let array_built = ArrayBuilder::default()
            // Ignore clipped member 'array_open'
            .array_opt(array_opt)
            // Ignore clipped member 'array_close'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// ArrayOpt /* Option<T>::Some */: ArrayValues;
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_0(
        &mut self,
        _array_values: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values = pop_item!(self, array_values, ArrayValues, context);
        let array_opt_0_built = ArrayOptBuilder::default()
            .array_values(Box::new(array_values))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ArrayOpt(Some(Box::new(array_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// ArrayOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// ArrayValues: Val ArrayValuesSuffix0;
    ///
    #[parol_runtime::function_name::named]
    fn array_values(
        &mut self,
        _val: &ParseTreeStackEntry<'t>,
        _array_values_suffix0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix0 =
            pop_item!(self, array_values_suffix0, ArrayValuesSuffix0, context);
        let val = pop_item!(self, val, Val, context);
        let array_values_built = ArrayValuesBuilder::default()
            .val(Box::new(val))
            .array_values_suffix0(Box::new(array_values_suffix0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array_values(&array_values_built)?;
        self.push(ASTType::ArrayValues(array_values_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// ArrayValuesSuffix0: ArraySep^ /* Clipped */ ArrayValuesSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix0_0(
        &mut self,
        _array_sep: &ParseTreeStackEntry<'t>,
        _array_values_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix = pop_item!(self, array_values_suffix, ArrayValuesSuffix, context);
        // Ignore clipped member 'array_sep'
        self.pop(context);
        let array_values_suffix0_0_built =
            ArrayValuesSuffix0ArraySepArrayValuesSuffixBuilder::default()
                // Ignore clipped member 'array_sep'
                .array_values_suffix(Box::new(array_values_suffix))
                .build()
                .into_diagnostic()?;
        let array_values_suffix0_0_built =
            ArrayValuesSuffix0::ArraySepArrayValuesSuffix(array_values_suffix0_0_built);
        self.push(
            ASTType::ArrayValuesSuffix0(array_values_suffix0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// ArrayValuesSuffix0: ;
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix0_1_built =
            ArrayValuesSuffix0ArrayValuesSuffix0EmptyBuilder::default()
                .build()
                .into_diagnostic()?;
        let array_values_suffix0_1_built =
            ArrayValuesSuffix0::ArrayValuesSuffix0Empty(array_values_suffix0_1_built);
        self.push(
            ASTType::ArrayValuesSuffix0(array_values_suffix0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// ArrayValuesSuffix: ArrayValues;
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix_0(
        &mut self,
        _array_values: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values = pop_item!(self, array_values, ArrayValues, context);
        let array_values_suffix_0_built = ArrayValuesSuffixArrayValuesBuilder::default()
            .array_values(Box::new(array_values))
            .build()
            .into_diagnostic()?;
        let array_values_suffix_0_built =
            ArrayValuesSuffix::ArrayValues(array_values_suffix_0_built);
        self.push(
            ASTType::ArrayValuesSuffix(array_values_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// ArrayValuesSuffix: ;
    ///
    #[parol_runtime::function_name::named]
    fn array_values_suffix_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_values_suffix_1_built = ArrayValuesSuffixArrayValuesSuffixEmptyBuilder::default()
            .build()
            .into_diagnostic()?;
        let array_values_suffix_1_built =
            ArrayValuesSuffix::ArrayValuesSuffixEmpty(array_values_suffix_1_built);
        self.push(
            ASTType::ArrayValuesSuffix(array_values_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// ArraySep: <INITIAL, Val>",";
    ///
    #[parol_runtime::function_name::named]
    fn array_sep(
        &mut self,
        array_sep: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_sep = array_sep.token(parse_tree)?.clone();
        let array_sep_built = ArraySepBuilder::default()
            .array_sep(array_sep)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array_sep(&array_sep_built)?;
        self.push(ASTType::ArraySep(array_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// Table: StdTable;
    ///
    #[parol_runtime::function_name::named]
    fn table_0(
        &mut self,
        _std_table: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let std_table = pop_item!(self, std_table, StdTable, context);
        let table_0_built = TableStdTableBuilder::default()
            .std_table(Box::new(std_table))
            .build()
            .into_diagnostic()?;
        let table_0_built = Table::StdTable(table_0_built);
        // Calling user action here
        self.user_grammar.table(&table_0_built)?;
        self.push(ASTType::Table(table_0_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// Table: ArrayTable;
    ///
    #[parol_runtime::function_name::named]
    fn table_1(
        &mut self,
        _array_table: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table = pop_item!(self, array_table, ArrayTable, context);
        let table_1_built = TableArrayTableBuilder::default()
            .array_table(Box::new(array_table))
            .build()
            .into_diagnostic()?;
        let table_1_built = Table::ArrayTable(table_1_built);
        // Calling user action here
        self.user_grammar.table(&table_1_built)?;
        self.push(ASTType::Table(table_1_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// StdTable: StdTableOpen^ /* Clipped */ Key StdTableClose^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn std_table(
        &mut self,
        _std_table_open: &ParseTreeStackEntry<'t>,
        _key: &ParseTreeStackEntry<'t>,
        _std_table_close: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'std_table_close'
        self.pop(context);
        let key = pop_item!(self, key, Key, context);
        // Ignore clipped member 'std_table_open'
        self.pop(context);
        let std_table_built = StdTableBuilder::default()
            // Ignore clipped member 'std_table_open'
            .key(Box::new(key))
            // Ignore clipped member 'std_table_close'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.std_table(&std_table_built)?;
        self.push(ASTType::StdTable(std_table_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// ArrayTableOpen: "\u{5B}\u{5B}";
    ///
    #[parol_runtime::function_name::named]
    fn array_table_open(
        &mut self,
        array_table_open: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table_open = array_table_open.token(parse_tree)?.clone();
        let array_table_open_built = ArrayTableOpenBuilder::default()
            .array_table_open(array_table_open)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .array_table_open(&array_table_open_built)?;
        self.push(ASTType::ArrayTableOpen(array_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// ArrayTableClose: "\u{5D}\u{5D}";
    ///
    #[parol_runtime::function_name::named]
    fn array_table_close(
        &mut self,
        array_table_close: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_table_close = array_table_close.token(parse_tree)?.clone();
        let array_table_close_built = ArrayTableCloseBuilder::default()
            .array_table_close(array_table_close)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .array_table_close(&array_table_close_built)?;
        self.push(ASTType::ArrayTableClose(array_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// ArrayOpen: <INITIAL, Val>"\u{5B}";
    ///
    #[parol_runtime::function_name::named]
    fn array_open(
        &mut self,
        array_open: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_open = array_open.token(parse_tree)?.clone();
        let array_open_built = ArrayOpenBuilder::default()
            .array_open(array_open)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array_open(&array_open_built)?;
        self.push(ASTType::ArrayOpen(array_open_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// ArrayClose: <INITIAL, Val>"\u{5D}";
    ///
    #[parol_runtime::function_name::named]
    fn array_close(
        &mut self,
        array_close: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_close = array_close.token(parse_tree)?.clone();
        let array_close_built = ArrayCloseBuilder::default()
            .array_close(array_close)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array_close(&array_close_built)?;
        self.push(ASTType::ArrayClose(array_close_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// StdTableOpen: ArrayOpen;
    ///
    #[parol_runtime::function_name::named]
    fn std_table_open(
        &mut self,
        _array_open: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_open = pop_item!(self, array_open, ArrayOpen, context);
        let std_table_open_built = StdTableOpenBuilder::default()
            .array_open(Box::new(array_open))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.std_table_open(&std_table_open_built)?;
        self.push(ASTType::StdTableOpen(std_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// StdTableClose: ArrayClose;
    ///
    #[parol_runtime::function_name::named]
    fn std_table_close(
        &mut self,
        _array_close: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_close = pop_item!(self, array_close, ArrayClose, context);
        let std_table_close_built = StdTableCloseBuilder::default()
            .array_close(Box::new(array_close))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.std_table_close(&std_table_close_built)?;
        self.push(ASTType::StdTableClose(std_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// InlineTable: InlineTableOpen^ /* Clipped */ %push(INITIAL) InlineTableOpt /* Option */ %pop() InlineTableClose^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table(
        &mut self,
        _inline_table_open: &ParseTreeStackEntry<'t>,
        _inline_table_opt: &ParseTreeStackEntry<'t>,
        _inline_table_close: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'inline_table_close'
        self.pop(context);
        let inline_table_opt = pop_item!(self, inline_table_opt, InlineTableOpt, context);
        // Ignore clipped member 'inline_table_open'
        self.pop(context);
        let inline_table_built = InlineTableBuilder::default()
            // Ignore clipped member 'inline_table_open'
            .inline_table_opt(inline_table_opt)
            // Ignore clipped member 'inline_table_close'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inline_table(&inline_table_built)?;
        self.push(ASTType::InlineTable(inline_table_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// InlineTableOpt /* Option<T>::Some */: InlineTableKeyVals;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt_0(
        &mut self,
        _inline_table_key_vals: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals =
            pop_item!(self, inline_table_key_vals, InlineTableKeyVals, context);
        let inline_table_opt_0_built = InlineTableOptBuilder::default()
            .inline_table_key_vals(Box::new(inline_table_key_vals))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InlineTableOpt(Some(Box::new(inline_table_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// InlineTableOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InlineTableOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// InlineTableOpen: <INITIAL, Val>"\u{7B}";
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_open(
        &mut self,
        inline_table_open: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_open = inline_table_open.token(parse_tree)?.clone();
        let inline_table_open_built = InlineTableOpenBuilder::default()
            .inline_table_open(inline_table_open)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inline_table_open(&inline_table_open_built)?;
        self.push(ASTType::InlineTableOpen(inline_table_open_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// InlineTableClose: <INITIAL, Val>"\u{7D}";
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_close(
        &mut self,
        inline_table_close: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_close = inline_table_close.token(parse_tree)?.clone();
        let inline_table_close_built = InlineTableCloseBuilder::default()
            .inline_table_close(inline_table_close)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inline_table_close(&inline_table_close_built)?;
        self.push(ASTType::InlineTableClose(inline_table_close_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// InlineTableSep: ArraySep;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_sep(
        &mut self,
        _array_sep: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_sep = pop_item!(self, array_sep, ArraySep, context);
        let inline_table_sep_built = InlineTableSepBuilder::default()
            .array_sep(Box::new(array_sep))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inline_table_sep(&inline_table_sep_built)?;
        self.push(ASTType::InlineTableSep(inline_table_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// InlineTableKeyVals: KeyVal InlineTableKeyValsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals(
        &mut self,
        _key_val: &ParseTreeStackEntry<'t>,
        _inline_table_key_vals_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals_opt = pop_item!(
            self,
            inline_table_key_vals_opt,
            InlineTableKeyValsOpt,
            context
        );
        let key_val = pop_item!(self, key_val, KeyVal, context);
        let inline_table_key_vals_built = InlineTableKeyValsBuilder::default()
            .key_val(Box::new(key_val))
            .inline_table_key_vals_opt(inline_table_key_vals_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inline_table_key_vals(&inline_table_key_vals_built)?;
        self.push(
            ASTType::InlineTableKeyVals(inline_table_key_vals_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// InlineTableKeyValsOpt /* Option<T>::Some */: InlineTableSep^ /* Clipped */ InlineTableKeyVals;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals_opt_0(
        &mut self,
        _inline_table_sep: &ParseTreeStackEntry<'t>,
        _inline_table_key_vals: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_table_key_vals =
            pop_item!(self, inline_table_key_vals, InlineTableKeyVals, context);
        // Ignore clipped member 'inline_table_sep'
        self.pop(context);
        let inline_table_key_vals_opt_0_built = InlineTableKeyValsOptBuilder::default()
            // Ignore clipped member 'inline_table_sep'
            .inline_table_key_vals(Box::new(inline_table_key_vals))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InlineTableKeyValsOpt(Some(Box::new(inline_table_key_vals_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// InlineTableKeyValsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inline_table_key_vals_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InlineTableKeyValsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// ArrayTable: ArrayTableOpen^ /* Clipped */ Key ArrayTableClose^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn array_table(
        &mut self,
        _array_table_open: &ParseTreeStackEntry<'t>,
        _key: &ParseTreeStackEntry<'t>,
        _array_table_close: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'array_table_close'
        self.pop(context);
        let key = pop_item!(self, key, Key, context);
        // Ignore clipped member 'array_table_open'
        self.pop(context);
        let array_table_built = ArrayTableBuilder::default()
            // Ignore clipped member 'array_table_open'
            .key(Box::new(key))
            // Ignore clipped member 'array_table_close'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.array_table(&array_table_built)?;
        self.push(ASTType::ArrayTable(array_table_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// UnsignedDecInt: <Val>"0|[1-9]([0-9]|_[0-9])*";
    ///
    #[parol_runtime::function_name::named]
    fn unsigned_dec_int(
        &mut self,
        unsigned_dec_int: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsigned_dec_int = unsigned_dec_int.token(parse_tree)?.clone();
        let unsigned_dec_int_built = UnsignedDecIntBuilder::default()
            .unsigned_dec_int(unsigned_dec_int)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .unsigned_dec_int(&unsigned_dec_int_built)?;
        self.push(ASTType::UnsignedDecInt(unsigned_dec_int_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// UnquotedKey: "[-_A-Za-z0-9]+";
    ///
    #[parol_runtime::function_name::named]
    fn unquoted_key(
        &mut self,
        unquoted_key: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unquoted_key = unquoted_key.token(parse_tree)?.clone();
        let unquoted_key_built = UnquotedKeyBuilder::default()
            .unquoted_key(unquoted_key)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.unquoted_key(&unquoted_key_built)?;
        self.push(ASTType::UnquotedKey(unquoted_key_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// DotSep: <INITIAL, Val>"\.";
    ///
    #[parol_runtime::function_name::named]
    fn dot_sep(
        &mut self,
        dot_sep: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_sep = dot_sep.token(parse_tree)?.clone();
        let dot_sep_built = DotSepBuilder::default()
            .dot_sep(dot_sep)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_sep(&dot_sep_built)?;
        self.push(ASTType::DotSep(dot_sep_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// MLBasicStringStart: <INITIAL, Val>"\u{22}{3}";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string_start(
        &mut self,
        m_l_basic_string_start: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_start = m_l_basic_string_start.token(parse_tree)?.clone();
        let m_l_basic_string_start_built = MLBasicStringStartBuilder::default()
            .m_l_basic_string_start(m_l_basic_string_start)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_basic_string_start(&m_l_basic_string_start_built)?;
        self.push(
            ASTType::MLBasicStringStart(m_l_basic_string_start_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// MLBasicStringEnd: <MLBString>"\u{22}{3,5}";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_basic_string_end(
        &mut self,
        m_l_basic_string_end: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_basic_string_end = m_l_basic_string_end.token(parse_tree)?.clone();
        let m_l_basic_string_end_built = MLBasicStringEndBuilder::default()
            .m_l_basic_string_end(m_l_basic_string_end)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_basic_string_end(&m_l_basic_string_end_built)?;
        self.push(
            ASTType::MLBasicStringEnd(m_l_basic_string_end_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// MLBQuotes: <MLBString>"\u{22}{1,2}";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_b_quotes(
        &mut self,
        m_l_b_quotes: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_b_quotes = m_l_b_quotes.token(parse_tree)?.clone();
        let m_l_b_quotes_built = MLBQuotesBuilder::default()
            .m_l_b_quotes(m_l_b_quotes)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.m_l_b_quotes(&m_l_b_quotes_built)?;
        self.push(ASTType::MLBQuotes(m_l_b_quotes_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// QuotationMark: <INITIAL, Esc, Val, BString>"\u{22}";
    ///
    #[parol_runtime::function_name::named]
    fn quotation_mark(
        &mut self,
        quotation_mark: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quotation_mark = quotation_mark.token(parse_tree)?.clone();
        let quotation_mark_built = QuotationMarkBuilder::default()
            .quotation_mark(quotation_mark)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.quotation_mark(&quotation_mark_built)?;
        self.push(ASTType::QuotationMark(quotation_mark_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// MLLiteralStringStart: <INITIAL, Val>"\u{27}{3}";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string_start(
        &mut self,
        m_l_literal_string_start: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string_start = m_l_literal_string_start.token(parse_tree)?.clone();
        let m_l_literal_string_start_built = MLLiteralStringStartBuilder::default()
            .m_l_literal_string_start(m_l_literal_string_start)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_literal_string_start(&m_l_literal_string_start_built)?;
        self.push(
            ASTType::MLLiteralStringStart(m_l_literal_string_start_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// MLLiteralStringEnd: <MLLString>"\u{27}{3,5}(?:\r?\n)?";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_literal_string_end(
        &mut self,
        m_l_literal_string_end: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_literal_string_end = m_l_literal_string_end.token(parse_tree)?.clone();
        let m_l_literal_string_end_built = MLLiteralStringEndBuilder::default()
            .m_l_literal_string_end(m_l_literal_string_end)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .m_l_literal_string_end(&m_l_literal_string_end_built)?;
        self.push(
            ASTType::MLLiteralStringEnd(m_l_literal_string_end_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// MLLQuotes: <MLLString>"\u{27}{1,2}";
    ///
    #[parol_runtime::function_name::named]
    fn m_l_l_quotes(
        &mut self,
        m_l_l_quotes: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_l_l_quotes = m_l_l_quotes.token(parse_tree)?.clone();
        let m_l_l_quotes_built = MLLQuotesBuilder::default()
            .m_l_l_quotes(m_l_l_quotes)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.m_l_l_quotes(&m_l_l_quotes_built)?;
        self.push(ASTType::MLLQuotes(m_l_l_quotes_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// Apostrophe: <INITIAL, Val, LString>"\u{27}";
    ///
    #[parol_runtime::function_name::named]
    fn apostrophe(
        &mut self,
        apostrophe: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let apostrophe = apostrophe.token(parse_tree)?.clone();
        let apostrophe_built = ApostropheBuilder::default()
            .apostrophe(apostrophe)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.apostrophe(&apostrophe_built)?;
        self.push(ASTType::Apostrophe(apostrophe_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// AsciiNoEscape: <Esc, BString, MLBString>"[ \t\u{21}\u{23}-\u{5B}\u{5D}-\u{7E}]+";
    ///
    #[parol_runtime::function_name::named]
    fn ascii_no_escape(
        &mut self,
        ascii_no_escape: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ascii_no_escape = ascii_no_escape.token(parse_tree)?.clone();
        let ascii_no_escape_built = AsciiNoEscapeBuilder::default()
            .ascii_no_escape(ascii_no_escape)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ascii_no_escape(&ascii_no_escape_built)?;
        self.push(ASTType::AsciiNoEscape(ascii_no_escape_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// Minus: <Val>"\u{2D}";
    ///
    #[parol_runtime::function_name::named]
    fn minus(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let minus_built = MinusBuilder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// Plus: <Val>"\u{2B}";
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolTomlGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolTomlGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_toml(&children[0], parse_tree),
            1 => self.parol_toml_list_0(&children[0], &children[1], parse_tree),
            2 => self.parol_toml_list_1(parse_tree),
            3 => self.expression_0(&children[0], parse_tree),
            4 => self.expression_1(&children[0], parse_tree),
            5 => self.newline(&children[0], parse_tree),
            6 => self.ws_newline(&children[0], parse_tree),
            7 => self.non_ascii(&children[0], parse_tree),
            8 => self.key_val(&children[0], &children[1], &children[2], parse_tree),
            9 => self.key(&children[0], &children[1], parse_tree),
            10 => self.key_suffix_0(parse_tree),
            11 => self.key_suffix_1(&children[0], &children[1], &children[2], parse_tree),
            12 => self.key_list_0(&children[0], &children[1], &children[2], parse_tree),
            13 => self.key_list_1(parse_tree),
            14 => self.simple_key_0(&children[0], parse_tree),
            15 => self.simple_key_1(&children[0], parse_tree),
            16 => self.quoted_key_0(&children[0], parse_tree),
            17 => self.quoted_key_1(&children[0], parse_tree),
            18 => self.key_val_sep(&children[0], parse_tree),
            19 => self.val_0(&children[0], parse_tree),
            20 => self.val_1(&children[0], parse_tree),
            21 => self.val_2(&children[0], parse_tree),
            22 => self.val_3(&children[0], parse_tree),
            23 => self.val_4(&children[0], parse_tree),
            24 => self.val_5(&children[0], parse_tree),
            25 => self.val_6(&children[0], parse_tree),
            26 => self.val_7(&children[0], parse_tree),
            27 => self.val_8(&children[0], parse_tree),
            28 => self.numeric_0(&children[0], parse_tree),
            29 => self.numeric_1(&children[0], parse_tree),
            30 => self.basic_string(&children[0], &children[1], &children[2], parse_tree),
            31 => self.basic_string_list_0(&children[0], &children[1], parse_tree),
            32 => self.basic_string_list_1(parse_tree),
            33 => self.basic_char_0(&children[0], parse_tree),
            34 => self.basic_char_1(&children[0], parse_tree),
            35 => self.basic_unescaped_0(&children[0], parse_tree),
            36 => self.basic_unescaped_1(&children[0], parse_tree),
            37 => self.escaped(&children[0], &children[1], parse_tree),
            38 => self.escape(&children[0], parse_tree),
            39 => self.escape_seq_char_0(&children[0], parse_tree),
            40 => self.escape_seq_char_1(&children[0], parse_tree),
            41 => self.escape_seq_char_2(&children[0], parse_tree),
            42 => self.escape_seq_char_3(&children[0], parse_tree),
            43 => self.escape_seq_char_4(&children[0], parse_tree),
            44 => self.escape_seq_char_5(&children[0], parse_tree),
            45 => self.escape_seq_char_6(&children[0], parse_tree),
            46 => self.escape_seq_char_7(&children[0], parse_tree),
            47 => self.escape_seq_char_8(&children[0], parse_tree),
            48 => self.escape_seq_char_9(&children[0], parse_tree),
            49 => self.escape_seq_char_10(&children[0], parse_tree),
            50 => self.unicode4(&children[0], parse_tree),
            51 => self.unicode8(&children[0], parse_tree),
            52 => self.m_l_basic_string(&children[0], &children[1], &children[2], parse_tree),
            53 => self.m_l_basic_body(&children[0], &children[1], parse_tree),
            54 => self.m_l_basic_body_list_0(&children[0], &children[1], &children[2], parse_tree),
            55 => self.m_l_basic_body_list_1(parse_tree),
            56 => self.m_l_b_content_list_0(&children[0], &children[1], parse_tree),
            57 => self.m_l_b_content_list_1(parse_tree),
            58 => self.m_l_b_content_list1(&children[0], &children[1], parse_tree),
            59 => self.m_l_b_content_0(&children[0], parse_tree),
            60 => self.m_l_b_content_1(&children[0], parse_tree),
            61 => self.m_l_b_content_2(&children[0], parse_tree),
            62 => self.m_l_b_char_0(&children[0], parse_tree),
            63 => self.m_l_b_char_1(&children[0], parse_tree),
            64 => self.m_l_b_unescaped_0(&children[0], parse_tree),
            65 => self.m_l_b_unescaped_1(&children[0], parse_tree),
            66 => self.m_l_b_escaped_n_l(&children[0], parse_tree),
            67 => self.literal_string(&children[0], &children[1], &children[2], parse_tree),
            68 => self.literal_string_list_0(&children[0], &children[1], parse_tree),
            69 => self.literal_string_list_1(parse_tree),
            70 => self.literal_char_0(&children[0], parse_tree),
            71 => self.literal_char_1(&children[0], parse_tree),
            72 => self.literal_char_no_apostrophe(&children[0], parse_tree),
            73 => self.m_l_literal_string(&children[0], &children[1], parse_tree),
            74 => self.m_l_literal_body(&children[0], &children[1], &children[2], parse_tree),
            75 => {
                self.m_l_literal_body_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            76 => self.m_l_literal_body_list_1(parse_tree),
            77 => self.m_l_l_content_list_0(&children[0], &children[1], parse_tree),
            78 => self.m_l_l_content_list_1(parse_tree),
            79 => self.m_l_l_content_list1(&children[0], &children[1], parse_tree),
            80 => self.m_l_l_content_0(&children[0], parse_tree),
            81 => self.m_l_l_content_1(&children[0], parse_tree),
            82 => self.integer_0(&children[0], parse_tree),
            83 => self.integer_1(&children[0], parse_tree),
            84 => self.integer_2(&children[0], parse_tree),
            85 => self.integer_3(&children[0], parse_tree),
            86 => self.hex_prefix(&children[0], parse_tree),
            87 => self.oct_prefix(&children[0], parse_tree),
            88 => self.bin_prefix(&children[0], parse_tree),
            89 => self.dec_int(&children[0], &children[1], parse_tree),
            90 => self.dec_int_opt_0(&children[0], parse_tree),
            91 => self.dec_int_opt_group_0(&children[0], parse_tree),
            92 => self.dec_int_opt_group_1(&children[0], parse_tree),
            93 => self.dec_int_opt_1(parse_tree),
            94 => self.hex_int(&children[0], &children[1], parse_tree),
            95 => self.hex_int_content(&children[0], parse_tree),
            96 => self.oct_int(&children[0], &children[1], parse_tree),
            97 => self.oct_int_content(&children[0], parse_tree),
            98 => self.bin_int(&children[0], &children[1], parse_tree),
            99 => self.bin_int_content(&children[0], parse_tree),
            100 => self.boolean_0(&children[0], parse_tree),
            101 => self.boolean_1(&children[0], parse_tree),
            102 => self.float_0(&children[0], parse_tree),
            103 => self.float_1(&children[0], parse_tree),
            104 => self.normal_float(&children[0], parse_tree),
            105 => self.special_float(&children[0], parse_tree),
            106 => self.date_time_0(&children[0], parse_tree),
            107 => self.date_time_1(&children[0], parse_tree),
            108 => self.date_time_2(&children[0], parse_tree),
            109 => self.date_time_3(&children[0], parse_tree),
            110 => self.offset_date_time(&children[0], parse_tree),
            111 => self.local_date_time(&children[0], parse_tree),
            112 => self.local_date(&children[0], parse_tree),
            113 => self.local_time(&children[0], parse_tree),
            114 => self.array(&children[0], &children[1], &children[2], parse_tree),
            115 => self.array_opt_0(&children[0], parse_tree),
            116 => self.array_opt_1(parse_tree),
            117 => self.array_values(&children[0], &children[1], parse_tree),
            118 => self.array_values_suffix0_0(&children[0], &children[1], parse_tree),
            119 => self.array_values_suffix0_1(parse_tree),
            120 => self.array_values_suffix_0(&children[0], parse_tree),
            121 => self.array_values_suffix_1(parse_tree),
            122 => self.array_sep(&children[0], parse_tree),
            123 => self.table_0(&children[0], parse_tree),
            124 => self.table_1(&children[0], parse_tree),
            125 => self.std_table(&children[0], &children[1], &children[2], parse_tree),
            126 => self.array_table_open(&children[0], parse_tree),
            127 => self.array_table_close(&children[0], parse_tree),
            128 => self.array_open(&children[0], parse_tree),
            129 => self.array_close(&children[0], parse_tree),
            130 => self.std_table_open(&children[0], parse_tree),
            131 => self.std_table_close(&children[0], parse_tree),
            132 => self.inline_table(&children[0], &children[1], &children[2], parse_tree),
            133 => self.inline_table_opt_0(&children[0], parse_tree),
            134 => self.inline_table_opt_1(parse_tree),
            135 => self.inline_table_open(&children[0], parse_tree),
            136 => self.inline_table_close(&children[0], parse_tree),
            137 => self.inline_table_sep(&children[0], parse_tree),
            138 => self.inline_table_key_vals(&children[0], &children[1], parse_tree),
            139 => self.inline_table_key_vals_opt_0(&children[0], &children[1], parse_tree),
            140 => self.inline_table_key_vals_opt_1(parse_tree),
            141 => self.array_table(&children[0], &children[1], &children[2], parse_tree),
            142 => self.unsigned_dec_int(&children[0], parse_tree),
            143 => self.unquoted_key(&children[0], parse_tree),
            144 => self.dot_sep(&children[0], parse_tree),
            145 => self.m_l_basic_string_start(&children[0], parse_tree),
            146 => self.m_l_basic_string_end(&children[0], parse_tree),
            147 => self.m_l_b_quotes(&children[0], parse_tree),
            148 => self.quotation_mark(&children[0], parse_tree),
            149 => self.m_l_literal_string_start(&children[0], parse_tree),
            150 => self.m_l_literal_string_end(&children[0], parse_tree),
            151 => self.m_l_l_quotes(&children[0], parse_tree),
            152 => self.apostrophe(&children[0], parse_tree),
            153 => self.ascii_no_escape(&children[0], parse_tree),
            154 => self.minus(&children[0], parse_tree),
            155 => self.plus(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
