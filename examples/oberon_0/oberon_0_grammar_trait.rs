// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use crate::oberon_0_grammar::Oberon0Grammar;
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
///
/// The `Oberon0GrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait Oberon0GrammarTrait {
    /// Semantic action for production 0:
    ///
    /// `Selector: SelectorList;`
    ///
    fn selector(&mut self, _selector_list: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `SelectorList: "\." Ident SelectorList;`
    ///
    fn selector_list_0(
        &mut self,
        _dot: &ParseTreeType,
        _ident: &ParseTreeType,
        _selector_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `SelectorList: "\[" Expression "]" SelectorList;`
    ///
    fn selector_list_1(
        &mut self,
        _l_bracket: &ParseTreeType,
        _expression: &ParseTreeType,
        _r_bracket: &ParseTreeType,
        _selector_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `SelectorList: ;`
    ///
    fn selector_list_2(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `Factor: Ident Selector;`
    ///
    fn factor_0(&mut self, _ident: &ParseTreeType, _selector: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Factor: Integer;`
    ///
    fn factor_1(&mut self, _integer: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `Factor: "\(" Expression "\)";`
    ///
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeType,
        _expression: &ParseTreeType,
        _r_paren: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Factor: "~" Factor;`
    ///
    fn factor_3(&mut self, _tilde: &ParseTreeType, _factor: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Factor: UnaryOp Factor;`
    ///
    fn factor_4(&mut self, _unary_op: &ParseTreeType, _factor: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Term: Factor MulExpression;`
    ///
    fn term(&mut self, _factor: &ParseTreeType, _mul_expression: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `MulExpression: MulOperator Factor MulExpression;`
    ///
    fn mul_expression_0(
        &mut self,
        _mul_operator: &ParseTreeType,
        _factor: &ParseTreeType,
        _mul_expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `MulExpression: ;`
    ///
    fn mul_expression_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `SimpleExpression: Term AddExpression;`
    ///
    fn simple_expression(
        &mut self,
        _term: &ParseTreeType,
        _add_expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `AddExpression: AddOperator Term AddExpression;`
    ///
    fn add_expression_0(
        &mut self,
        _add_operator: &ParseTreeType,
        _term: &ParseTreeType,
        _add_expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `AddExpression: ;`
    ///
    fn add_expression_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `AssignOp: ":=";`
    ///
    fn assign_op_0(&mut self, _colon_equ: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `RelationOp: AssignOp;`
    ///
    fn relation_op_0(&mut self, _assign_op: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `RelationOp: RelationalOps;`
    ///
    fn relation_op_1(&mut self, _relational_ops: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `RelationalOps: ">=|<=|\#|<|>";`
    ///
    fn relational_ops(&mut self, _relational_ops: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `AssignOp: "=";`
    ///
    fn assign_op_1(&mut self, _equ: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `Expression: SimpleExpression ExpressionSuffix;`
    ///
    fn expression(
        &mut self,
        _simple_expression: &ParseTreeType,
        _expression_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `ExpressionSuffix: RelationOp SimpleExpression;`
    ///
    fn expression_suffix_0(
        &mut self,
        _relation_op: &ParseTreeType,
        _simple_expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `ExpressionSuffix: ;`
    ///
    fn expression_suffix_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `Assignment: Ident Selector AssignOp Expression;`
    ///
    fn assignment(
        &mut self,
        _ident: &ParseTreeType,
        _selector: &ParseTreeType,
        _assign_op: &ParseTreeType,
        _expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `ActualParameters: "\(" ActualParametersSuffix;`
    ///
    fn actual_parameters(
        &mut self,
        _l_paren: &ParseTreeType,
        _actual_parameters_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ActualParametersSuffix: "\)";`
    ///
    fn actual_parameters_suffix_0(&mut self, _r_paren: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `ActualParametersSuffix: Expression ExpressionListRest "\)";`
    ///
    fn actual_parameters_suffix_1(
        &mut self,
        _expression: &ParseTreeType,
        _expression_list_rest: &ParseTreeType,
        _r_paren: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ExpressionListRest: "," Expression ExpressionListRest;`
    ///
    fn expression_list_rest_0(
        &mut self,
        _comma: &ParseTreeType,
        _expression: &ParseTreeType,
        _expression_list_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `ExpressionListRest: ;`
    ///
    fn expression_list_rest_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ProcedureCall: Ident ProcedureCallSuffix;`
    ///
    fn procedure_call(
        &mut self,
        _ident: &ParseTreeType,
        _procedure_call_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `ProcedureCallSuffix: ActualParameters;`
    ///
    fn procedure_call_suffix_0(&mut self, _actual_parameters: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `ProcedureCallSuffix: ;`
    ///
    fn procedure_call_suffix_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `IfStatement: IfPrefix IfStatementSuffix;`
    ///
    fn if_statement(
        &mut self,
        _if_prefix: &ParseTreeType,
        _if_statement_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `IfStatementSuffix: "ELSE" StatementSequence "END";`
    ///
    fn if_statement_suffix_0(
        &mut self,
        _e_l_s_e: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _e_n_d: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `IfStatementSuffix: "END";`
    ///
    fn if_statement_suffix_1(&mut self, _e_n_d: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `IfPrefix: "IF" Expression "THEN" StatementSequence ElseIfList;`
    ///
    fn if_prefix(
        &mut self,
        _i_f: &ParseTreeType,
        _expression: &ParseTreeType,
        _t_h_e_n: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _else_if_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `ElseIfList: "ELSIF" Expression "THEN" StatementSequence ElseIfList;`
    ///
    fn else_if_list_0(
        &mut self,
        _e_l_s_i_f: &ParseTreeType,
        _expression: &ParseTreeType,
        _t_h_e_n: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _else_if_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `ElseIfList: ;`
    ///
    fn else_if_list_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `WhileStatement: "WHILE" Expression "DO" StatementSequence "END";`
    ///
    fn while_statement(
        &mut self,
        _w_h_i_l_e: &ParseTreeType,
        _expression: &ParseTreeType,
        _d_o: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _e_n_d: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `RepeatStatement: "REPEAT" StatementSequence "UNTIL" Expression;`
    ///
    fn repeat_statement(
        &mut self,
        _r_e_p_e_a_t: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _u_n_t_i_l: &ParseTreeType,
        _expression: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `Statement: Assignment;`
    ///
    fn statement_0(&mut self, _assignment: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `Statement: ProcedureCall;`
    ///
    fn statement_1(&mut self, _procedure_call: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `Statement: IfStatement;`
    ///
    fn statement_2(&mut self, _if_statement: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `Statement: WhileStatement;`
    ///
    fn statement_3(&mut self, _while_statement: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `Statement: RepeatStatement;`
    ///
    fn statement_4(&mut self, _repeat_statement: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `Statement: ;`
    ///
    fn statement_5(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `StatementSequence: Statement StatementSequenceRest;`
    ///
    fn statement_sequence(
        &mut self,
        _statement: &ParseTreeType,
        _statement_sequence_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `StatementSequenceRest: ";" Statement StatementSequenceRest;`
    ///
    fn statement_sequence_rest_0(
        &mut self,
        _semicolon: &ParseTreeType,
        _statement: &ParseTreeType,
        _statement_sequence_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `StatementSequenceRest: ;`
    ///
    fn statement_sequence_rest_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `IdentList: Ident IdentListRest;`
    ///
    fn ident_list(
        &mut self,
        _ident: &ParseTreeType,
        _ident_list_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `IdentListRest: "," Ident IdentListRest;`
    ///
    fn ident_list_rest_0(
        &mut self,
        _comma: &ParseTreeType,
        _ident: &ParseTreeType,
        _ident_list_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `IdentListRest: ;`
    ///
    fn ident_list_rest_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `ArrayType: "ARRAY" Expression "OF" Type;`
    ///
    fn array_type(
        &mut self,
        _a_r_r_a_y: &ParseTreeType,
        _expression: &ParseTreeType,
        _o_f: &ParseTreeType,
        _type: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `FieldList: IdentList ":" Type;`
    ///
    fn field_list_0(
        &mut self,
        _ident_list: &ParseTreeType,
        _colon: &ParseTreeType,
        _type: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `FieldList: ;`
    ///
    fn field_list_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `RecordType: "RECORD" FieldList FieldListRest "END";`
    ///
    fn record_type(
        &mut self,
        _r_e_c_o_r_d: &ParseTreeType,
        _field_list: &ParseTreeType,
        _field_list_rest: &ParseTreeType,
        _e_n_d: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `FieldListRest: ";" FieldList FieldListRest;`
    ///
    fn field_list_rest_0(
        &mut self,
        _semicolon: &ParseTreeType,
        _field_list: &ParseTreeType,
        _field_list_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `FieldListRest: ;`
    ///
    fn field_list_rest_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Type: Ident;`
    ///
    fn type_0(&mut self, _ident: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `Type: ArrayType;`
    ///
    fn type_1(&mut self, _array_type: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `Type: RecordType;`
    ///
    fn type_2(&mut self, _record_type: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `FPSection: "VAR" IdentList ":" Type;`
    ///
    fn f_p_section_0(
        &mut self,
        _v_a_r: &ParseTreeType,
        _ident_list: &ParseTreeType,
        _colon: &ParseTreeType,
        _type: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `FPSection: IdentList ":" Type;`
    ///
    fn f_p_section_1(
        &mut self,
        _ident_list: &ParseTreeType,
        _colon: &ParseTreeType,
        _type: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `FormalParameters: "\(" FormalParametersSuffix;`
    ///
    fn formal_parameters(
        &mut self,
        _l_paren: &ParseTreeType,
        _formal_parameters_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `FormalParametersSuffix: "\)";`
    ///
    fn formal_parameters_suffix_0(&mut self, _r_paren: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `FormalParametersSuffix: FPSection FPSectionRest "\)";`
    ///
    fn formal_parameters_suffix_1(
        &mut self,
        _f_p_section: &ParseTreeType,
        _f_p_section_rest: &ParseTreeType,
        _r_paren: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `FPSectionRest: ";" FPSection FPSectionRest;`
    ///
    fn f_p_section_rest_0(
        &mut self,
        _semicolon: &ParseTreeType,
        _f_p_section: &ParseTreeType,
        _f_p_section_rest: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `FPSectionRest: ;`
    ///
    fn f_p_section_rest_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `ProcedureHeading: "PROCEDURE" Ident ProcedureHeadingSuffix;`
    ///
    fn procedure_heading(
        &mut self,
        _p_r_o_c_e_d_u_r_e: &ParseTreeType,
        _ident: &ParseTreeType,
        _procedure_heading_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `ProcedureHeadingSuffix: FormalParameters;`
    ///
    fn procedure_heading_suffix_0(&mut self, _formal_parameters: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `ProcedureHeadingSuffix: ;`
    ///
    fn procedure_heading_suffix_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `ProcedureBody: Declarations ProcedureBodySuffix0;`
    ///
    fn procedure_body(
        &mut self,
        _declarations: &ParseTreeType,
        _procedure_body_suffix0: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `ProcedureBodySuffix0: "BEGIN" StatementSequence ProcedureBodySuffix;`
    ///
    fn procedure_body_suffix0_0(
        &mut self,
        _b_e_g_i_n: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _procedure_body_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `ProcedureBodySuffix0: "RETURN" Expression "END" Ident;`
    ///
    fn procedure_body_suffix0_1(
        &mut self,
        _r_e_t_u_r_n: &ParseTreeType,
        _expression: &ParseTreeType,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `ProcedureBodySuffix0: "END" Ident;`
    ///
    fn procedure_body_suffix0_2(
        &mut self,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `ProcedureBodySuffix: "RETURN" Expression "END" Ident;`
    ///
    fn procedure_body_suffix_0(
        &mut self,
        _r_e_t_u_r_n: &ParseTreeType,
        _expression: &ParseTreeType,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `ProcedureBodySuffix: "END" Ident;`
    ///
    fn procedure_body_suffix_1(
        &mut self,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `ProcedureDeclaration: ProcedureHeading ";" ProcedureBody;`
    ///
    fn procedure_declaration(
        &mut self,
        _procedure_heading: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _procedure_body: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `Declarations: "TYPE" TypeDecls DeclarationsSuffix1;`
    ///
    fn declarations_0(
        &mut self,
        _t_y_p_e: &ParseTreeType,
        _type_decls: &ParseTreeType,
        _declarations_suffix1: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `Declarations: "CONST" ConstDecls DeclarationsSuffix0;`
    ///
    fn declarations_1(
        &mut self,
        _c_o_n_s_t: &ParseTreeType,
        _const_decls: &ParseTreeType,
        _declarations_suffix0: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `DeclarationsSuffix1: "VAR" VarDecls ProcedureDeclarationList;`
    ///
    fn declarations_suffix1_0(
        &mut self,
        _v_a_r: &ParseTreeType,
        _var_decls: &ParseTreeType,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `DeclarationsSuffix1: ProcedureDeclarationList;`
    ///
    fn declarations_suffix1_1(
        &mut self,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `Declarations: "VAR" VarDecls ProcedureDeclarationList;`
    ///
    fn declarations_2(
        &mut self,
        _v_a_r: &ParseTreeType,
        _var_decls: &ParseTreeType,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `Declarations: ProcedureDeclarationList;`
    ///
    fn declarations_3(&mut self, _procedure_declaration_list: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `DeclarationsSuffix0: "TYPE" TypeDecls DeclarationsSuffix;`
    ///
    fn declarations_suffix0_0(
        &mut self,
        _t_y_p_e: &ParseTreeType,
        _type_decls: &ParseTreeType,
        _declarations_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `DeclarationsSuffix0: "VAR" VarDecls ProcedureDeclarationList;`
    ///
    fn declarations_suffix0_1(
        &mut self,
        _v_a_r: &ParseTreeType,
        _var_decls: &ParseTreeType,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `DeclarationsSuffix0: ProcedureDeclarationList;`
    ///
    fn declarations_suffix0_2(
        &mut self,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `DeclarationsSuffix: "VAR" VarDecls ProcedureDeclarationList;`
    ///
    fn declarations_suffix_0(
        &mut self,
        _v_a_r: &ParseTreeType,
        _var_decls: &ParseTreeType,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `DeclarationsSuffix: ProcedureDeclarationList;`
    ///
    fn declarations_suffix_1(&mut self, _procedure_declaration_list: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `ProcedureDeclarationList: ProcedureDeclaration ";" ProcedureDeclarationList;`
    ///
    fn procedure_declaration_list_0(
        &mut self,
        _procedure_declaration: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _procedure_declaration_list: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `ProcedureDeclarationList: ;`
    ///
    fn procedure_declaration_list_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `ConstDecls: Ident AssignOp Expression ";" ConstDecls;`
    ///
    fn const_decls_0(
        &mut self,
        _ident: &ParseTreeType,
        _assign_op: &ParseTreeType,
        _expression: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _const_decls: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `ConstDecls: ;`
    ///
    fn const_decls_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `TypeDecls: Ident AssignOp Type ";" TypeDecls;`
    ///
    fn type_decls_0(
        &mut self,
        _ident: &ParseTreeType,
        _assign_op: &ParseTreeType,
        _type: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _type_decls: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `TypeDecls: ;`
    ///
    fn type_decls_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `VarDecls: IdentList ":" Type ";" VarDecls;`
    ///
    fn var_decls_0(
        &mut self,
        _ident_list: &ParseTreeType,
        _colon: &ParseTreeType,
        _type: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _var_decls: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `VarDecls: ;`
    ///
    fn var_decls_1(&mut self) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `Module: "MODULE" Ident ";" Declarations ModuleSuffix;`
    ///
    fn module(
        &mut self,
        _m_o_d_u_l_e: &ParseTreeType,
        _ident: &ParseTreeType,
        _semicolon: &ParseTreeType,
        _declarations: &ParseTreeType,
        _module_suffix: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `ModuleSuffix: "BEGIN" StatementSequence "END" Ident "\.";`
    ///
    fn module_suffix_0(
        &mut self,
        _b_e_g_i_n: &ParseTreeType,
        _statement_sequence: &ParseTreeType,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
        _dot: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `ModuleSuffix: "END" Ident "\.";`
    ///
    fn module_suffix_1(
        &mut self,
        _e_n_d: &ParseTreeType,
        _ident: &ParseTreeType,
        _dot: &ParseTreeType,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `MulOperator: "\*|/|DIV|MOD|&";`
    ///
    fn mul_operator(&mut self, _mul_operator: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `AddOperator: "\+|-|OR";`
    ///
    fn add_operator(&mut self, _add_operator: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `UnaryOp: "\+|-";`
    ///
    fn unary_op(&mut self, _unary_op: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `Ident: "[a-zA-Z][a-zA-Z0-9]*";`
    ///
    fn ident(&mut self, _ident: &ParseTreeType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `Integer: "[0-9]+";`
    ///
    fn integer(&mut self, _integer: &ParseTreeType) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait<'_> for Oberon0Grammar {
    ///
    /// This function is implemented automatically for the user's item Oberon0Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType],
    ) -> Result<()> {
        match prod_num {
            0 => self.selector(&children[0]),
            1 => self.selector_list_0(&children[0], &children[1], &children[2]),
            2 => self.selector_list_1(&children[0], &children[1], &children[2], &children[3]),
            3 => self.selector_list_2(),
            4 => self.factor_0(&children[0], &children[1]),
            5 => self.factor_1(&children[0]),
            6 => self.factor_2(&children[0], &children[1], &children[2]),
            7 => self.factor_3(&children[0], &children[1]),
            8 => self.factor_4(&children[0], &children[1]),
            9 => self.term(&children[0], &children[1]),
            10 => self.mul_expression_0(&children[0], &children[1], &children[2]),
            11 => self.mul_expression_1(),
            12 => self.simple_expression(&children[0], &children[1]),
            13 => self.add_expression_0(&children[0], &children[1], &children[2]),
            14 => self.add_expression_1(),
            15 => self.assign_op_0(&children[0]),
            16 => self.relation_op_0(&children[0]),
            17 => self.relation_op_1(&children[0]),
            18 => self.relational_ops(&children[0]),
            19 => self.assign_op_1(&children[0]),
            20 => self.expression(&children[0], &children[1]),
            21 => self.expression_suffix_0(&children[0], &children[1]),
            22 => self.expression_suffix_1(),
            23 => self.assignment(&children[0], &children[1], &children[2], &children[3]),
            24 => self.actual_parameters(&children[0], &children[1]),
            25 => self.actual_parameters_suffix_0(&children[0]),
            26 => self.actual_parameters_suffix_1(&children[0], &children[1], &children[2]),
            27 => self.expression_list_rest_0(&children[0], &children[1], &children[2]),
            28 => self.expression_list_rest_1(),
            29 => self.procedure_call(&children[0], &children[1]),
            30 => self.procedure_call_suffix_0(&children[0]),
            31 => self.procedure_call_suffix_1(),
            32 => self.if_statement(&children[0], &children[1]),
            33 => self.if_statement_suffix_0(&children[0], &children[1], &children[2]),
            34 => self.if_statement_suffix_1(&children[0]),
            35 => self.if_prefix(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            36 => self.else_if_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            37 => self.else_if_list_1(),
            38 => self.while_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            39 => self.repeat_statement(&children[0], &children[1], &children[2], &children[3]),
            40 => self.statement_0(&children[0]),
            41 => self.statement_1(&children[0]),
            42 => self.statement_2(&children[0]),
            43 => self.statement_3(&children[0]),
            44 => self.statement_4(&children[0]),
            45 => self.statement_5(),
            46 => self.statement_sequence(&children[0], &children[1]),
            47 => self.statement_sequence_rest_0(&children[0], &children[1], &children[2]),
            48 => self.statement_sequence_rest_1(),
            49 => self.ident_list(&children[0], &children[1]),
            50 => self.ident_list_rest_0(&children[0], &children[1], &children[2]),
            51 => self.ident_list_rest_1(),
            52 => self.array_type(&children[0], &children[1], &children[2], &children[3]),
            53 => self.field_list_0(&children[0], &children[1], &children[2]),
            54 => self.field_list_1(),
            55 => self.record_type(&children[0], &children[1], &children[2], &children[3]),
            56 => self.field_list_rest_0(&children[0], &children[1], &children[2]),
            57 => self.field_list_rest_1(),
            58 => self.type_0(&children[0]),
            59 => self.type_1(&children[0]),
            60 => self.type_2(&children[0]),
            61 => self.f_p_section_0(&children[0], &children[1], &children[2], &children[3]),
            62 => self.f_p_section_1(&children[0], &children[1], &children[2]),
            63 => self.formal_parameters(&children[0], &children[1]),
            64 => self.formal_parameters_suffix_0(&children[0]),
            65 => self.formal_parameters_suffix_1(&children[0], &children[1], &children[2]),
            66 => self.f_p_section_rest_0(&children[0], &children[1], &children[2]),
            67 => self.f_p_section_rest_1(),
            68 => self.procedure_heading(&children[0], &children[1], &children[2]),
            69 => self.procedure_heading_suffix_0(&children[0]),
            70 => self.procedure_heading_suffix_1(),
            71 => self.procedure_body(&children[0], &children[1]),
            72 => self.procedure_body_suffix0_0(&children[0], &children[1], &children[2]),
            73 => self.procedure_body_suffix0_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            74 => self.procedure_body_suffix0_2(&children[0], &children[1]),
            75 => {
                self.procedure_body_suffix_0(&children[0], &children[1], &children[2], &children[3])
            }
            76 => self.procedure_body_suffix_1(&children[0], &children[1]),
            77 => self.procedure_declaration(&children[0], &children[1], &children[2]),
            78 => self.declarations_0(&children[0], &children[1], &children[2]),
            79 => self.declarations_1(&children[0], &children[1], &children[2]),
            80 => self.declarations_suffix1_0(&children[0], &children[1], &children[2]),
            81 => self.declarations_suffix1_1(&children[0]),
            82 => self.declarations_2(&children[0], &children[1], &children[2]),
            83 => self.declarations_3(&children[0]),
            84 => self.declarations_suffix0_0(&children[0], &children[1], &children[2]),
            85 => self.declarations_suffix0_1(&children[0], &children[1], &children[2]),
            86 => self.declarations_suffix0_2(&children[0]),
            87 => self.declarations_suffix_0(&children[0], &children[1], &children[2]),
            88 => self.declarations_suffix_1(&children[0]),
            89 => self.procedure_declaration_list_0(&children[0], &children[1], &children[2]),
            90 => self.procedure_declaration_list_1(),
            91 => self.const_decls_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            92 => self.const_decls_1(),
            93 => self.type_decls_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            94 => self.type_decls_1(),
            95 => self.var_decls_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            96 => self.var_decls_1(),
            97 => self.module(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            98 => self.module_suffix_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            99 => self.module_suffix_1(&children[0], &children[1], &children[2]),
            100 => self.mul_operator(&children[0]),
            101 => self.add_operator(&children[0]),
            102 => self.unary_op(&children[0]),
            103 => self.ident(&children[0]),
            104 => self.integer(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
    fn on_comment_parsed(&mut self, _token: Token<'_>) {
        // This is currently only supported for auto generate mode.
        // Please, file an issue if need arises.
    }
}
