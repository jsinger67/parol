// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::{
    ParolError, ParseTree, TokenStream,
    parser::{
        LLKParser, LookaheadDFA, ParseType, Production, Trans, parse_tree_type::TreeConstruct,
    },
};
use scnr2::scanner;
use std::path::Path;

use crate::allow_unmatched_grammar::AllowUnmatchedGrammar;
use crate::allow_unmatched_grammar_trait::AllowUnmatchedGrammarAuto;

pub const TERMINAL_NAMES: &[&str; 8] = &[
    /* 0 */ "EndOfInput",
    /* 1 */ "Newline",
    /* 2 */ "Whitespace",
    /* 3 */ "LineComment",
    /* 4 */ "BlockComment",
    /* 5 */ "NUMBER",
    /* 6 */ "PLUS",
    /* 7 */ "Error",
];

scanner! {
    AllowUnmatchedGrammarScanner {
        mode INITIAL {
            token r"\r\n|\r|\n" => 1; // "Newline"
            token r"[\s--\r\n]+" => 2; // "Whitespace"
            token r"[0-9]+" => 5; // "NUMBER"
            token r"\+" => 6; // "PLUS"
        }
    }
}

const MAX_K: usize = 1;

pub const NON_TERMINALS: &[&str; 4] = &[
    /* 0 */ "Expr", /* 1 */ "ExprList", /* 2 */ "NUMBER", /* 3 */ "PLUS",
];

pub const LOOKAHEAD_AUTOMATA: &[LookaheadDFA; 4] = &[
    /* 0 - "Expr" */
    LookaheadDFA {
        prod0: 2,
        transitions: &[],
        k: 0,
    },
    /* 1 - "ExprList" */
    LookaheadDFA {
        prod0: -1,
        transitions: &[Trans(0, 0, 2, 4), Trans(0, 6, 1, 3)],
        k: 1,
    },
    /* 2 - "NUMBER" */
    LookaheadDFA {
        prod0: 0,
        transitions: &[],
        k: 0,
    },
    /* 3 - "PLUS" */
    LookaheadDFA {
        prod0: 1,
        transitions: &[],
        k: 0,
    },
];

pub const PRODUCTIONS: &[Production; 5] = &[
    // 0 - NUMBER: /[0-9]+/;
    Production {
        lhs: 2,
        production: &[ParseType::T(5)],
    },
    // 1 - PLUS: /\+/;
    Production {
        lhs: 3,
        production: &[ParseType::T(6)],
    },
    // 2 - Expr: NUMBER ExprList /* Vec */;
    Production {
        lhs: 0,
        production: &[ParseType::N(1), ParseType::N(2)],
    },
    // 3 - ExprList: PLUS NUMBER ExprList;
    Production {
        lhs: 1,
        production: &[ParseType::N(1), ParseType::N(2), ParseType::N(3)],
    },
    // 4 - ExprList: ;
    Production {
        lhs: 1,
        production: &[],
    },
];

pub fn parse<'t, T>(
    input: &'t str,
    file_name: T,
    user_actions: &mut AllowUnmatchedGrammar<'t>,
) -> Result<ParseTree, ParolError>
where
    T: AsRef<Path>,
{
    use parol_runtime::{
        parser::{parse_tree_type::SynTree, parser_types::SynTreeFlavor},
        syntree::Builder,
    };
    let mut builder = Builder::<SynTree, SynTreeFlavor>::new_with();
    parse_into(input, &mut builder, file_name, user_actions)?;
    Ok(builder.build()?)
}
#[allow(dead_code)]
pub fn parse_into<'t, T: TreeConstruct<'t>>(
    input: &'t str,
    tree_builder: &mut T,
    file_name: impl AsRef<Path>,
    user_actions: &mut AllowUnmatchedGrammar<'t>,
) -> Result<(), ParolError>
where
    ParolError: From<T::Error>,
{
    use allow_unmatched_grammar_scanner::AllowUnmatchedGrammarScanner;
    let mut llk_parser = LLKParser::new(
        0,
        LOOKAHEAD_AUTOMATA,
        PRODUCTIONS,
        TERMINAL_NAMES,
        NON_TERMINALS,
    );
    let scanner = AllowUnmatchedGrammarScanner::new();
    // Initialize wrapper
    let mut user_actions = AllowUnmatchedGrammarAuto::new(user_actions);
    llk_parser.parse_into(
        tree_builder,
        TokenStream::new(
            input,
            file_name,
            scanner.scanner_impl.clone(),
            &AllowUnmatchedGrammarScanner::match_function,
            MAX_K,
        )
        .unwrap(),
        &mut user_actions,
    )
}
