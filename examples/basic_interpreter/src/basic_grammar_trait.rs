// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Basic'
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LineNumber'
    fn line_number(&mut self, _arg: &LineNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Remark'
    fn remark(&mut self, _arg: &Remark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GotoStatement'
    fn goto_statement(&mut self, _arg: &GotoStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfBody'
    fn if_body(&mut self, _arg: &IfBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PrintStatement'
    fn print_statement(&mut self, _arg: &PrintStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndStatement'
    fn end_statement(&mut self, _arg: &EndStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndOfLine'
    fn end_of_line(&mut self, _arg: &EndOfLine) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Literal'
    fn literal(&mut self, _arg: &Literal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float1'
    fn float1(&mut self, _arg: &Float1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float2'
    fn float2(&mut self, _arg: &Float2) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Then'
    fn then(&mut self, _arg: &Then) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Goto'
    fn goto(&mut self, _arg: &Goto) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Let'
    fn r#let(&mut self, _arg: &Let) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Print'
    fn print(&mut self, _arg: &Print) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignOp'
    fn assign_op(&mut self, _arg: &AssignOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrOp'
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndOp'
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNotOp'
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalOp'
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comment'
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Variable'
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOr'
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAnd'
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNot'
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relational'
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Summation'
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Multiplication'
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 11
///
/// Statement: Remark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementRemark<'t> {
    pub remark: Box<Remark<'t>>,
}

///
/// Type derived for production 12
///
/// Statement: GotoStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementGotoStatement {
    pub goto_statement: Box<GotoStatement>,
}

///
/// Type derived for production 13
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfStatement<'t> {
    pub if_statement: Box<IfStatement<'t>>,
}

///
/// Type derived for production 14
///
/// Statement: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementAssignment<'t> {
    pub assignment: Box<Assignment<'t>>,
}

///
/// Type derived for production 15
///
/// Statement: PrintStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementPrintStatement<'t> {
    pub print_statement: Box<PrintStatement<'t>>,
}

///
/// Type derived for production 16
///
/// Statement: EndStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementEndStatement {
    pub end_statement: Box<EndStatement>,
}

///
/// Type derived for production 25
///
/// IfBody: Then Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfBodyThenStatement<'t> {
    pub then: Box<Then>,
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for production 26
///
/// IfBody: Goto LineNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfBodyGotoLineNumber {
    pub goto: Box<Goto>,
    pub line_number: Box<LineNumber>,
}

///
/// Type derived for production 33
///
/// Number: Float;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberFloat {
    pub float: Box<Float>,
}

///
/// Type derived for production 34
///
/// Number: Integer;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberInteger {
    pub integer: Box<Integer>,
}

///
/// Type derived for production 35
///
/// Float: Float1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatFloat1 {
    pub float1: Box<Float1>,
}

///
/// Type derived for production 36
///
/// Float: Float2;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatFloat2 {
    pub float2: Box<Float2>,
}

///
/// Type derived for production 73
///
/// SummationListGroup: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupPlus<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 74
///
/// SummationListGroup: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupMinus<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 79
///
/// Factor: Literal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLiteral {
    pub literal: Box<Literal>,
}

///
/// Type derived for production 80
///
/// Factor: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorVariable<'t> {
    pub variable: Box<Variable<'t>>,
}

///
/// Type derived for production 81
///
/// Factor: Minus Factor;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorMinusFactor<'t> {
    pub minus: Box<Minus<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 82
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenExpressionRParen<'t> {
    pub l_paren: Box<LParen<'t>>,
    pub expression: Box<Expression<'t>>,
    pub r_paren: Box<RParen<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignOp {}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assignment<'t> {
    pub assignment_opt: Option<Box<AssignmentOpt>>,
    pub variable: Box<Variable<'t>>,
    pub assign_op: Box<AssignOp>,
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal AssignmentOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOpt {
    pub r#let: Box<Let>,
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Basic<'t> {
    pub basic_opt: Option<Box<BasicOpt>>,
    pub line: Box<Line<'t>>,
    pub basic_list: Vec<BasicList<'t>>,
    pub basic_opt0: Option<Box<BasicOpt0>>,
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicList<'t> {
    pub end_of_line: Box<EndOfLine>,
    pub line: Box<Line<'t>>,
}

///
/// Type derived for non-terminal BasicOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicOpt {
    pub end_of_line: Box<EndOfLine>,
}

///
/// Type derived for non-terminal BasicOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicOpt0 {
    pub end_of_line: Box<EndOfLine>,
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comment<'t> {
    pub comment: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct End {}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EndOfLine {}

///
/// Type derived for non-terminal EndStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EndStatement {
    pub end: Box<End>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression<'t> {
    pub logical_or: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Literal(FactorLiteral),
    Variable(FactorVariable<'t>),
    MinusFactor(FactorMinusFactor<'t>),
    LParenExpressionRParen(FactorLParenExpressionRParen<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float {
    Float1(FloatFloat1),
    Float2(FloatFloat2),
}

///
/// Type derived for non-terminal Float1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Float1 {
    pub float1: crate::basic_grammar::BasicNumber, /* (?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)? */
}

///
/// Type derived for non-terminal Float2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Float2 {
    pub float2: crate::basic_grammar::BasicNumber, /* (?:[0-9] *)+E *[-+]? *(?:[0-9] *)+ */
}

///
/// Type derived for non-terminal Goto
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Goto {}

///
/// Type derived for non-terminal GotoStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GotoStatement {
    pub goto: Box<Goto>,
    pub line_number: Box<LineNumber>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct If {}

///
/// Type derived for non-terminal IfBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfBody<'t> {
    ThenStatement(IfBodyThenStatement<'t>),
    GotoLineNumber(IfBodyGotoLineNumber),
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatement<'t> {
    pub r#if: Box<If>,
    pub expression: Box<Expression<'t>>,
    pub if_body: Box<IfBody<'t>>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer {
    pub integer: crate::basic_grammar::BasicNumber, /* (?:[0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Let {}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Line<'t> {
    pub line_number: Box<LineNumber>,
    pub statement: Box<Statement<'t>>,
    pub line_list: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineList<'t> {
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineNumber {
    pub line_number: crate::basic_grammar::BasicLineNumber, /* [0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+ */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Literal {
    pub number: Box<Number>,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAnd<'t> {
    pub logical_not: Box<LogicalNot<'t>>,
    pub logical_and_list: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndList<'t> {
    pub logical_and_op: Box<LogicalAndOp<'t>>,
    pub logical_not: Box<LogicalNot<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndOp<'t> {
    pub logical_and_op: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNot<'t> {
    pub logical_not_opt: Option<Box<LogicalNotOpt<'t>>>,
    pub relational: Box<Relational<'t>>,
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNotOp<'t> {
    pub logical_not_op: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalNotOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNotOpt<'t> {
    pub logical_not_op: Box<LogicalNotOp<'t>>,
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOr<'t> {
    pub logical_and: Box<LogicalAnd<'t>>,
    pub logical_or_list: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrList<'t> {
    pub logical_or_op: Box<LogicalOrOp<'t>>,
    pub logical_and: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrOp<'t> {
    pub logical_or_op: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOp<'t> {
    pub mul_op: Token<'t>, /* \*|\u{2F} */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Multiplication<'t> {
    pub factor: Box<Factor<'t>>,
    pub multiplication_list: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationList<'t> {
    pub mul_op: Box<MulOp<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    Float(NumberFloat),
    Integer(NumberInteger),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Print
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Print {}

///
/// Type derived for non-terminal PrintStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrintStatement<'t> {
    pub print: Box<Print>,
    pub expression: Box<Expression<'t>>,
    pub print_statement_list: Vec<PrintStatementList<'t>>,
}

///
/// Type derived for non-terminal PrintStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrintStatementList<'t> {
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Relational<'t> {
    pub summation: Box<Summation<'t>>,
    pub relational_list: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalList<'t> {
    pub relational_op: Box<RelationalOp<'t>>,
    pub summation: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOp<'t> {
    pub relational_op: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|>|= */
}

///
/// Type derived for non-terminal Remark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Remark<'t> {
    pub remark_opt: Option<Box<RemarkOpt<'t>>>,
}

///
/// Type derived for non-terminal RemarkOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RemarkOpt<'t> {
    pub comment: Box<Comment<'t>>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Remark(StatementRemark<'t>),
    GotoStatement(StatementGotoStatement),
    IfStatement(StatementIfStatement<'t>),
    Assignment(StatementAssignment<'t>),
    PrintStatement(StatementPrintStatement<'t>),
    EndStatement(StatementEndStatement),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Summation<'t> {
    pub multiplication: Box<Multiplication<'t>>,
    pub summation_list: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationList<'t> {
    pub summation_list_group: Box<SummationListGroup<'t>>,
    pub multiplication: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    Plus(SummationListGroupPlus<'t>),
    Minus(SummationListGroupMinus<'t>),
}

///
/// Type derived for non-terminal Then
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Then {}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Variable<'t> {
    pub variable: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOp(AssignOp),
    Assignment(Assignment<'t>),
    AssignmentOpt(Option<Box<AssignmentOpt>>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicOpt(Option<Box<BasicOpt>>),
    BasicOpt0(Option<Box<BasicOpt0>>),
    Comment(Comment<'t>),
    End(End),
    EndOfLine(EndOfLine),
    EndStatement(EndStatement),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float),
    Float1(Float1),
    Float2(Float2),
    Goto(Goto),
    GotoStatement(GotoStatement),
    If(If),
    IfBody(IfBody<'t>),
    IfStatement(IfStatement<'t>),
    Integer(Integer),
    LParen(LParen<'t>),
    Let(Let),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber),
    Literal(Literal),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalNotOpt(Option<Box<LogicalNotOpt<'t>>>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number),
    Plus(Plus<'t>),
    Print(Print),
    PrintStatement(PrintStatement<'t>),
    PrintStatementList(Vec<PrintStatementList<'t>>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalOp(RelationalOp<'t>),
    Remark(Remark<'t>),
    RemarkOpt(Option<Box<RemarkOpt<'t>>>),
    Statement(Statement<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Then(Then),
    Variable(Variable<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Basic: BasicOpt /* Option */ Line BasicList /* Vec */ BasicOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn basic(
        &mut self,
        _basic_opt: &ParseTreeStackEntry<'t>,
        _line: &ParseTreeStackEntry<'t>,
        _basic_list: &ParseTreeStackEntry<'t>,
        _basic_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_opt0 = pop_item!(self, basic_opt0, BasicOpt0, context);
        let basic_list = pop_and_reverse_item!(self, basic_list, BasicList, context);
        let line = pop_item!(self, line, Line, context);
        let basic_opt = pop_item!(self, basic_opt, BasicOpt, context);
        let basic_built = BasicBuilder::default()
            .basic_opt(basic_opt)
            .line(Box::new(line))
            .basic_list(basic_list)
            .basic_opt0(basic_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.basic(&basic_built)?;
        self.push(ASTType::Basic(basic_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// BasicList /* Vec<T>::Push */: EndOfLine Line BasicList;
    ///
    #[parol_runtime::function_name::named]
    fn basic_list_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _line: &ParseTreeStackEntry<'t>,
        _basic_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list = pop_item!(self, basic_list, BasicList, context);
        let line = pop_item!(self, line, Line, context);
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_list_0_built = BasicListBuilder::default()
            .line(Box::new(line))
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        basic_list.push(basic_list_0_built);
        self.push(ASTType::BasicList(basic_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasicList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn basic_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_list_1_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasicOpt0 /* Option<T>::Some */: EndOfLine;
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt0_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_opt0_0_built = BasicOpt0Builder::default()
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::BasicOpt0(Some(Box::new(basic_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasicOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BasicOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// BasicOpt /* Option<T>::Some */: EndOfLine;
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt_0(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_opt_0_built = BasicOptBuilder::default()
            .end_of_line(Box::new(end_of_line))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::BasicOpt(Some(Box::new(basic_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BasicOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BasicOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Line: LineNumber Statement LineList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn line(
        &mut self,
        _line_number: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _line_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list = pop_and_reverse_item!(self, line_list, LineList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let line_built = LineBuilder::default()
            .line_number(Box::new(line_number))
            .statement(Box::new(statement))
            .line_list(line_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_built)?;
        self.push(ASTType::Line(line_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// LineList /* Vec<T>::Push */: <INITIAL, Expr>':'^ /* Clipped */ Statement LineList;
    ///
    #[parol_runtime::function_name::named]
    fn line_list_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _line_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut line_list = pop_item!(self, line_list, LineList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let line_list_0_built = LineListBuilder::default()
            .statement(Box::new(statement))
            // Ignore clipped member 'colon'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        line_list.push(line_list_0_built);
        self.push(ASTType::LineList(line_list), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// LineList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn line_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list_1_built = Vec::new();
        self.push(ASTType::LineList(line_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// LineNumber: /[0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+/ : BasicLineNumber;
    ///
    #[parol_runtime::function_name::named]
    fn line_number(
        &mut self,
        line_number: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = line_number
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let line_number_built = LineNumberBuilder::default()
            .line_number(line_number)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_number(&line_number_built)?;
        self.push(ASTType::LineNumber(line_number_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Statement: Remark;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(
        &mut self,
        _remark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark = pop_item!(self, remark, Remark, context);
        let statement_0_built = StatementRemarkBuilder::default()
            .remark(Box::new(remark))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Remark(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Statement: GotoStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(
        &mut self,
        _goto_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto_statement = pop_item!(self, goto_statement, GotoStatement, context);
        let statement_1_built = StatementGotoStatementBuilder::default()
            .goto_statement(Box::new(goto_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::GotoStatement(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_2(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_2_built = StatementIfStatementBuilder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_2_built = Statement::IfStatement(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Statement: Assignment;
    ///
    #[parol_runtime::function_name::named]
    fn statement_3(
        &mut self,
        _assignment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let statement_3_built = StatementAssignmentBuilder::default()
            .assignment(Box::new(assignment))
            .build()
            .into_diagnostic()?;
        let statement_3_built = Statement::Assignment(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Statement: PrintStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_4(
        &mut self,
        _print_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement = pop_item!(self, print_statement, PrintStatement, context);
        let statement_4_built = StatementPrintStatementBuilder::default()
            .print_statement(Box::new(print_statement))
            .build()
            .into_diagnostic()?;
        let statement_4_built = Statement::PrintStatement(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Statement: EndStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_5(
        &mut self,
        _end_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_statement = pop_item!(self, end_statement, EndStatement, context);
        let statement_5_built = StatementEndStatementBuilder::default()
            .end_statement(Box::new(end_statement))
            .build()
            .into_diagnostic()?;
        let statement_5_built = Statement::EndStatement(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Remark: 'REM'^ /* Clipped */ %push(Cmnt) RemarkOpt /* Option */ %pop();
    ///
    #[parol_runtime::function_name::named]
    fn remark(
        &mut self,
        _r_e_m: &ParseTreeStackEntry<'t>,
        _remark_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark_opt = pop_item!(self, remark_opt, RemarkOpt, context);
        let remark_built = RemarkBuilder::default()
            // Ignore clipped member 'r_e_m'
            .remark_opt(remark_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.remark(&remark_built)?;
        self.push(ASTType::Remark(remark_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// RemarkOpt /* Option<T>::Some */: Comment;
    ///
    #[parol_runtime::function_name::named]
    fn remark_opt_0(
        &mut self,
        _comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = pop_item!(self, comment, Comment, context);
        let remark_opt_0_built = RemarkOptBuilder::default()
            .comment(Box::new(comment))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::RemarkOpt(Some(Box::new(remark_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// RemarkOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn remark_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RemarkOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// GotoStatement: Goto LineNumber;
    ///
    #[parol_runtime::function_name::named]
    fn goto_statement(
        &mut self,
        _goto: &ParseTreeStackEntry<'t>,
        _line_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let goto = pop_item!(self, goto, Goto, context);
        let goto_statement_built = GotoStatementBuilder::default()
            .goto(Box::new(goto))
            .line_number(Box::new(line_number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto_statement(&goto_statement_built)?;
        self.push(ASTType::GotoStatement(goto_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// IfStatement: If %push(Expr) Expression %pop() IfBody;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _if_body: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_body = pop_item!(self, if_body, IfBody, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .if_body(Box::new(if_body))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Assignment: AssignmentOpt /* Option */ Variable AssignOp %push(Expr) Expression %pop();
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        _assignment_opt: &ParseTreeStackEntry<'t>,
        _variable: &ParseTreeStackEntry<'t>,
        _assign_op: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assign_op = pop_item!(self, assign_op, AssignOp, context);
        let variable = pop_item!(self, variable, Variable, context);
        let assignment_opt = pop_item!(self, assignment_opt, AssignmentOpt, context);
        let assignment_built = AssignmentBuilder::default()
            .assignment_opt(assignment_opt)
            .variable(Box::new(variable))
            .assign_op(Box::new(assign_op))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// AssignmentOpt /* Option<T>::Some */: Let;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_opt_0(
        &mut self,
        _let: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let = pop_item!(self, r#let, Let, context);
        let assignment_opt_0_built = AssignmentOptBuilder::default()
            .r#let(Box::new(r#let))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AssignmentOpt(Some(Box::new(assignment_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// AssignmentOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AssignmentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// IfBody: Then Statement;
    ///
    #[parol_runtime::function_name::named]
    fn if_body_0(
        &mut self,
        _then: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let then = pop_item!(self, then, Then, context);
        let if_body_0_built = IfBodyThenStatementBuilder::default()
            .then(Box::new(then))
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        let if_body_0_built = IfBody::ThenStatement(if_body_0_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_0_built)?;
        self.push(ASTType::IfBody(if_body_0_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// IfBody: Goto LineNumber;
    ///
    #[parol_runtime::function_name::named]
    fn if_body_1(
        &mut self,
        _goto: &ParseTreeStackEntry<'t>,
        _line_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let goto = pop_item!(self, goto, Goto, context);
        let if_body_1_built = IfBodyGotoLineNumberBuilder::default()
            .goto(Box::new(goto))
            .line_number(Box::new(line_number))
            .build()
            .into_diagnostic()?;
        let if_body_1_built = IfBody::GotoLineNumber(if_body_1_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_1_built)?;
        self.push(ASTType::IfBody(if_body_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// PrintStatement: Print %push(Expr) Expression PrintStatementList /* Vec */ %pop();
    ///
    #[parol_runtime::function_name::named]
    fn print_statement(
        &mut self,
        _print: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _print_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list =
            pop_and_reverse_item!(self, print_statement_list, PrintStatementList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let print = pop_item!(self, print, Print, context);
        let print_statement_built = PrintStatementBuilder::default()
            .print(Box::new(print))
            .expression(Box::new(expression))
            .print_statement_list(print_statement_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print_statement(&print_statement_built)?;
        self.push(ASTType::PrintStatement(print_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// PrintStatementList /* Vec<T>::Push */: <INITIAL, Expr>','^ /* Clipped */ Expression PrintStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn print_statement_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _print_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut print_statement_list =
            pop_item!(self, print_statement_list, PrintStatementList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let print_statement_list_0_built = PrintStatementListBuilder::default()
            .expression(Box::new(expression))
            // Ignore clipped member 'comma'
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        print_statement_list.push(print_statement_list_0_built);
        self.push(ASTType::PrintStatementList(print_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// PrintStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn print_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list_1_built = Vec::new();
        self.push(
            ASTType::PrintStatementList(print_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// EndStatement: End;
    ///
    #[parol_runtime::function_name::named]
    fn end_statement(
        &mut self,
        _end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let end_statement_built = EndStatementBuilder::default()
            .end(Box::new(end))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_statement(&end_statement_built)?;
        self.push(ASTType::EndStatement(end_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// EndOfLine: <INITIAL, Expr>/(?:\r?\n|\r)+/^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn end_of_line(
        &mut self,
        _end_of_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_built = EndOfLineBuilder::default()
            // Ignore clipped member 'end_of_line'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_built)?;
        self.push(ASTType::EndOfLine(end_of_line_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Literal: Number;
    ///
    #[parol_runtime::function_name::named]
    fn literal(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let literal_built = LiteralBuilder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.literal(&literal_built)?;
        self.push(ASTType::Literal(literal_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Number: Float;
    ///
    #[parol_runtime::function_name::named]
    fn number_0(
        &mut self,
        _float: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = pop_item!(self, float, Float, context);
        let number_0_built = NumberFloatBuilder::default()
            .float(Box::new(float))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::Float(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Number: Integer;
    ///
    #[parol_runtime::function_name::named]
    fn number_1(
        &mut self,
        _integer: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let number_1_built = NumberIntegerBuilder::default()
            .integer(Box::new(integer))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::Integer(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Float: Float1;
    ///
    #[parol_runtime::function_name::named]
    fn float_0(
        &mut self,
        _float1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = pop_item!(self, float1, Float1, context);
        let float_0_built = FloatFloat1Builder::default()
            .float1(Box::new(float1))
            .build()
            .into_diagnostic()?;
        let float_0_built = Float::Float1(float_0_built);
        // Calling user action here
        self.user_grammar.float(&float_0_built)?;
        self.push(ASTType::Float(float_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Float: Float2;
    ///
    #[parol_runtime::function_name::named]
    fn float_1(
        &mut self,
        _float2: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = pop_item!(self, float2, Float2, context);
        let float_1_built = FloatFloat2Builder::default()
            .float2(Box::new(float2))
            .build()
            .into_diagnostic()?;
        let float_1_built = Float::Float2(float_1_built);
        // Calling user action here
        self.user_grammar.float(&float_1_built)?;
        self.push(ASTType::Float(float_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Float1: <Expr>/(?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)?/ : BasicNumber;
    ///
    #[parol_runtime::function_name::named]
    fn float1(
        &mut self,
        float1: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = float1.token(parse_tree)?.try_into().into_diagnostic()?;
        let float1_built = Float1Builder::default()
            .float1(float1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float1(&float1_built)?;
        self.push(ASTType::Float1(float1_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Float2: <Expr>/(?:[0-9] *)+E *[-+]? *(?:[0-9] *)+/ : BasicNumber;
    ///
    #[parol_runtime::function_name::named]
    fn float2(
        &mut self,
        float2: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = float2.token(parse_tree)?.try_into().into_diagnostic()?;
        let float2_built = Float2Builder::default()
            .float2(float2)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.float2(&float2_built)?;
        self.push(ASTType::Float2(float2_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Integer: <Expr>/(?:[0-9] *)+/ : BasicNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integer(
        &mut self,
        integer: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token(parse_tree)?.try_into().into_diagnostic()?;
        let integer_built = IntegerBuilder::default()
            .integer(integer)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// If: 'IF'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn r#if(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if_built = IfBuilder::default()
            // Ignore clipped member 'r#if'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Then: <INITIAL, Expr>'THEN'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn then(
        &mut self,
        _then: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then_built = ThenBuilder::default()
            // Ignore clipped member 'then'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.then(&then_built)?;
        self.push(ASTType::Then(then_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Goto: <INITIAL, Expr>'GOTO'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn goto(
        &mut self,
        _goto: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto_built = GotoBuilder::default()
            // Ignore clipped member 'goto'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.goto(&goto_built)?;
        self.push(ASTType::Goto(goto_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Let: 'LET'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn r#let(
        &mut self,
        _let: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let_built = LetBuilder::default()
            // Ignore clipped member 'r#let'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#let(&r#let_built)?;
        self.push(ASTType::Let(r#let_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Print: /PRINT|\?/^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn print(
        &mut self,
        _print: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_built = PrintBuilder::default()
            // Ignore clipped member 'print'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.print(&print_built)?;
        self.push(ASTType::Print(print_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// End: 'END'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn end(
        &mut self,
        _end: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_built = EndBuilder::default()
            // Ignore clipped member 'end'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// AssignOp: '='^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn assign_op(
        &mut self,
        _assign_op: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_op_built = AssignOpBuilder::default()
            // Ignore clipped member 'assign_op'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_built)?;
        self.push(ASTType::AssignOp(assign_op_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// LogicalOrOp: <Expr>/N?OR/;
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_op(
        &mut self,
        logical_or_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op = logical_or_op.token(parse_tree)?.clone();
        let logical_or_op_built = LogicalOrOpBuilder::default()
            .logical_or_op(logical_or_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// LogicalAndOp: <Expr>'AND';
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_op(
        &mut self,
        logical_and_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op = logical_and_op.token(parse_tree)?.clone();
        let logical_and_op_built = LogicalAndOpBuilder::default()
            .logical_and_op(logical_and_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// LogicalNotOp: <Expr>'NOT';
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_op(
        &mut self,
        logical_not_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op = logical_not_op.token(parse_tree)?.clone();
        let logical_not_op_built = LogicalNotOpBuilder::default()
            .logical_not_op(logical_not_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// RelationalOp: <Expr>/<\s*>|<\s*=|<|>\s*=|>|=/;
    ///
    #[parol_runtime::function_name::named]
    fn relational_op(
        &mut self,
        relational_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_op = relational_op.token(parse_tree)?.clone();
        let relational_op_built = RelationalOpBuilder::default()
            .relational_op(relational_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_built)?;
        self.push(ASTType::RelationalOp(relational_op_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Plus: <Expr>'+';
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Minus: <Expr>'-';
    ///
    #[parol_runtime::function_name::named]
    fn minus(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let minus_built = MinusBuilder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// MulOp: <Expr>/\*|\u{2F}/;
    ///
    #[parol_runtime::function_name::named]
    fn mul_op(
        &mut self,
        mul_op: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mul_op = mul_op.token(parse_tree)?.clone();
        let mul_op_built = MulOpBuilder::default()
            .mul_op(mul_op)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_built)?;
        self.push(ASTType::MulOp(mul_op_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LParen: <Expr>'(';
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token(parse_tree)?.clone();
        let l_paren_built = LParenBuilder::default()
            .l_paren(l_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// RParen: <Expr>')';
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(
        &mut self,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token(parse_tree)?.clone();
        let r_paren_built = RParenBuilder::default()
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Comment: <Cmnt>/[^\r\n]+/;
    ///
    #[parol_runtime::function_name::named]
    fn comment(
        &mut self,
        comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = comment.token(parse_tree)?.clone();
        let comment_built = CommentBuilder::default()
            .comment(comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_built)?;
        self.push(ASTType::Comment(comment_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Variable: <INITIAL, Expr>/[A-Z][0-9A-Z]*/;
    ///
    #[parol_runtime::function_name::named]
    fn variable(
        &mut self,
        variable: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = variable.token(parse_tree)?.clone();
        let variable_built = VariableBuilder::default()
            .variable(variable)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.variable(&variable_built)?;
        self.push(ASTType::Variable(variable_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Expression: LogicalOr;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _logical_or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or = pop_item!(self, logical_or, LogicalOr, context);
        let expression_built = ExpressionBuilder::default()
            .logical_or(Box::new(logical_or))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// LogicalOr: LogicalAnd LogicalOrList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn logical_or(
        &mut self,
        _logical_and: &ParseTreeStackEntry<'t>,
        _logical_or_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list = pop_and_reverse_item!(self, logical_or_list, LogicalOrList, context);
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_built = LogicalOrBuilder::default()
            .logical_and(Box::new(logical_and))
            .logical_or_list(logical_or_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_built)?;
        self.push(ASTType::LogicalOr(logical_or_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// LogicalOrList /* Vec<T>::Push */: LogicalOrOp LogicalAnd LogicalOrList;
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_list_0(
        &mut self,
        _logical_or_op: &ParseTreeStackEntry<'t>,
        _logical_and: &ParseTreeStackEntry<'t>,
        _logical_or_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list = pop_item!(self, logical_or_list, LogicalOrList, context);
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_op = pop_item!(self, logical_or_op, LogicalOrOp, context);
        let logical_or_list_0_built = LogicalOrListBuilder::default()
            .logical_and(Box::new(logical_and))
            .logical_or_op(Box::new(logical_or_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_or_list.push(logical_or_list_0_built);
        self.push(ASTType::LogicalOrList(logical_or_list), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// LogicalOrList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// LogicalAnd: LogicalNot LogicalAndList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn logical_and(
        &mut self,
        _logical_not: &ParseTreeStackEntry<'t>,
        _logical_and_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list =
            pop_and_reverse_item!(self, logical_and_list, LogicalAndList, context);
        let logical_not = pop_item!(self, logical_not, LogicalNot, context);
        let logical_and_built = LogicalAndBuilder::default()
            .logical_not(Box::new(logical_not))
            .logical_and_list(logical_and_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_built)?;
        self.push(ASTType::LogicalAnd(logical_and_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// LogicalAndList /* Vec<T>::Push */: LogicalAndOp LogicalNot LogicalAndList;
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_list_0(
        &mut self,
        _logical_and_op: &ParseTreeStackEntry<'t>,
        _logical_not: &ParseTreeStackEntry<'t>,
        _logical_and_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list = pop_item!(self, logical_and_list, LogicalAndList, context);
        let logical_not = pop_item!(self, logical_not, LogicalNot, context);
        let logical_and_op = pop_item!(self, logical_and_op, LogicalAndOp, context);
        let logical_and_list_0_built = LogicalAndListBuilder::default()
            .logical_not(Box::new(logical_not))
            .logical_and_op(Box::new(logical_and_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        logical_and_list.push(logical_and_list_0_built);
        self.push(ASTType::LogicalAndList(logical_and_list), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// LogicalAndList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// LogicalNot: LogicalNotOpt /* Option */ Relational;
    ///
    #[parol_runtime::function_name::named]
    fn logical_not(
        &mut self,
        _logical_not_opt: &ParseTreeStackEntry<'t>,
        _relational: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational = pop_item!(self, relational, Relational, context);
        let logical_not_opt = pop_item!(self, logical_not_opt, LogicalNotOpt, context);
        let logical_not_built = LogicalNotBuilder::default()
            .logical_not_opt(logical_not_opt)
            .relational(Box::new(relational))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_built)?;
        self.push(ASTType::LogicalNot(logical_not_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// LogicalNotOpt /* Option<T>::Some */: LogicalNotOp;
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_opt_0(
        &mut self,
        _logical_not_op: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op = pop_item!(self, logical_not_op, LogicalNotOp, context);
        let logical_not_opt_0_built = LogicalNotOptBuilder::default()
            .logical_not_op(Box::new(logical_not_op))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::LogicalNotOpt(Some(Box::new(logical_not_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// LogicalNotOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LogicalNotOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// Relational: Summation RelationalList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn relational(
        &mut self,
        _summation: &ParseTreeStackEntry<'t>,
        _relational_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list = pop_and_reverse_item!(self, relational_list, RelationalList, context);
        let summation = pop_item!(self, summation, Summation, context);
        let relational_built = RelationalBuilder::default()
            .summation(Box::new(summation))
            .relational_list(relational_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.relational(&relational_built)?;
        self.push(ASTType::Relational(relational_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// RelationalList /* Vec<T>::Push */: RelationalOp Summation RelationalList;
    ///
    #[parol_runtime::function_name::named]
    fn relational_list_0(
        &mut self,
        _relational_op: &ParseTreeStackEntry<'t>,
        _summation: &ParseTreeStackEntry<'t>,
        _relational_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list = pop_item!(self, relational_list, RelationalList, context);
        let summation = pop_item!(self, summation, Summation, context);
        let relational_op = pop_item!(self, relational_op, RelationalOp, context);
        let relational_list_0_built = RelationalListBuilder::default()
            .summation(Box::new(summation))
            .relational_op(Box::new(relational_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        relational_list.push(relational_list_0_built);
        self.push(ASTType::RelationalList(relational_list), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// RelationalList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn relational_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn summation(
        &mut self,
        _multiplication: &ParseTreeStackEntry<'t>,
        _summation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list = pop_and_reverse_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_built = SummationBuilder::default()
            .multiplication(Box::new(multiplication))
            .summation_list(summation_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.summation(&summation_built)?;
        self.push(ASTType::Summation(summation_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// SummationList /* Vec<T>::Push */: SummationListGroup Multiplication SummationList;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_0(
        &mut self,
        _summation_list_group: &ParseTreeStackEntry<'t>,
        _multiplication: &ParseTreeStackEntry<'t>,
        _summation_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list = pop_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_list_group =
            pop_item!(self, summation_list_group, SummationListGroup, context);
        let summation_list_0_built = SummationListBuilder::default()
            .multiplication(Box::new(multiplication))
            .summation_list_group(Box::new(summation_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        summation_list.push(summation_list_0_built);
        self.push(ASTType::SummationList(summation_list), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// SummationListGroup: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let summation_list_group_0_built = SummationListGroupPlusBuilder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let summation_list_group_0_built = SummationListGroup::Plus(summation_list_group_0_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// SummationListGroup: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let summation_list_group_1_built = SummationListGroupMinusBuilder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let summation_list_group_1_built = SummationListGroup::Minus(summation_list_group_1_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// SummationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _multiplication_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list =
            pop_and_reverse_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let multiplication_built = MultiplicationBuilder::default()
            .factor(Box::new(factor))
            .multiplication_list(multiplication_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_built)?;
        self.push(ASTType::Multiplication(multiplication_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// MultiplicationList /* Vec<T>::Push */: MulOp Factor MultiplicationList;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_0(
        &mut self,
        _mul_op: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _multiplication_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list =
            pop_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_op = pop_item!(self, mul_op, MulOp, context);
        let multiplication_list_0_built = MultiplicationListBuilder::default()
            .factor(Box::new(factor))
            .mul_op(Box::new(mul_op))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        multiplication_list.push(multiplication_list_0_built);
        self.push(ASTType::MultiplicationList(multiplication_list), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// MultiplicationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// Factor: Literal;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _literal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal = pop_item!(self, literal, Literal, context);
        let factor_0_built = FactorLiteralBuilder::default()
            .literal(Box::new(literal))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Literal(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// Factor: Variable;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _variable: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = pop_item!(self, variable, Variable, context);
        let factor_1_built = FactorVariableBuilder::default()
            .variable(Box::new(variable))
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Variable(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Factor: Minus Factor;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let minus = pop_item!(self, minus, Minus, context);
        let factor_2_built = FactorMinusFactorBuilder::default()
            .minus(Box::new(minus))
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::MinusFactor(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_3_built = FactorLParenExpressionRParenBuilder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_3_built = Factor::LParenExpressionRParen(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.basic(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            1 => self.basic_list_0(&children[0], &children[1], &children[2], parse_tree),
            2 => self.basic_list_1(parse_tree),
            3 => self.basic_opt0_0(&children[0], parse_tree),
            4 => self.basic_opt0_1(parse_tree),
            5 => self.basic_opt_0(&children[0], parse_tree),
            6 => self.basic_opt_1(parse_tree),
            7 => self.line(&children[0], &children[1], &children[2], parse_tree),
            8 => self.line_list_0(&children[0], &children[1], &children[2], parse_tree),
            9 => self.line_list_1(parse_tree),
            10 => self.line_number(&children[0], parse_tree),
            11 => self.statement_0(&children[0], parse_tree),
            12 => self.statement_1(&children[0], parse_tree),
            13 => self.statement_2(&children[0], parse_tree),
            14 => self.statement_3(&children[0], parse_tree),
            15 => self.statement_4(&children[0], parse_tree),
            16 => self.statement_5(&children[0], parse_tree),
            17 => self.remark(&children[0], &children[1], parse_tree),
            18 => self.remark_opt_0(&children[0], parse_tree),
            19 => self.remark_opt_1(parse_tree),
            20 => self.goto_statement(&children[0], &children[1], parse_tree),
            21 => self.if_statement(&children[0], &children[1], &children[2], parse_tree),
            22 => self.assignment(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            23 => self.assignment_opt_0(&children[0], parse_tree),
            24 => self.assignment_opt_1(parse_tree),
            25 => self.if_body_0(&children[0], &children[1], parse_tree),
            26 => self.if_body_1(&children[0], &children[1], parse_tree),
            27 => self.print_statement(&children[0], &children[1], &children[2], parse_tree),
            28 => self.print_statement_list_0(&children[0], &children[1], &children[2], parse_tree),
            29 => self.print_statement_list_1(parse_tree),
            30 => self.end_statement(&children[0], parse_tree),
            31 => self.end_of_line(&children[0], parse_tree),
            32 => self.literal(&children[0], parse_tree),
            33 => self.number_0(&children[0], parse_tree),
            34 => self.number_1(&children[0], parse_tree),
            35 => self.float_0(&children[0], parse_tree),
            36 => self.float_1(&children[0], parse_tree),
            37 => self.float1(&children[0], parse_tree),
            38 => self.float2(&children[0], parse_tree),
            39 => self.integer(&children[0], parse_tree),
            40 => self.r#if(&children[0], parse_tree),
            41 => self.then(&children[0], parse_tree),
            42 => self.goto(&children[0], parse_tree),
            43 => self.r#let(&children[0], parse_tree),
            44 => self.print(&children[0], parse_tree),
            45 => self.end(&children[0], parse_tree),
            46 => self.assign_op(&children[0], parse_tree),
            47 => self.logical_or_op(&children[0], parse_tree),
            48 => self.logical_and_op(&children[0], parse_tree),
            49 => self.logical_not_op(&children[0], parse_tree),
            50 => self.relational_op(&children[0], parse_tree),
            51 => self.plus(&children[0], parse_tree),
            52 => self.minus(&children[0], parse_tree),
            53 => self.mul_op(&children[0], parse_tree),
            54 => self.l_paren(&children[0], parse_tree),
            55 => self.r_paren(&children[0], parse_tree),
            56 => self.comment(&children[0], parse_tree),
            57 => self.variable(&children[0], parse_tree),
            58 => self.expression(&children[0], parse_tree),
            59 => self.logical_or(&children[0], &children[1], parse_tree),
            60 => self.logical_or_list_0(&children[0], &children[1], &children[2], parse_tree),
            61 => self.logical_or_list_1(parse_tree),
            62 => self.logical_and(&children[0], &children[1], parse_tree),
            63 => self.logical_and_list_0(&children[0], &children[1], &children[2], parse_tree),
            64 => self.logical_and_list_1(parse_tree),
            65 => self.logical_not(&children[0], &children[1], parse_tree),
            66 => self.logical_not_opt_0(&children[0], parse_tree),
            67 => self.logical_not_opt_1(parse_tree),
            68 => self.relational(&children[0], &children[1], parse_tree),
            69 => self.relational_list_0(&children[0], &children[1], &children[2], parse_tree),
            70 => self.relational_list_1(parse_tree),
            71 => self.summation(&children[0], &children[1], parse_tree),
            72 => self.summation_list_0(&children[0], &children[1], &children[2], parse_tree),
            73 => self.summation_list_group_0(&children[0], parse_tree),
            74 => self.summation_list_group_1(&children[0], parse_tree),
            75 => self.summation_list_1(parse_tree),
            76 => self.multiplication(&children[0], &children[1], parse_tree),
            77 => self.multiplication_list_0(&children[0], &children[1], &children[2], parse_tree),
            78 => self.multiplication_list_1(parse_tree),
            79 => self.factor_0(&children[0], parse_tree),
            80 => self.factor_1(&children[0], parse_tree),
            81 => self.factor_2(&children[0], &children[1], parse_tree),
            82 => self.factor_3(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
