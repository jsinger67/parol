// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::parse_tree_type::{NonTerminalEnum, TerminalEnum};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait BasicGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Basic'
    fn basic(&mut self, _arg: &Basic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LineNumber'
    fn line_number(&mut self, _arg: &LineNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Remark'
    fn remark(&mut self, _arg: &Remark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GotoStatement'
    fn goto_statement(&mut self, _arg: &GotoStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfBody'
    fn if_body(&mut self, _arg: &IfBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PrintStatement'
    fn print_statement(&mut self, _arg: &PrintStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndStatement'
    fn end_statement(&mut self, _arg: &EndStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EndOfLine'
    fn end_of_line(&mut self, _arg: &EndOfLine) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Literal'
    fn literal(&mut self, _arg: &Literal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float1'
    fn float1(&mut self, _arg: &Float1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float2'
    fn float2(&mut self, _arg: &Float2) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Rem'
    fn rem(&mut self, _arg: &Rem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Then'
    fn then(&mut self, _arg: &Then) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Goto'
    fn goto(&mut self, _arg: &Goto) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Let'
    fn r#let(&mut self, _arg: &Let) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Print'
    fn print(&mut self, _arg: &Print) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignOp'
    fn assign_op(&mut self, _arg: &AssignOp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrOp'
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndOp'
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNotOp'
    fn logical_not_op(&mut self, _arg: &LogicalNotOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalOp'
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comment'
    fn comment(&mut self, _arg: &Comment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Variable'
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOr'
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAnd'
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalNot'
    fn logical_not(&mut self, _arg: &LogicalNot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relational'
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Summation'
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Multiplication'
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 11
///
/// `Statement: Remark;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementRemark<'t> {
    pub remark: Remark<'t>,
}

///
/// Type derived for production 12
///
/// `Statement: GotoStatement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementGotoStatement {
    pub goto_statement: GotoStatement,
}

///
/// Type derived for production 13
///
/// `Statement: IfStatement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfStatement<'t> {
    pub if_statement: Box<IfStatement<'t>>,
}

///
/// Type derived for production 14
///
/// `Statement: Assignment;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementAssignment<'t> {
    pub assignment: Assignment<'t>,
}

///
/// Type derived for production 15
///
/// `Statement: PrintStatement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementPrintStatement<'t> {
    pub print_statement: PrintStatement<'t>,
}

///
/// Type derived for production 16
///
/// `Statement: EndStatement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementEndStatement {
    pub end_statement: EndStatement,
}

///
/// Type derived for production 25
///
/// `IfBody: Then Statement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfBodyThenStatement<'t> {
    pub then: Then,
    pub statement: Statement<'t>,
}

///
/// Type derived for production 26
///
/// `IfBody: Goto LineNumber;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfBodyGotoLineNumber {
    pub goto: Goto,
    pub line_number: LineNumber,
}

///
/// Type derived for production 33
///
/// `Number: Float;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberFloat {
    pub float: Float,
}

///
/// Type derived for production 34
///
/// `Number: Integer;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberInteger {
    pub integer: Integer,
}

///
/// Type derived for production 35
///
/// `Float: Float1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatFloat1 {
    pub float1: Float1,
}

///
/// Type derived for production 36
///
/// `Float: Float2;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FloatFloat2 {
    pub float2: Float2,
}

///
/// Type derived for production 74
///
/// `SummationListGroup: Plus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupPlus<'t> {
    pub plus: Plus<'t>,
}

///
/// Type derived for production 75
///
/// `SummationListGroup: Minus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupMinus<'t> {
    pub minus: Minus<'t>,
}

///
/// Type derived for production 80
///
/// `Factor: Literal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLiteral {
    pub literal: Literal,
}

///
/// Type derived for production 81
///
/// `Factor: Variable;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorVariable<'t> {
    pub variable: Variable<'t>,
}

///
/// Type derived for production 82
///
/// `Factor: Minus Factor;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorMinusFactor<'t> {
    pub minus: Minus<'t>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 83
///
/// `Factor: LParen Expression RParen;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenExpressionRParen<'t> {
    pub l_paren: LParen<'t>,
    pub expression: Box<Expression<'t>>,
    pub r_paren: RParen<'t>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignOp {}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assignment<'t> {
    pub assignment_opt: Option<AssignmentOpt>,
    pub variable: Variable<'t>,
    pub assign_op: AssignOp,
    pub expression: Expression<'t>,
}

///
/// Type derived for non-terminal AssignmentOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOpt {
    pub r#let: Let,
}

///
/// Type derived for non-terminal Basic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Basic<'t> {
    pub basic_opt: Option<BasicOpt>,
    pub line: Line<'t>,
    pub basic_list: Vec<BasicList<'t>>,
    pub basic_opt0: Option<BasicOpt0>,
}

///
/// Type derived for non-terminal BasicList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicList<'t> {
    pub end_of_line: EndOfLine,
    pub line: Line<'t>,
}

///
/// Type derived for non-terminal BasicOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicOpt {
    pub end_of_line: EndOfLine,
}

///
/// Type derived for non-terminal BasicOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasicOpt0 {
    pub end_of_line: EndOfLine,
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comment<'t> {
    pub comment: Token<'t>, /* [^\r\n]+ */
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct End {}

///
/// Type derived for non-terminal EndOfLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EndOfLine {}

///
/// Type derived for non-terminal EndStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EndStatement {
    pub end: End,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression<'t> {
    pub logical_or: LogicalOr<'t>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Literal(FactorLiteral),
    Variable(FactorVariable<'t>),
    MinusFactor(FactorMinusFactor<'t>),
    LParenExpressionRParen(FactorLParenExpressionRParen<'t>),
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Float {
    Float1(FloatFloat1),
    Float2(FloatFloat2),
}

///
/// Type derived for non-terminal Float1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Float1 {
    pub float1: crate::basic_grammar::BasicNumber, /* (?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)? */
}

///
/// Type derived for non-terminal Float2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Float2 {
    pub float2: crate::basic_grammar::BasicNumber, /* (?:[0-9] *)+E *[-+]? *(?:[0-9] *)+ */
}

///
/// Type derived for non-terminal Goto
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Goto {}

///
/// Type derived for non-terminal GotoStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GotoStatement {
    pub goto: Goto,
    pub line_number: LineNumber,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct If {}

///
/// Type derived for non-terminal IfBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfBody<'t> {
    ThenStatement(IfBodyThenStatement<'t>),
    GotoLineNumber(IfBodyGotoLineNumber),
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatement<'t> {
    pub r#if: If,
    pub expression: Expression<'t>,
    pub if_body: IfBody<'t>,
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer {
    pub integer: crate::basic_grammar::BasicNumber, /* (?:[0-9] *)+ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Let {}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Line<'t> {
    pub line_number: LineNumber,
    pub statement: Statement<'t>,
    pub line_list: Vec<LineList<'t>>,
}

///
/// Type derived for non-terminal LineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineList<'t> {
    pub statement: Statement<'t>,
}

///
/// Type derived for non-terminal LineNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineNumber {
    pub line_number: crate::basic_grammar::BasicLineNumber, /* [0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+ */
}

///
/// Type derived for non-terminal Literal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Literal {
    pub number: Number,
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAnd<'t> {
    pub logical_not: LogicalNot<'t>,
    pub logical_and_list: Vec<LogicalAndList<'t>>,
}

///
/// Type derived for non-terminal LogicalAndList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndList<'t> {
    pub logical_and_op: LogicalAndOp<'t>,
    pub logical_not: LogicalNot<'t>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndOp<'t> {
    pub logical_and_op: Token<'t>, /* AND */
}

///
/// Type derived for non-terminal LogicalNot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNot<'t> {
    pub logical_not_opt: Option<LogicalNotOpt<'t>>,
    pub relational: Relational<'t>,
}

///
/// Type derived for non-terminal LogicalNotOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNotOp<'t> {
    pub logical_not_op: Token<'t>, /* NOT */
}

///
/// Type derived for non-terminal LogicalNotOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNotOpt<'t> {
    pub logical_not_op: LogicalNotOp<'t>,
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOr<'t> {
    pub logical_and: LogicalAnd<'t>,
    pub logical_or_list: Vec<LogicalOrList<'t>>,
}

///
/// Type derived for non-terminal LogicalOrList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrList<'t> {
    pub logical_or_op: LogicalOrOp<'t>,
    pub logical_and: LogicalAnd<'t>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrOp<'t> {
    pub logical_or_op: Token<'t>, /* N?OR */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOp<'t> {
    pub mul_op: Token<'t>, /* \*|\u{2F} */
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Multiplication<'t> {
    pub factor: Factor<'t>,
    pub multiplication_list: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationList<'t> {
    pub mul_op: MulOp<'t>,
    pub factor: Factor<'t>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    Float(NumberFloat),
    Integer(NumberInteger),
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Print
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Print {}

///
/// Type derived for non-terminal PrintStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrintStatement<'t> {
    pub print: Print,
    pub expression: Expression<'t>,
    pub print_statement_list: Vec<PrintStatementList<'t>>,
}

///
/// Type derived for non-terminal PrintStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrintStatementList<'t> {
    pub expression: Expression<'t>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Relational<'t> {
    pub summation: Summation<'t>,
    pub relational_list: Vec<RelationalList<'t>>,
}

///
/// Type derived for non-terminal RelationalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalList<'t> {
    pub relational_op: RelationalOp<'t>,
    pub summation: Summation<'t>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOp<'t> {
    pub relational_op: Token<'t>, /* <\s*>|<\s*=|<|>\s*=|>|= */
}

///
/// Type derived for non-terminal Rem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Rem {}

///
/// Type derived for non-terminal Remark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Remark<'t> {
    pub rem: Rem,
    pub remark_opt: Option<RemarkOpt<'t>>,
}

///
/// Type derived for non-terminal RemarkOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RemarkOpt<'t> {
    pub comment: Comment<'t>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Remark(StatementRemark<'t>),
    GotoStatement(StatementGotoStatement),
    IfStatement(StatementIfStatement<'t>),
    Assignment(StatementAssignment<'t>),
    PrintStatement(StatementPrintStatement<'t>),
    EndStatement(StatementEndStatement),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Summation<'t> {
    pub multiplication: Multiplication<'t>,
    pub summation_list: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationList<'t> {
    pub summation_list_group: SummationListGroup<'t>,
    pub multiplication: Multiplication<'t>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    Plus(SummationListGroupPlus<'t>),
    Minus(SummationListGroupMinus<'t>),
}

///
/// Type derived for non-terminal Then
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Then {}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Variable<'t> {
    pub variable: Token<'t>, /* [A-Z][0-9A-Z]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AssignOp(AssignOp),
    Assignment(Assignment<'t>),
    AssignmentOpt(Option<AssignmentOpt>),
    Basic(Basic<'t>),
    BasicList(Vec<BasicList<'t>>),
    BasicOpt(Option<BasicOpt>),
    BasicOpt0(Option<BasicOpt0>),
    Comment(Comment<'t>),
    End(End),
    EndOfLine(EndOfLine),
    EndStatement(EndStatement),
    Expression(Expression<'t>),
    Factor(Factor<'t>),
    Float(Float),
    Float1(Float1),
    Float2(Float2),
    Goto(Goto),
    GotoStatement(GotoStatement),
    If(If),
    IfBody(IfBody<'t>),
    IfStatement(IfStatement<'t>),
    Integer(Integer),
    LParen(LParen<'t>),
    Let(Let),
    Line(Line<'t>),
    LineList(Vec<LineList<'t>>),
    LineNumber(LineNumber),
    Literal(Literal),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndList(Vec<LogicalAndList<'t>>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalNot(LogicalNot<'t>),
    LogicalNotOp(LogicalNotOp<'t>),
    LogicalNotOpt(Option<LogicalNotOpt<'t>>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrList(Vec<LogicalOrList<'t>>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    MulOp(MulOp<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    Number(Number),
    Plus(Plus<'t>),
    Print(Print),
    PrintStatement(PrintStatement<'t>),
    PrintStatementList(Vec<PrintStatementList<'t>>),
    RParen(RParen<'t>),
    Relational(Relational<'t>),
    RelationalList(Vec<RelationalList<'t>>),
    RelationalOp(RelationalOp<'t>),
    Rem(Rem),
    Remark(Remark<'t>),
    RemarkOpt(Option<RemarkOpt<'t>>),
    Statement(Statement<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Then(Then),
    Variable(Variable<'t>),
}

// -------------------------------------------------------------------------------------------------

#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum NonTerminalKind {
    AssignOp,
    Assignment,
    AssignmentOpt,
    Basic,
    BasicList,
    BasicOpt,
    BasicOpt0,
    Comment,
    End,
    EndOfLine,
    EndStatement,
    Expression,
    Factor,
    Float,
    Float1,
    Float2,
    Goto,
    GotoStatement,
    If,
    IfBody,
    IfStatement,
    Integer,
    LParen,
    Let,
    Line,
    LineList,
    LineNumber,
    Literal,
    LogicalAnd,
    LogicalAndList,
    LogicalAndOp,
    LogicalNot,
    LogicalNotOp,
    LogicalNotOpt,
    LogicalOr,
    LogicalOrList,
    LogicalOrOp,
    Minus,
    MulOp,
    Multiplication,
    MultiplicationList,
    Number,
    Plus,
    Print,
    PrintStatement,
    PrintStatementList,
    RParen,
    Relational,
    RelationalList,
    RelationalOp,
    Rem,
    Remark,
    RemarkOpt,
    Statement,
    Summation,
    SummationList,
    SummationListGroup,
    Then,
    Variable,
    Root,
}

#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TerminalKind {
    NewLine,
    Whitespace,
    LineComment,
    BlockComment,
    Colon,
    LineNumber,
    Comma,
    EndOfLine,
    Float1,
    Float2,
    Integer,
    Rem,
    If,
    Then,
    Goto,
    Let,
    Print,
    End,
    AssignOp,
    LogicalOrOp,
    LogicalAndOp,
    LogicalNotOp,
    RelationalOp,
    Plus,
    Minus,
    MulOp,
    LParen,
    RParen,
    Comment,
    Variable,
}

impl TerminalEnum for TerminalKind {
    fn from_terminal_index(index: u16) -> Self {
        match index {
            1 => Self::NewLine,
            2 => Self::Whitespace,
            3 => Self::LineComment,
            4 => Self::BlockComment,
            5 => Self::Colon,
            6 => Self::LineNumber,
            7 => Self::Comma,
            8 => Self::EndOfLine,
            9 => Self::Float1,
            10 => Self::Float2,
            11 => Self::Integer,
            12 => Self::Rem,
            13 => Self::If,
            14 => Self::Then,
            15 => Self::Goto,
            16 => Self::Let,
            17 => Self::Print,
            18 => Self::End,
            19 => Self::AssignOp,
            20 => Self::LogicalOrOp,
            21 => Self::LogicalAndOp,
            22 => Self::LogicalNotOp,
            23 => Self::RelationalOp,
            24 => Self::Plus,
            25 => Self::Minus,
            26 => Self::MulOp,
            27 => Self::LParen,
            28 => Self::RParen,
            29 => Self::Comment,
            30 => Self::Variable,
            _ => panic!("Invalid terminal index: {}", index),
        }
    }
}

impl NonTerminalEnum for NonTerminalKind {
    fn from_non_terminal_name(name: &str) -> Self {
        match name {
            "AssignOp" => Self::AssignOp,
            "Assignment" => Self::Assignment,
            "AssignmentOpt" => Self::AssignmentOpt,
            "Basic" => Self::Basic,
            "BasicList" => Self::BasicList,
            "BasicOpt" => Self::BasicOpt,
            "BasicOpt0" => Self::BasicOpt0,
            "Comment" => Self::Comment,
            "End" => Self::End,
            "EndOfLine" => Self::EndOfLine,
            "EndStatement" => Self::EndStatement,
            "Expression" => Self::Expression,
            "Factor" => Self::Factor,
            "Float" => Self::Float,
            "Float1" => Self::Float1,
            "Float2" => Self::Float2,
            "Goto" => Self::Goto,
            "GotoStatement" => Self::GotoStatement,
            "If" => Self::If,
            "IfBody" => Self::IfBody,
            "IfStatement" => Self::IfStatement,
            "Integer" => Self::Integer,
            "LParen" => Self::LParen,
            "Let" => Self::Let,
            "Line" => Self::Line,
            "LineList" => Self::LineList,
            "LineNumber" => Self::LineNumber,
            "Literal" => Self::Literal,
            "LogicalAnd" => Self::LogicalAnd,
            "LogicalAndList" => Self::LogicalAndList,
            "LogicalAndOp" => Self::LogicalAndOp,
            "LogicalNot" => Self::LogicalNot,
            "LogicalNotOp" => Self::LogicalNotOp,
            "LogicalNotOpt" => Self::LogicalNotOpt,
            "LogicalOr" => Self::LogicalOr,
            "LogicalOrList" => Self::LogicalOrList,
            "LogicalOrOp" => Self::LogicalOrOp,
            "Minus" => Self::Minus,
            "MulOp" => Self::MulOp,
            "Multiplication" => Self::Multiplication,
            "MultiplicationList" => Self::MultiplicationList,
            "Number" => Self::Number,
            "Plus" => Self::Plus,
            "Print" => Self::Print,
            "PrintStatement" => Self::PrintStatement,
            "PrintStatementList" => Self::PrintStatementList,
            "RParen" => Self::RParen,
            "Relational" => Self::Relational,
            "RelationalList" => Self::RelationalList,
            "RelationalOp" => Self::RelationalOp,
            "Rem" => Self::Rem,
            "Remark" => Self::Remark,
            "RemarkOpt" => Self::RemarkOpt,
            "Statement" => Self::Statement,
            "Summation" => Self::Summation,
            "SummationList" => Self::SummationList,
            "SummationListGroup" => Self::SummationListGroup,
            "Then" => Self::Then,
            "Variable" => Self::Variable,
            "" => Self::Root,
            _ => panic!("Invalid non-terminal name: {}", name),
        }
    }
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct BasicGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn BasicGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `BasicGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> BasicGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn BasicGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Basic: BasicOpt /* Option */ Line BasicList /* Vec */ BasicOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn basic(
        &mut self,
        _basic_opt: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
        _basic_list: &ParseTreeType<'t>,
        _basic_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_opt0 = pop_item!(self, basic_opt0, BasicOpt0, context);
        let basic_list = pop_and_reverse_item!(self, basic_list, BasicList, context);
        let line = pop_item!(self, line, Line, context);
        let basic_opt = pop_item!(self, basic_opt, BasicOpt, context);
        let basic_built = Basic {
            basic_opt,
            line,
            basic_list,
            basic_opt0,
        };
        // Calling user action here
        self.user_grammar.basic(&basic_built)?;
        self.push(ASTType::Basic(basic_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `BasicList /* Vec<T>::Push */: EndOfLine Line BasicList;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_list_0(
        &mut self,
        _end_of_line: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
        _basic_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut basic_list = pop_item!(self, basic_list, BasicList, context);
        let line = pop_item!(self, line, Line, context);
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_list_0_built = BasicList { line, end_of_line };
        // Add an element to the vector
        basic_list.push(basic_list_0_built);
        self.push(ASTType::BasicList(basic_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `BasicList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let basic_list_1_built = Vec::new();
        self.push(ASTType::BasicList(basic_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `BasicOpt0 /* Option<T>::Some */: EndOfLine;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt0_0(&mut self, _end_of_line: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_opt0_0_built = BasicOpt0 { end_of_line };
        self.push(ASTType::BasicOpt0(Some(basic_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `BasicOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BasicOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `BasicOpt /* Option<T>::Some */: EndOfLine;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt_0(&mut self, _end_of_line: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line = pop_item!(self, end_of_line, EndOfLine, context);
        let basic_opt_0_built = BasicOpt { end_of_line };
        self.push(ASTType::BasicOpt(Some(basic_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `BasicOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn basic_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BasicOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Line: LineNumber Statement LineList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn line(
        &mut self,
        _line_number: &ParseTreeType<'t>,
        _statement: &ParseTreeType<'t>,
        _line_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list = pop_and_reverse_item!(self, line_list, LineList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let line_built = Line {
            line_number,
            statement,
            line_list,
        };
        // Calling user action here
        self.user_grammar.line(&line_built)?;
        self.push(ASTType::Line(line_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `LineList /* Vec<T>::Push */: <INITIAL, Expr>':'^ /* Clipped */ Statement LineList;`
    ///
    #[parol_runtime::function_name::named]
    fn line_list_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _statement: &ParseTreeType<'t>,
        _line_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut line_list = pop_item!(self, line_list, LineList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let line_list_0_built = LineList { statement };
        // Add an element to the vector
        line_list.push(line_list_0_built);
        self.push(ASTType::LineList(line_list), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `LineList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn line_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_list_1_built = Vec::new();
        self.push(ASTType::LineList(line_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `LineNumber: /[0 ]*[1-9] *(?:[0-9] *){1,4}|[0 ]+/ : BasicLineNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn line_number(&mut self, line_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = line_number
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let line_number_built = LineNumber { line_number };
        // Calling user action here
        self.user_grammar.line_number(&line_number_built)?;
        self.push(ASTType::LineNumber(line_number_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `Statement: Remark;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(&mut self, _remark: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark = pop_item!(self, remark, Remark, context);
        let statement_0_built = StatementRemark { remark };
        let statement_0_built = Statement::Remark(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `Statement: GotoStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(&mut self, _goto_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto_statement = pop_item!(self, goto_statement, GotoStatement, context);
        let statement_1_built = StatementGotoStatement { goto_statement };
        let statement_1_built = Statement::GotoStatement(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `Statement: IfStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_2(&mut self, _if_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_2_built = StatementIfStatement {
            if_statement: Box::new(if_statement),
        };
        let statement_2_built = Statement::IfStatement(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Statement: Assignment;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_3(&mut self, _assignment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let statement_3_built = StatementAssignment { assignment };
        let statement_3_built = Statement::Assignment(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `Statement: PrintStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_4(&mut self, _print_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement = pop_item!(self, print_statement, PrintStatement, context);
        let statement_4_built = StatementPrintStatement { print_statement };
        let statement_4_built = Statement::PrintStatement(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `Statement: EndStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_5(&mut self, _end_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_statement = pop_item!(self, end_statement, EndStatement, context);
        let statement_5_built = StatementEndStatement { end_statement };
        let statement_5_built = Statement::EndStatement(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `Remark: Rem RemarkOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn remark(&mut self, _rem: &ParseTreeType<'t>, _remark_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let remark_opt = pop_item!(self, remark_opt, RemarkOpt, context);
        let rem = pop_item!(self, rem, Rem, context);
        let remark_built = Remark { rem, remark_opt };
        // Calling user action here
        self.user_grammar.remark(&remark_built)?;
        self.push(ASTType::Remark(remark_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `RemarkOpt /* Option<T>::Some */: Comment;`
    ///
    #[parol_runtime::function_name::named]
    fn remark_opt_0(&mut self, _comment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = pop_item!(self, comment, Comment, context);
        let remark_opt_0_built = RemarkOpt { comment };
        self.push(ASTType::RemarkOpt(Some(remark_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `RemarkOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn remark_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RemarkOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `GotoStatement: Goto LineNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn goto_statement(
        &mut self,
        _goto: &ParseTreeType<'t>,
        _line_number: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let goto = pop_item!(self, goto, Goto, context);
        let goto_statement_built = GotoStatement { goto, line_number };
        // Calling user action here
        self.user_grammar.goto_statement(&goto_statement_built)?;
        self.push(ASTType::GotoStatement(goto_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `IfStatement: If Expression IfBody;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _if_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_body = pop_item!(self, if_body, IfBody, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatement {
            r#if,
            expression,
            if_body,
        };
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Assignment: AssignmentOpt /* Option */ Variable AssignOp Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        _assignment_opt: &ParseTreeType<'t>,
        _variable: &ParseTreeType<'t>,
        _assign_op: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assign_op = pop_item!(self, assign_op, AssignOp, context);
        let variable = pop_item!(self, variable, Variable, context);
        let assignment_opt = pop_item!(self, assignment_opt, AssignmentOpt, context);
        let assignment_built = Assignment {
            assignment_opt,
            variable,
            assign_op,
            expression,
        };
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `AssignmentOpt /* Option<T>::Some */: Let;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_opt_0(&mut self, _let: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let = pop_item!(self, r#let, Let, context);
        let assignment_opt_0_built = AssignmentOpt { r#let };
        self.push(
            ASTType::AssignmentOpt(Some(assignment_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `AssignmentOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AssignmentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `IfBody: Then Statement;`
    ///
    #[parol_runtime::function_name::named]
    fn if_body_0(
        &mut self,
        _then: &ParseTreeType<'t>,
        _statement: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let then = pop_item!(self, then, Then, context);
        let if_body_0_built = IfBodyThenStatement { then, statement };
        let if_body_0_built = IfBody::ThenStatement(if_body_0_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_0_built)?;
        self.push(ASTType::IfBody(if_body_0_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `IfBody: Goto LineNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn if_body_1(
        &mut self,
        _goto: &ParseTreeType<'t>,
        _line_number: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_number = pop_item!(self, line_number, LineNumber, context);
        let goto = pop_item!(self, goto, Goto, context);
        let if_body_1_built = IfBodyGotoLineNumber { goto, line_number };
        let if_body_1_built = IfBody::GotoLineNumber(if_body_1_built);
        // Calling user action here
        self.user_grammar.if_body(&if_body_1_built)?;
        self.push(ASTType::IfBody(if_body_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `PrintStatement: Print Expression PrintStatementList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn print_statement(
        &mut self,
        _print: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _print_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list =
            pop_and_reverse_item!(self, print_statement_list, PrintStatementList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let print = pop_item!(self, print, Print, context);
        let print_statement_built = PrintStatement {
            print,
            expression,
            print_statement_list,
        };
        // Calling user action here
        self.user_grammar.print_statement(&print_statement_built)?;
        self.push(ASTType::PrintStatement(print_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `PrintStatementList /* Vec<T>::Push */: <INITIAL, Expr>','^ /* Clipped */ Expression PrintStatementList;`
    ///
    #[parol_runtime::function_name::named]
    fn print_statement_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _print_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut print_statement_list =
            pop_item!(self, print_statement_list, PrintStatementList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let print_statement_list_0_built = PrintStatementList { expression };
        // Add an element to the vector
        print_statement_list.push(print_statement_list_0_built);
        self.push(ASTType::PrintStatementList(print_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `PrintStatementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn print_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_statement_list_1_built = Vec::new();
        self.push(
            ASTType::PrintStatementList(print_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `EndStatement: End;`
    ///
    #[parol_runtime::function_name::named]
    fn end_statement(&mut self, _end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let end_statement_built = EndStatement { end };
        // Calling user action here
        self.user_grammar.end_statement(&end_statement_built)?;
        self.push(ASTType::EndStatement(end_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `EndOfLine: <INITIAL, Cmnt, Expr>/(?:\r?\n|\r)+/^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn end_of_line(&mut self, _end_of_line: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_of_line_built = EndOfLine {};
        // Calling user action here
        self.user_grammar.end_of_line(&end_of_line_built)?;
        self.push(ASTType::EndOfLine(end_of_line_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `Literal: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn literal(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let literal_built = Literal { number };
        // Calling user action here
        self.user_grammar.literal(&literal_built)?;
        self.push(ASTType::Literal(literal_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `Number: Float;`
    ///
    #[parol_runtime::function_name::named]
    fn number_0(&mut self, _float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = pop_item!(self, float, Float, context);
        let number_0_built = NumberFloat { float };
        let number_0_built = Number::Float(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `Number: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn number_1(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let number_1_built = NumberInteger { integer };
        let number_1_built = Number::Integer(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `Float: Float1;`
    ///
    #[parol_runtime::function_name::named]
    fn float_0(&mut self, _float1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = pop_item!(self, float1, Float1, context);
        let float_0_built = FloatFloat1 { float1 };
        let float_0_built = Float::Float1(float_0_built);
        // Calling user action here
        self.user_grammar.float(&float_0_built)?;
        self.push(ASTType::Float(float_0_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `Float: Float2;`
    ///
    #[parol_runtime::function_name::named]
    fn float_1(&mut self, _float2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = pop_item!(self, float2, Float2, context);
        let float_1_built = FloatFloat2 { float2 };
        let float_1_built = Float::Float2(float_1_built);
        // Calling user action here
        self.user_grammar.float(&float_1_built)?;
        self.push(ASTType::Float(float_1_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `Float1: <Expr>/(?:(?:[0-9] *)+)?\. *(?:(?:[0-9] *)+)? *(?:E *[-+]? *(?:[0-9] *)+)?/ : BasicNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn float1(&mut self, float1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float1 = float1
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let float1_built = Float1 { float1 };
        // Calling user action here
        self.user_grammar.float1(&float1_built)?;
        self.push(ASTType::Float1(float1_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `Float2: <Expr>/(?:[0-9] *)+E *[-+]? *(?:[0-9] *)+/ : BasicNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn float2(&mut self, float2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float2 = float2
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let float2_built = Float2 { float2 };
        // Calling user action here
        self.user_grammar.float2(&float2_built)?;
        self.push(ASTType::Float2(float2_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `Integer: <Expr>/(?:[0-9] *)+/ : BasicNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `Rem: 'REM'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn rem(&mut self, _rem: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rem_built = Rem {};
        // Calling user action here
        self.user_grammar.rem(&rem_built)?;
        self.push(ASTType::Rem(rem_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `If: 'IF'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn r#if(&mut self, _if: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if_built = If {};
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `Then: <INITIAL, Expr>'THEN'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn then(&mut self, _then: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then_built = Then {};
        // Calling user action here
        self.user_grammar.then(&then_built)?;
        self.push(ASTType::Then(then_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `Goto: <INITIAL, Expr>'GOTO'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn goto(&mut self, _goto: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let goto_built = Goto {};
        // Calling user action here
        self.user_grammar.goto(&goto_built)?;
        self.push(ASTType::Goto(goto_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `Let: 'LET'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn r#let(&mut self, _let: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let_built = Let {};
        // Calling user action here
        self.user_grammar.r#let(&r#let_built)?;
        self.push(ASTType::Let(r#let_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `Print: /PRINT|\?/^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn print(&mut self, _print: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let print_built = Print {};
        // Calling user action here
        self.user_grammar.print(&print_built)?;
        self.push(ASTType::Print(print_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `End: 'END'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, _end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end_built = End {};
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `AssignOp: '='^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_op(&mut self, _assign_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_op_built = AssignOp {};
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_built)?;
        self.push(ASTType::AssignOp(assign_op_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `LogicalOrOp: <Expr>/N?OR/;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_op(&mut self, logical_or_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op = logical_or_op.token()?.clone();
        let logical_or_op_built = LogicalOrOp { logical_or_op };
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `LogicalAndOp: <Expr>'AND';`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_op(&mut self, logical_and_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op = logical_and_op.token()?.clone();
        let logical_and_op_built = LogicalAndOp { logical_and_op };
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `LogicalNotOp: <Expr>'NOT';`
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_op(&mut self, logical_not_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op = logical_not_op.token()?.clone();
        let logical_not_op_built = LogicalNotOp { logical_not_op };
        // Calling user action here
        self.user_grammar.logical_not_op(&logical_not_op_built)?;
        self.push(ASTType::LogicalNotOp(logical_not_op_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `RelationalOp: <Expr>/<\s*>|<\s*=|<|>\s*=|>|=/;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_op(&mut self, relational_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_op = relational_op.token()?.clone();
        let relational_op_built = RelationalOp { relational_op };
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_built)?;
        self.push(ASTType::RelationalOp(relational_op_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `Plus: <Expr>'+';`
    ///
    #[parol_runtime::function_name::named]
    fn plus(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let plus_built = Plus { plus };
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `Minus: <Expr>'-';`
    ///
    #[parol_runtime::function_name::named]
    fn minus(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let minus_built = Minus { minus };
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `MulOp: <Expr>/\*|\u{2F}/;`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op(&mut self, mul_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mul_op = mul_op.token()?.clone();
        let mul_op_built = MulOp { mul_op };
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_built)?;
        self.push(ASTType::MulOp(mul_op_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `LParen: <Expr>'(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, l_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let l_paren_built = LParen { l_paren };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `RParen: <Expr>')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, r_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token()?.clone();
        let r_paren_built = RParen { r_paren };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `Comment: <Cmnt>/[^\r\n]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn comment(&mut self, comment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment = comment.token()?.clone();
        let comment_built = Comment { comment };
        // Calling user action here
        self.user_grammar.comment(&comment_built)?;
        self.push(ASTType::Comment(comment_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Variable: <INITIAL, Expr>/[A-Z][0-9A-Z]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn variable(&mut self, variable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = variable.token()?.clone();
        let variable_built = Variable { variable };
        // Calling user action here
        self.user_grammar.variable(&variable_built)?;
        self.push(ASTType::Variable(variable_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `Expression: LogicalOr;`
    ///
    #[parol_runtime::function_name::named]
    fn expression(&mut self, _logical_or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or = pop_item!(self, logical_or, LogicalOr, context);
        let expression_built = Expression { logical_or };
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `LogicalOr: LogicalAnd LogicalOrList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or(
        &mut self,
        _logical_and: &ParseTreeType<'t>,
        _logical_or_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list = pop_and_reverse_item!(self, logical_or_list, LogicalOrList, context);
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_built = LogicalOr {
            logical_and,
            logical_or_list,
        };
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_built)?;
        self.push(ASTType::LogicalOr(logical_or_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `LogicalOrList /* Vec<T>::Push */: LogicalOrOp LogicalAnd LogicalOrList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_list_0(
        &mut self,
        _logical_or_op: &ParseTreeType<'t>,
        _logical_and: &ParseTreeType<'t>,
        _logical_or_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_or_list = pop_item!(self, logical_or_list, LogicalOrList, context);
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_op = pop_item!(self, logical_or_op, LogicalOrOp, context);
        let logical_or_list_0_built = LogicalOrList {
            logical_and,
            logical_or_op,
        };
        // Add an element to the vector
        logical_or_list.push(logical_or_list_0_built);
        self.push(ASTType::LogicalOrList(logical_or_list), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `LogicalOrList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_list_1_built = Vec::new();
        self.push(ASTType::LogicalOrList(logical_or_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `LogicalAnd: LogicalNot LogicalAndList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and(
        &mut self,
        _logical_not: &ParseTreeType<'t>,
        _logical_and_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list =
            pop_and_reverse_item!(self, logical_and_list, LogicalAndList, context);
        let logical_not = pop_item!(self, logical_not, LogicalNot, context);
        let logical_and_built = LogicalAnd {
            logical_not,
            logical_and_list,
        };
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_built)?;
        self.push(ASTType::LogicalAnd(logical_and_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `LogicalAndList /* Vec<T>::Push */: LogicalAndOp LogicalNot LogicalAndList;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_list_0(
        &mut self,
        _logical_and_op: &ParseTreeType<'t>,
        _logical_not: &ParseTreeType<'t>,
        _logical_and_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut logical_and_list = pop_item!(self, logical_and_list, LogicalAndList, context);
        let logical_not = pop_item!(self, logical_not, LogicalNot, context);
        let logical_and_op = pop_item!(self, logical_and_op, LogicalAndOp, context);
        let logical_and_list_0_built = LogicalAndList {
            logical_not,
            logical_and_op,
        };
        // Add an element to the vector
        logical_and_list.push(logical_and_list_0_built);
        self.push(ASTType::LogicalAndList(logical_and_list), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `LogicalAndList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_list_1_built = Vec::new();
        self.push(ASTType::LogicalAndList(logical_and_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `LogicalNot: LogicalNotOpt /* Option */ Relational;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_not(
        &mut self,
        _logical_not_opt: &ParseTreeType<'t>,
        _relational: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational = pop_item!(self, relational, Relational, context);
        let logical_not_opt = pop_item!(self, logical_not_opt, LogicalNotOpt, context);
        let logical_not_built = LogicalNot {
            logical_not_opt,
            relational,
        };
        // Calling user action here
        self.user_grammar.logical_not(&logical_not_built)?;
        self.push(ASTType::LogicalNot(logical_not_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `LogicalNotOpt /* Option<T>::Some */: LogicalNotOp;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_opt_0(&mut self, _logical_not_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_not_op = pop_item!(self, logical_not_op, LogicalNotOp, context);
        let logical_not_opt_0_built = LogicalNotOpt { logical_not_op };
        self.push(
            ASTType::LogicalNotOpt(Some(logical_not_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `LogicalNotOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_not_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LogicalNotOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `Relational: Summation RelationalList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn relational(
        &mut self,
        _summation: &ParseTreeType<'t>,
        _relational_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list = pop_and_reverse_item!(self, relational_list, RelationalList, context);
        let summation = pop_item!(self, summation, Summation, context);
        let relational_built = Relational {
            summation,
            relational_list,
        };
        // Calling user action here
        self.user_grammar.relational(&relational_built)?;
        self.push(ASTType::Relational(relational_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `RelationalList /* Vec<T>::Push */: RelationalOp Summation RelationalList;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_list_0(
        &mut self,
        _relational_op: &ParseTreeType<'t>,
        _summation: &ParseTreeType<'t>,
        _relational_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut relational_list = pop_item!(self, relational_list, RelationalList, context);
        let summation = pop_item!(self, summation, Summation, context);
        let relational_op = pop_item!(self, relational_op, RelationalOp, context);
        let relational_list_0_built = RelationalList {
            summation,
            relational_op,
        };
        // Add an element to the vector
        relational_list.push(relational_list_0_built);
        self.push(ASTType::RelationalList(relational_list), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `RelationalList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_list_1_built = Vec::new();
        self.push(ASTType::RelationalList(relational_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `Summation: Multiplication SummationList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn summation(
        &mut self,
        _multiplication: &ParseTreeType<'t>,
        _summation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list = pop_and_reverse_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_built = Summation {
            multiplication,
            summation_list,
        };
        // Calling user action here
        self.user_grammar.summation(&summation_built)?;
        self.push(ASTType::Summation(summation_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `SummationList /* Vec<T>::Push */: SummationListGroup Multiplication SummationList;`
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_0(
        &mut self,
        _summation_list_group: &ParseTreeType<'t>,
        _multiplication: &ParseTreeType<'t>,
        _summation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list = pop_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_list_group =
            pop_item!(self, summation_list_group, SummationListGroup, context);
        let summation_list_0_built = SummationList {
            multiplication,
            summation_list_group,
        };
        // Add an element to the vector
        summation_list.push(summation_list_0_built);
        self.push(ASTType::SummationList(summation_list), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `SummationListGroup: Plus;`
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_0(&mut self, _plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let summation_list_group_0_built = SummationListGroupPlus { plus };
        let summation_list_group_0_built = SummationListGroup::Plus(summation_list_group_0_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `SummationListGroup: Minus;`
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_1(&mut self, _minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let summation_list_group_1_built = SummationListGroupMinus { minus };
        let summation_list_group_1_built = SummationListGroup::Minus(summation_list_group_1_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `SummationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `Multiplication: Factor MultiplicationList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn multiplication(
        &mut self,
        _factor: &ParseTreeType<'t>,
        _multiplication_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list =
            pop_and_reverse_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let multiplication_built = Multiplication {
            factor,
            multiplication_list,
        };
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_built)?;
        self.push(ASTType::Multiplication(multiplication_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `MultiplicationList /* Vec<T>::Push */: MulOp Factor MultiplicationList;`
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_0(
        &mut self,
        _mul_op: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _multiplication_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list =
            pop_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_op = pop_item!(self, mul_op, MulOp, context);
        let multiplication_list_0_built = MultiplicationList { factor, mul_op };
        // Add an element to the vector
        multiplication_list.push(multiplication_list_0_built);
        self.push(ASTType::MultiplicationList(multiplication_list), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `MultiplicationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `Factor: Literal;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let literal = pop_item!(self, literal, Literal, context);
        let factor_0_built = FactorLiteral { literal };
        let factor_0_built = Factor::Literal(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `Factor: Variable;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _variable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = pop_item!(self, variable, Variable, context);
        let factor_1_built = FactorVariable { variable };
        let factor_1_built = Factor::Variable(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `Factor: Minus Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(&mut self, _minus: &ParseTreeType<'t>, _factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let minus = pop_item!(self, minus, Minus, context);
        let factor_2_built = FactorMinusFactor {
            minus,
            factor: Box::new(factor),
        };
        let factor_2_built = Factor::MinusFactor(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `Factor: LParen Expression RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_3_built = FactorLParenExpressionRParen {
            l_paren,
            expression: Box::new(expression),
            r_paren,
        };
        let factor_3_built = Factor::LParenExpressionRParen(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for BasicGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item BasicGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.basic(&children[0], &children[1], &children[2], &children[3]),
            1 => self.basic_list_0(&children[0], &children[1], &children[2]),
            2 => self.basic_list_1(),
            3 => self.basic_opt0_0(&children[0]),
            4 => self.basic_opt0_1(),
            5 => self.basic_opt_0(&children[0]),
            6 => self.basic_opt_1(),
            7 => self.line(&children[0], &children[1], &children[2]),
            8 => self.line_list_0(&children[0], &children[1], &children[2]),
            9 => self.line_list_1(),
            10 => self.line_number(&children[0]),
            11 => self.statement_0(&children[0]),
            12 => self.statement_1(&children[0]),
            13 => self.statement_2(&children[0]),
            14 => self.statement_3(&children[0]),
            15 => self.statement_4(&children[0]),
            16 => self.statement_5(&children[0]),
            17 => self.remark(&children[0], &children[1]),
            18 => self.remark_opt_0(&children[0]),
            19 => self.remark_opt_1(),
            20 => self.goto_statement(&children[0], &children[1]),
            21 => self.if_statement(&children[0], &children[1], &children[2]),
            22 => self.assignment(&children[0], &children[1], &children[2], &children[3]),
            23 => self.assignment_opt_0(&children[0]),
            24 => self.assignment_opt_1(),
            25 => self.if_body_0(&children[0], &children[1]),
            26 => self.if_body_1(&children[0], &children[1]),
            27 => self.print_statement(&children[0], &children[1], &children[2]),
            28 => self.print_statement_list_0(&children[0], &children[1], &children[2]),
            29 => self.print_statement_list_1(),
            30 => self.end_statement(&children[0]),
            31 => self.end_of_line(&children[0]),
            32 => self.literal(&children[0]),
            33 => self.number_0(&children[0]),
            34 => self.number_1(&children[0]),
            35 => self.float_0(&children[0]),
            36 => self.float_1(&children[0]),
            37 => self.float1(&children[0]),
            38 => self.float2(&children[0]),
            39 => self.integer(&children[0]),
            40 => self.rem(&children[0]),
            41 => self.r#if(&children[0]),
            42 => self.then(&children[0]),
            43 => self.goto(&children[0]),
            44 => self.r#let(&children[0]),
            45 => self.print(&children[0]),
            46 => self.end(&children[0]),
            47 => self.assign_op(&children[0]),
            48 => self.logical_or_op(&children[0]),
            49 => self.logical_and_op(&children[0]),
            50 => self.logical_not_op(&children[0]),
            51 => self.relational_op(&children[0]),
            52 => self.plus(&children[0]),
            53 => self.minus(&children[0]),
            54 => self.mul_op(&children[0]),
            55 => self.l_paren(&children[0]),
            56 => self.r_paren(&children[0]),
            57 => self.comment(&children[0]),
            58 => self.variable(&children[0]),
            59 => self.expression(&children[0]),
            60 => self.logical_or(&children[0], &children[1]),
            61 => self.logical_or_list_0(&children[0], &children[1], &children[2]),
            62 => self.logical_or_list_1(),
            63 => self.logical_and(&children[0], &children[1]),
            64 => self.logical_and_list_0(&children[0], &children[1], &children[2]),
            65 => self.logical_and_list_1(),
            66 => self.logical_not(&children[0], &children[1]),
            67 => self.logical_not_opt_0(&children[0]),
            68 => self.logical_not_opt_1(),
            69 => self.relational(&children[0], &children[1]),
            70 => self.relational_list_0(&children[0], &children[1], &children[2]),
            71 => self.relational_list_1(),
            72 => self.summation(&children[0], &children[1]),
            73 => self.summation_list_0(&children[0], &children[1], &children[2]),
            74 => self.summation_list_group_0(&children[0]),
            75 => self.summation_list_group_1(&children[0]),
            76 => self.summation_list_1(),
            77 => self.multiplication(&children[0], &children[1]),
            78 => self.multiplication_list_0(&children[0], &children[1], &children[2]),
            79 => self.multiplication_list_1(),
            80 => self.factor_0(&children[0]),
            81 => self.factor_1(&children[0]),
            82 => self.factor_2(&children[0], &children[1]),
            83 => self.factor_3(&children[0], &children[1], &children[2]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
