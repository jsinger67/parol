// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait CalcGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Calc'
    fn calc(&mut self, _arg: &Calc<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CalcLst1'
    fn calc_lst1(&mut self, _arg: &CalcLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CalcLst1Itm1'
    fn calc_lst1_itm1(&mut self, _arg: &CalcLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Instruction'
    fn instruction(&mut self, _arg: &Instruction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EqualityOp'
    fn equality_op(&mut self, _arg: &EqualityOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignOp'
    fn assign_op(&mut self, _arg: &AssignOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignItem'
    fn assign_item(&mut self, _arg: &AssignItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentLst1'
    fn assignment_lst1(&mut self, _arg: &AssignmentLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentLst1Itm1'
    fn assignment_lst1_itm1(&mut self, _arg: &AssignmentLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOr'
    fn logical_or(&mut self, _arg: &LogicalOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrLst1'
    fn logical_or_lst1(&mut self, _arg: &LogicalOrLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrLst1Itm1'
    fn logical_or_lst1_itm1(&mut self, _arg: &LogicalOrLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrOp'
    fn logical_or_op(&mut self, _arg: &LogicalOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalOrItem'
    fn logical_or_item(&mut self, _arg: &LogicalOrItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAnd'
    fn logical_and(&mut self, _arg: &LogicalAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndLst1'
    fn logical_and_lst1(&mut self, _arg: &LogicalAndLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndLst1Itm1'
    fn logical_and_lst1_itm1(&mut self, _arg: &LogicalAndLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndOp'
    fn logical_and_op(&mut self, _arg: &LogicalAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicalAndItem'
    fn logical_and_item(&mut self, _arg: &LogicalAndItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseOr'
    fn bitwise_or(&mut self, _arg: &BitwiseOr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseOrLst1'
    fn bitwise_or_lst1(&mut self, _arg: &BitwiseOrLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseOrLst1Itm1'
    fn bitwise_or_lst1_itm1(&mut self, _arg: &BitwiseOrLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseOrOp'
    fn bitwise_or_op(&mut self, _arg: &BitwiseOrOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseOrItem'
    fn bitwise_or_item(&mut self, _arg: &BitwiseOrItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseAnd'
    fn bitwise_and(&mut self, _arg: &BitwiseAnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseAndLst1'
    fn bitwise_and_lst1(&mut self, _arg: &BitwiseAndLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseAndLst1Itm1'
    fn bitwise_and_lst1_itm1(&mut self, _arg: &BitwiseAndLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseAndOp'
    fn bitwise_and_op(&mut self, _arg: &BitwiseAndOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseAndItem'
    fn bitwise_and_item(&mut self, _arg: &BitwiseAndItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equality'
    fn equality(&mut self, _arg: &Equality<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EqualityLst1'
    fn equality_lst1(&mut self, _arg: &EqualityLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EqualityLst1Itm1'
    fn equality_lst1_itm1(&mut self, _arg: &EqualityLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EqualityItem'
    fn equality_item(&mut self, _arg: &EqualityItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseShiftOp'
    fn bitwise_shift_op(&mut self, _arg: &BitwiseShiftOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relational'
    fn relational(&mut self, _arg: &Relational<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalLst1'
    fn relational_lst1(&mut self, _arg: &RelationalLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalLst1Itm1'
    fn relational_lst1_itm1(&mut self, _arg: &RelationalLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalOp'
    fn relational_op(&mut self, _arg: &RelationalOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RelationalItem'
    fn relational_item(&mut self, _arg: &RelationalItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseShift'
    fn bitwise_shift(&mut self, _arg: &BitwiseShift<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseShiftLst1'
    fn bitwise_shift_lst1(&mut self, _arg: &BitwiseShiftLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseShiftLst1Itm1'
    fn bitwise_shift_lst1_itm1(&mut self, _arg: &BitwiseShiftLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitwiseShiftItem'
    fn bitwise_shift_item(&mut self, _arg: &BitwiseShiftItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Summ'
    fn summ(&mut self, _arg: &Summ<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SummLst1'
    fn summ_lst1(&mut self, _arg: &SummLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SummLst1Itm1'
    fn summ_lst1_itm1(&mut self, _arg: &SummLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AddOp'
    fn add_op(&mut self, _arg: &AddOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SummItem'
    fn summ_item(&mut self, _arg: &SummItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PowOp'
    fn pow_op(&mut self, _arg: &PowOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Mult'
    fn mult(&mut self, _arg: &Mult<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MultLst1'
    fn mult_lst1(&mut self, _arg: &MultLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MultLst1Itm1'
    fn mult_lst1_itm1(&mut self, _arg: &MultLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MultOp'
    fn mult_op(&mut self, _arg: &MultOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MultItem'
    fn mult_item(&mut self, _arg: &MultItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Power'
    fn power(&mut self, _arg: &Power<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PowerLst1'
    fn power_lst1(&mut self, _arg: &PowerLst1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PowerLst1Itm1'
    fn power_lst1_itm1(&mut self, _arg: &PowerLst1Itm1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negate'
    fn negate(&mut self, _arg: &Negate<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdRef'
    fn id_ref(&mut self, _arg: &IdRef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Id'
    fn id(&mut self, _arg: &Id<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 1
///
/// `CalcLst1: CalcLst1Itm1 CalcLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CalcLst1CalcLst1Itm1CalcLst1<'t> {
    pub calc_lst1_itm1: Box<CalcLst1Itm1<'t>>,
    pub calc_lst1: Box<CalcLst1<'t>>,
}

///
/// Type derived for production 3
///
/// `CalcLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CalcLst1CalcLst1Empty {}

///
/// Type derived for production 4
///
/// `Instruction: Assignment;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstructionAssignment<'t> {
    pub assignment: Box<Assignment<'t>>,
}

///
/// Type derived for production 5
///
/// `Instruction: LogicalOr;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstructionLogicalOr<'t> {
    pub logical_or: Box<LogicalOr<'t>>,
}

///
/// Type derived for production 10
///
/// `AssignmentLst1: AssignmentLst1Itm1 AssignmentLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentLst1AssignmentLst1Itm1AssignmentLst1<'t> {
    pub assignment_lst1_itm1: Box<AssignmentLst1Itm1<'t>>,
    pub assignment_lst1: Box<AssignmentLst1<'t>>,
}

///
/// Type derived for production 12
///
/// `AssignmentLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentLst1AssignmentLst1Empty {}

///
/// Type derived for production 14
///
/// `LogicalOrLst1: LogicalOrLst1Itm1 LogicalOrLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrLst1LogicalOrLst1Itm1LogicalOrLst1<'t> {
    pub logical_or_lst1_itm1: Box<LogicalOrLst1Itm1<'t>>,
    pub logical_or_lst1: Box<LogicalOrLst1<'t>>,
}

///
/// Type derived for production 16
///
/// `LogicalOrLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrLst1LogicalOrLst1Empty {}

///
/// Type derived for production 20
///
/// `LogicalAndLst1: LogicalAndLst1Itm1 LogicalAndLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndLst1LogicalAndLst1Itm1LogicalAndLst1<'t> {
    pub logical_and_lst1_itm1: Box<LogicalAndLst1Itm1<'t>>,
    pub logical_and_lst1: Box<LogicalAndLst1<'t>>,
}

///
/// Type derived for production 22
///
/// `LogicalAndLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndLst1LogicalAndLst1Empty {}

///
/// Type derived for production 26
///
/// `BitwiseOrLst1: BitwiseOrLst1Itm1 BitwiseOrLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOrLst1BitwiseOrLst1Itm1BitwiseOrLst1<'t> {
    pub bitwise_or_lst1_itm1: Box<BitwiseOrLst1Itm1<'t>>,
    pub bitwise_or_lst1: Box<BitwiseOrLst1<'t>>,
}

///
/// Type derived for production 28
///
/// `BitwiseOrLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOrLst1BitwiseOrLst1Empty {}

///
/// Type derived for production 32
///
/// `BitwiseAndLst1: BitwiseAndLst1Itm1 BitwiseAndLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAndLst1BitwiseAndLst1Itm1BitwiseAndLst1<'t> {
    pub bitwise_and_lst1_itm1: Box<BitwiseAndLst1Itm1<'t>>,
    pub bitwise_and_lst1: Box<BitwiseAndLst1<'t>>,
}

///
/// Type derived for production 34
///
/// `BitwiseAndLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAndLst1BitwiseAndLst1Empty {}

///
/// Type derived for production 38
///
/// `EqualityLst1: EqualityLst1Itm1 EqualityLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualityLst1EqualityLst1Itm1EqualityLst1<'t> {
    pub equality_lst1_itm1: Box<EqualityLst1Itm1<'t>>,
    pub equality_lst1: Box<EqualityLst1<'t>>,
}

///
/// Type derived for production 40
///
/// `EqualityLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualityLst1EqualityLst1Empty {}

///
/// Type derived for production 44
///
/// `RelationalLst1: RelationalLst1Itm1 RelationalLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalLst1RelationalLst1Itm1RelationalLst1<'t> {
    pub relational_lst1_itm1: Box<RelationalLst1Itm1<'t>>,
    pub relational_lst1: Box<RelationalLst1<'t>>,
}

///
/// Type derived for production 46
///
/// `RelationalLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalLst1RelationalLst1Empty {}

///
/// Type derived for production 50
///
/// `BitwiseShiftLst1: BitwiseShiftLst1Itm1 BitwiseShiftLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShiftLst1BitwiseShiftLst1Itm1BitwiseShiftLst1<'t> {
    pub bitwise_shift_lst1_itm1: Box<BitwiseShiftLst1Itm1<'t>>,
    pub bitwise_shift_lst1: Box<BitwiseShiftLst1<'t>>,
}

///
/// Type derived for production 52
///
/// `BitwiseShiftLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShiftLst1BitwiseShiftLst1Empty {}

///
/// Type derived for production 55
///
/// `SummLst1: SummLst1Itm1 SummLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummLst1SummLst1Itm1SummLst1<'t> {
    pub summ_lst1_itm1: Box<SummLst1Itm1<'t>>,
    pub summ_lst1: Box<SummLst1<'t>>,
}

///
/// Type derived for production 57
///
/// `SummLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummLst1SummLst1Empty {}

///
/// Type derived for production 60
///
/// `AddOp: Plus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOpPlus<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 61
///
/// `AddOp: Minus;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOpMinus<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 65
///
/// `MultLst1: MultLst1Itm1 MultLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultLst1MultLst1Itm1MultLst1<'t> {
    pub mult_lst1_itm1: Box<MultLst1Itm1<'t>>,
    pub mult_lst1: Box<MultLst1<'t>>,
}

///
/// Type derived for production 67
///
/// `MultLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultLst1MultLst1Empty {}

///
/// Type derived for production 71
///
/// `PowerLst1: PowerLst1Itm1 PowerLst1;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PowerLst1PowerLst1Itm1PowerLst1<'t> {
    pub power_lst1_itm1: Box<PowerLst1Itm1<'t>>,
    pub power_lst1: Box<PowerLst1<'t>>,
}

///
/// Type derived for production 73
///
/// `PowerLst1: ;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PowerLst1PowerLst1Empty {}

///
/// Type derived for production 75
///
/// `Factor: Number;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNumber<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 76
///
/// `Factor: IdRef;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorIdRef<'t> {
    pub id_ref: Box<IdRef<'t>>,
}

///
/// Type derived for production 77
///
/// `Factor: Negate Factor;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNegateFactor<'t> {
    pub negate: Box<Negate<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 78
///
/// `Factor: "\(" LogicalOr "\)";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenLogicalOrRParen<'t> {
    pub l_paren: Token<'t>, /* \( */
    pub logical_or: Box<LogicalOr<'t>>,
    pub r_paren: Token<'t>, /* \) */
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AddOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOp<'t> {
    Plus(AddOpPlus<'t>),
    Minus(AddOpMinus<'t>),
}

///
/// Type derived for non-terminal AssignItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignItem<'t> {
    pub id: Box<Id<'t>>,
    pub assign_op: Box<AssignOp<'t>>,
}

///
/// Type derived for non-terminal AssignOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignOp<'t> {
    pub assign_op: Token<'t>, /* (\+|-|\*|/|%|<<|>>|&|\^|\|)?= */
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assignment<'t> {
    pub assign_item: Box<AssignItem<'t>>,
    pub assignment_lst1: Box<AssignmentLst1<'t>>,
    pub logical_or: Box<LogicalOr<'t>>,
}

///
/// Type derived for non-terminal AssignmentLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AssignmentLst1<'t> {
    AssignmentLst1Itm1AssignmentLst1(AssignmentLst1AssignmentLst1Itm1AssignmentLst1<'t>),
    AssignmentLst1Empty(AssignmentLst1AssignmentLst1Empty),
}

///
/// Type derived for non-terminal AssignmentLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentLst1Itm1<'t> {
    pub assign_item: Box<AssignItem<'t>>,
}

///
/// Type derived for non-terminal BitwiseAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAnd<'t> {
    pub equality: Box<Equality<'t>>,
    pub bitwise_and_lst1: Box<BitwiseAndLst1<'t>>,
}

///
/// Type derived for non-terminal BitwiseAndItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAndItem<'t> {
    pub bitwise_and_op: Box<BitwiseAndOp<'t>>,
    pub equality: Box<Equality<'t>>,
}

///
/// Type derived for non-terminal BitwiseAndLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BitwiseAndLst1<'t> {
    BitwiseAndLst1Itm1BitwiseAndLst1(BitwiseAndLst1BitwiseAndLst1Itm1BitwiseAndLst1<'t>),
    BitwiseAndLst1Empty(BitwiseAndLst1BitwiseAndLst1Empty),
}

///
/// Type derived for non-terminal BitwiseAndLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAndLst1Itm1<'t> {
    pub bitwise_and_item: Box<BitwiseAndItem<'t>>,
}

///
/// Type derived for non-terminal BitwiseAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseAndOp<'t> {
    pub bitwise_and_op: Token<'t>, /* & */
}

///
/// Type derived for non-terminal BitwiseOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOr<'t> {
    pub bitwise_and: Box<BitwiseAnd<'t>>,
    pub bitwise_or_lst1: Box<BitwiseOrLst1<'t>>,
}

///
/// Type derived for non-terminal BitwiseOrItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOrItem<'t> {
    pub bitwise_or_op: Box<BitwiseOrOp<'t>>,
    pub bitwise_and: Box<BitwiseAnd<'t>>,
}

///
/// Type derived for non-terminal BitwiseOrLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BitwiseOrLst1<'t> {
    BitwiseOrLst1Itm1BitwiseOrLst1(BitwiseOrLst1BitwiseOrLst1Itm1BitwiseOrLst1<'t>),
    BitwiseOrLst1Empty(BitwiseOrLst1BitwiseOrLst1Empty),
}

///
/// Type derived for non-terminal BitwiseOrLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOrLst1Itm1<'t> {
    pub bitwise_or_item: Box<BitwiseOrItem<'t>>,
}

///
/// Type derived for non-terminal BitwiseOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseOrOp<'t> {
    pub bitwise_or_op: Token<'t>, /* \| */
}

///
/// Type derived for non-terminal BitwiseShift
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShift<'t> {
    pub summ: Box<Summ<'t>>,
    pub bitwise_shift_lst1: Box<BitwiseShiftLst1<'t>>,
}

///
/// Type derived for non-terminal BitwiseShiftItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShiftItem<'t> {
    pub bitwise_shift_op: Box<BitwiseShiftOp<'t>>,
    pub summ: Box<Summ<'t>>,
}

///
/// Type derived for non-terminal BitwiseShiftLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BitwiseShiftLst1<'t> {
    BitwiseShiftLst1Itm1BitwiseShiftLst1(BitwiseShiftLst1BitwiseShiftLst1Itm1BitwiseShiftLst1<'t>),
    BitwiseShiftLst1Empty(BitwiseShiftLst1BitwiseShiftLst1Empty),
}

///
/// Type derived for non-terminal BitwiseShiftLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShiftLst1Itm1<'t> {
    pub bitwise_shift_item: Box<BitwiseShiftItem<'t>>,
}

///
/// Type derived for non-terminal BitwiseShiftOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitwiseShiftOp<'t> {
    pub bitwise_shift_op: Token<'t>, /* <<|>> */
}

///
/// Type derived for non-terminal Calc
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Calc<'t> {
    pub calc_lst1: Box<CalcLst1<'t>>,
}

///
/// Type derived for non-terminal CalcLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CalcLst1<'t> {
    CalcLst1Itm1CalcLst1(CalcLst1CalcLst1Itm1CalcLst1<'t>),
    CalcLst1Empty(CalcLst1CalcLst1Empty),
}

///
/// Type derived for non-terminal CalcLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CalcLst1Itm1<'t> {
    pub instruction: Box<Instruction<'t>>,
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal Equality
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equality<'t> {
    pub relational: Box<Relational<'t>>,
    pub equality_lst1: Box<EqualityLst1<'t>>,
}

///
/// Type derived for non-terminal EqualityItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualityItem<'t> {
    pub equality_op: Box<EqualityOp<'t>>,
    pub relational: Box<Relational<'t>>,
}

///
/// Type derived for non-terminal EqualityLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EqualityLst1<'t> {
    EqualityLst1Itm1EqualityLst1(EqualityLst1EqualityLst1Itm1EqualityLst1<'t>),
    EqualityLst1Empty(EqualityLst1EqualityLst1Empty),
}

///
/// Type derived for non-terminal EqualityLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualityLst1Itm1<'t> {
    pub equality_item: Box<EqualityItem<'t>>,
}

///
/// Type derived for non-terminal EqualityOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualityOp<'t> {
    pub equality_op: Token<'t>, /* ==|!= */
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Number(FactorNumber<'t>),
    IdRef(FactorIdRef<'t>),
    NegateFactor(FactorNegateFactor<'t>),
    LParenLogicalOrRParen(FactorLParenLogicalOrRParen<'t>),
}

///
/// Type derived for non-terminal Id
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Id<'t> {
    pub id: Token<'t>, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal IdRef
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdRef<'t> {
    pub id: Box<Id<'t>>,
}

///
/// Type derived for non-terminal Instruction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Instruction<'t> {
    Assignment(InstructionAssignment<'t>),
    LogicalOr(InstructionLogicalOr<'t>),
}

///
/// Type derived for non-terminal LogicalAnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAnd<'t> {
    pub bitwise_or: Box<BitwiseOr<'t>>,
    pub logical_and_lst1: Box<LogicalAndLst1<'t>>,
}

///
/// Type derived for non-terminal LogicalAndItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndItem<'t> {
    pub logical_and_op: Box<LogicalAndOp<'t>>,
    pub bitwise_or: Box<BitwiseOr<'t>>,
}

///
/// Type derived for non-terminal LogicalAndLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalAndLst1<'t> {
    LogicalAndLst1Itm1LogicalAndLst1(LogicalAndLst1LogicalAndLst1Itm1LogicalAndLst1<'t>),
    LogicalAndLst1Empty(LogicalAndLst1LogicalAndLst1Empty),
}

///
/// Type derived for non-terminal LogicalAndLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndLst1Itm1<'t> {
    pub logical_and_item: Box<LogicalAndItem<'t>>,
}

///
/// Type derived for non-terminal LogicalAndOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAndOp<'t> {
    pub logical_and_op: Token<'t>, /* && */
}

///
/// Type derived for non-terminal LogicalOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOr<'t> {
    pub logical_and: Box<LogicalAnd<'t>>,
    pub logical_or_lst1: Box<LogicalOrLst1<'t>>,
}

///
/// Type derived for non-terminal LogicalOrItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrItem<'t> {
    pub logical_or_op: Box<LogicalOrOp<'t>>,
    pub logical_and: Box<LogicalAnd<'t>>,
}

///
/// Type derived for non-terminal LogicalOrLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LogicalOrLst1<'t> {
    LogicalOrLst1Itm1LogicalOrLst1(LogicalOrLst1LogicalOrLst1Itm1LogicalOrLst1<'t>),
    LogicalOrLst1Empty(LogicalOrLst1LogicalOrLst1Empty),
}

///
/// Type derived for non-terminal LogicalOrLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrLst1Itm1<'t> {
    pub logical_or_item: Box<LogicalOrItem<'t>>,
}

///
/// Type derived for non-terminal LogicalOrOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOrOp<'t> {
    pub logical_or_op: Token<'t>, /* \|\| */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for non-terminal Mult
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Mult<'t> {
    pub power: Box<Power<'t>>,
    pub mult_lst1: Box<MultLst1<'t>>,
}

///
/// Type derived for non-terminal MultItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultItem<'t> {
    pub mult_op: Box<MultOp<'t>>,
    pub power: Box<Power<'t>>,
}

///
/// Type derived for non-terminal MultLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MultLst1<'t> {
    MultLst1Itm1MultLst1(MultLst1MultLst1Itm1MultLst1<'t>),
    MultLst1Empty(MultLst1MultLst1Empty),
}

///
/// Type derived for non-terminal MultLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultLst1Itm1<'t> {
    pub mult_item: Box<MultItem<'t>>,
}

///
/// Type derived for non-terminal MultOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultOp<'t> {
    pub mult_op: Token<'t>, /* \*|/|% */
}

///
/// Type derived for non-terminal Negate
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Negate<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Number<'t> {
    pub number: Token<'t>, /* 0|[1-9][0-9]* */
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal PowOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PowOp<'t> {
    pub pow_op: Token<'t>, /* \*\* */
}

///
/// Type derived for non-terminal Power
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Power<'t> {
    pub factor: Box<Factor<'t>>,
    pub power_lst1: Box<PowerLst1<'t>>,
}

///
/// Type derived for non-terminal PowerLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PowerLst1<'t> {
    PowerLst1Itm1PowerLst1(PowerLst1PowerLst1Itm1PowerLst1<'t>),
    PowerLst1Empty(PowerLst1PowerLst1Empty),
}

///
/// Type derived for non-terminal PowerLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PowerLst1Itm1<'t> {
    pub pow_op: Box<PowOp<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Relational
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Relational<'t> {
    pub bitwise_shift: Box<BitwiseShift<'t>>,
    pub relational_lst1: Box<RelationalLst1<'t>>,
}

///
/// Type derived for non-terminal RelationalItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalItem<'t> {
    pub relational_op: Box<RelationalOp<'t>>,
    pub bitwise_shift: Box<BitwiseShift<'t>>,
}

///
/// Type derived for non-terminal RelationalLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RelationalLst1<'t> {
    RelationalLst1Itm1RelationalLst1(RelationalLst1RelationalLst1Itm1RelationalLst1<'t>),
    RelationalLst1Empty(RelationalLst1RelationalLst1Empty),
}

///
/// Type derived for non-terminal RelationalLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalLst1Itm1<'t> {
    pub relational_item: Box<RelationalItem<'t>>,
}

///
/// Type derived for non-terminal RelationalOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationalOp<'t> {
    pub relational_op: Token<'t>, /* <=|<|>=|> */
}

///
/// Type derived for non-terminal Summ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Summ<'t> {
    pub mult: Box<Mult<'t>>,
    pub summ_lst1: Box<SummLst1<'t>>,
}

///
/// Type derived for non-terminal SummItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummItem<'t> {
    pub add_op: Box<AddOp<'t>>,
    pub mult: Box<Mult<'t>>,
}

///
/// Type derived for non-terminal SummLst1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummLst1<'t> {
    SummLst1Itm1SummLst1(SummLst1SummLst1Itm1SummLst1<'t>),
    SummLst1Empty(SummLst1SummLst1Empty),
}

///
/// Type derived for non-terminal SummLst1Itm1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummLst1Itm1<'t> {
    pub summ_item: Box<SummItem<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AddOp(AddOp<'t>),
    AssignItem(AssignItem<'t>),
    AssignOp(AssignOp<'t>),
    Assignment(Assignment<'t>),
    AssignmentLst1(AssignmentLst1<'t>),
    AssignmentLst1Itm1(AssignmentLst1Itm1<'t>),
    BitwiseAnd(BitwiseAnd<'t>),
    BitwiseAndItem(BitwiseAndItem<'t>),
    BitwiseAndLst1(BitwiseAndLst1<'t>),
    BitwiseAndLst1Itm1(BitwiseAndLst1Itm1<'t>),
    BitwiseAndOp(BitwiseAndOp<'t>),
    BitwiseOr(BitwiseOr<'t>),
    BitwiseOrItem(BitwiseOrItem<'t>),
    BitwiseOrLst1(BitwiseOrLst1<'t>),
    BitwiseOrLst1Itm1(BitwiseOrLst1Itm1<'t>),
    BitwiseOrOp(BitwiseOrOp<'t>),
    BitwiseShift(BitwiseShift<'t>),
    BitwiseShiftItem(BitwiseShiftItem<'t>),
    BitwiseShiftLst1(BitwiseShiftLst1<'t>),
    BitwiseShiftLst1Itm1(BitwiseShiftLst1Itm1<'t>),
    BitwiseShiftOp(BitwiseShiftOp<'t>),
    Calc(Calc<'t>),
    CalcLst1(CalcLst1<'t>),
    CalcLst1Itm1(CalcLst1Itm1<'t>),
    Equality(Equality<'t>),
    EqualityItem(EqualityItem<'t>),
    EqualityLst1(EqualityLst1<'t>),
    EqualityLst1Itm1(EqualityLst1Itm1<'t>),
    EqualityOp(EqualityOp<'t>),
    Factor(Factor<'t>),
    Id(Id<'t>),
    IdRef(IdRef<'t>),
    Instruction(Instruction<'t>),
    LogicalAnd(LogicalAnd<'t>),
    LogicalAndItem(LogicalAndItem<'t>),
    LogicalAndLst1(LogicalAndLst1<'t>),
    LogicalAndLst1Itm1(LogicalAndLst1Itm1<'t>),
    LogicalAndOp(LogicalAndOp<'t>),
    LogicalOr(LogicalOr<'t>),
    LogicalOrItem(LogicalOrItem<'t>),
    LogicalOrLst1(LogicalOrLst1<'t>),
    LogicalOrLst1Itm1(LogicalOrLst1Itm1<'t>),
    LogicalOrOp(LogicalOrOp<'t>),
    Minus(Minus<'t>),
    Mult(Mult<'t>),
    MultItem(MultItem<'t>),
    MultLst1(MultLst1<'t>),
    MultLst1Itm1(MultLst1Itm1<'t>),
    MultOp(MultOp<'t>),
    Negate(Negate<'t>),
    Number(Number<'t>),
    Plus(Plus<'t>),
    PowOp(PowOp<'t>),
    Power(Power<'t>),
    PowerLst1(PowerLst1<'t>),
    PowerLst1Itm1(PowerLst1Itm1<'t>),
    Relational(Relational<'t>),
    RelationalItem(RelationalItem<'t>),
    RelationalLst1(RelationalLst1<'t>),
    RelationalLst1Itm1(RelationalLst1Itm1<'t>),
    RelationalOp(RelationalOp<'t>),
    Summ(Summ<'t>),
    SummItem(SummItem<'t>),
    SummLst1(SummLst1<'t>),
    SummLst1Itm1(SummLst1Itm1<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct CalcGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn CalcGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `CalcGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> CalcGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn CalcGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Calc: CalcLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn calc(&mut self, _calc_lst1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let calc_lst1 = pop_item!(self, calc_lst1, CalcLst1, context);
        let calc_built = Calc {
            calc_lst1: Box::new(calc_lst1),
        };
        // Calling user action here
        self.user_grammar.calc(&calc_built)?;
        self.push(ASTType::Calc(calc_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `CalcLst1: CalcLst1Itm1 CalcLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn calc_lst1_0(
        &mut self,
        _calc_lst1_itm1: &ParseTreeType<'t>,
        _calc_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let calc_lst1 = pop_item!(self, calc_lst1, CalcLst1, context);
        let calc_lst1_itm1 = pop_item!(self, calc_lst1_itm1, CalcLst1Itm1, context);
        let calc_lst1_0_built = CalcLst1CalcLst1Itm1CalcLst1 {
            calc_lst1_itm1: Box::new(calc_lst1_itm1),
            calc_lst1: Box::new(calc_lst1),
        };
        let calc_lst1_0_built = CalcLst1::CalcLst1Itm1CalcLst1(calc_lst1_0_built);
        // Calling user action here
        self.user_grammar.calc_lst1(&calc_lst1_0_built)?;
        self.push(ASTType::CalcLst1(calc_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `CalcLst1Itm1: Instruction ";";`
    ///
    #[parol_runtime::function_name::named]
    fn calc_lst1_itm1(
        &mut self,
        _instruction: &ParseTreeType<'t>,
        semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token()?.clone();
        let instruction = pop_item!(self, instruction, Instruction, context);
        let calc_lst1_itm1_built = CalcLst1Itm1 {
            instruction: Box::new(instruction),
            semicolon,
        };
        // Calling user action here
        self.user_grammar.calc_lst1_itm1(&calc_lst1_itm1_built)?;
        self.push(ASTType::CalcLst1Itm1(calc_lst1_itm1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `CalcLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn calc_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let calc_lst1_1_built = CalcLst1CalcLst1Empty {};
        let calc_lst1_1_built = CalcLst1::CalcLst1Empty(calc_lst1_1_built);
        // Calling user action here
        self.user_grammar.calc_lst1(&calc_lst1_1_built)?;
        self.push(ASTType::CalcLst1(calc_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `Instruction: Assignment;`
    ///
    #[parol_runtime::function_name::named]
    fn instruction_0(&mut self, _assignment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let instruction_0_built = InstructionAssignment {
            assignment: Box::new(assignment),
        };
        let instruction_0_built = Instruction::Assignment(instruction_0_built);
        // Calling user action here
        self.user_grammar.instruction(&instruction_0_built)?;
        self.push(ASTType::Instruction(instruction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Instruction: LogicalOr;`
    ///
    #[parol_runtime::function_name::named]
    fn instruction_1(&mut self, _logical_or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or = pop_item!(self, logical_or, LogicalOr, context);
        let instruction_1_built = InstructionLogicalOr {
            logical_or: Box::new(logical_or),
        };
        let instruction_1_built = Instruction::LogicalOr(instruction_1_built);
        // Calling user action here
        self.user_grammar.instruction(&instruction_1_built)?;
        self.push(ASTType::Instruction(instruction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `EqualityOp: "==|!=";`
    ///
    #[parol_runtime::function_name::named]
    fn equality_op(&mut self, equality_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality_op = equality_op.token()?.clone();
        let equality_op_built = EqualityOp { equality_op };
        // Calling user action here
        self.user_grammar.equality_op(&equality_op_built)?;
        self.push(ASTType::EqualityOp(equality_op_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `AssignOp: "(\+|-|\*|/|%|<<|>>|&|\^|\|)?=";`
    ///
    #[parol_runtime::function_name::named]
    fn assign_op(&mut self, assign_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_op = assign_op.token()?.clone();
        let assign_op_built = AssignOp { assign_op };
        // Calling user action here
        self.user_grammar.assign_op(&assign_op_built)?;
        self.push(ASTType::AssignOp(assign_op_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `AssignItem: Id AssignOp;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_item(
        &mut self,
        _id: &ParseTreeType<'t>,
        _assign_op: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_op = pop_item!(self, assign_op, AssignOp, context);
        let id = pop_item!(self, id, Id, context);
        let assign_item_built = AssignItem {
            id: Box::new(id),
            assign_op: Box::new(assign_op),
        };
        // Calling user action here
        self.user_grammar.assign_item(&assign_item_built)?;
        self.push(ASTType::AssignItem(assign_item_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Assignment: AssignItem AssignmentLst1 LogicalOr;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        _assign_item: &ParseTreeType<'t>,
        _assignment_lst1: &ParseTreeType<'t>,
        _logical_or: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or = pop_item!(self, logical_or, LogicalOr, context);
        let assignment_lst1 = pop_item!(self, assignment_lst1, AssignmentLst1, context);
        let assign_item = pop_item!(self, assign_item, AssignItem, context);
        let assignment_built = Assignment {
            assign_item: Box::new(assign_item),
            assignment_lst1: Box::new(assignment_lst1),
            logical_or: Box::new(logical_or),
        };
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `AssignmentLst1: AssignmentLst1Itm1 AssignmentLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_lst1_0(
        &mut self,
        _assignment_lst1_itm1: &ParseTreeType<'t>,
        _assignment_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_lst1 = pop_item!(self, assignment_lst1, AssignmentLst1, context);
        let assignment_lst1_itm1 =
            pop_item!(self, assignment_lst1_itm1, AssignmentLst1Itm1, context);
        let assignment_lst1_0_built = AssignmentLst1AssignmentLst1Itm1AssignmentLst1 {
            assignment_lst1_itm1: Box::new(assignment_lst1_itm1),
            assignment_lst1: Box::new(assignment_lst1),
        };
        let assignment_lst1_0_built =
            AssignmentLst1::AssignmentLst1Itm1AssignmentLst1(assignment_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .assignment_lst1(&assignment_lst1_0_built)?;
        self.push(ASTType::AssignmentLst1(assignment_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `AssignmentLst1Itm1: AssignItem;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_lst1_itm1(&mut self, _assign_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_item = pop_item!(self, assign_item, AssignItem, context);
        let assignment_lst1_itm1_built = AssignmentLst1Itm1 {
            assign_item: Box::new(assign_item),
        };
        // Calling user action here
        self.user_grammar
            .assignment_lst1_itm1(&assignment_lst1_itm1_built)?;
        self.push(
            ASTType::AssignmentLst1Itm1(assignment_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `AssignmentLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_lst1_1_built = AssignmentLst1AssignmentLst1Empty {};
        let assignment_lst1_1_built = AssignmentLst1::AssignmentLst1Empty(assignment_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .assignment_lst1(&assignment_lst1_1_built)?;
        self.push(ASTType::AssignmentLst1(assignment_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `LogicalOr: LogicalAnd LogicalOrLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or(
        &mut self,
        _logical_and: &ParseTreeType<'t>,
        _logical_or_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_lst1 = pop_item!(self, logical_or_lst1, LogicalOrLst1, context);
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_built = LogicalOr {
            logical_and: Box::new(logical_and),
            logical_or_lst1: Box::new(logical_or_lst1),
        };
        // Calling user action here
        self.user_grammar.logical_or(&logical_or_built)?;
        self.push(ASTType::LogicalOr(logical_or_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `LogicalOrLst1: LogicalOrLst1Itm1 LogicalOrLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_lst1_0(
        &mut self,
        _logical_or_lst1_itm1: &ParseTreeType<'t>,
        _logical_or_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_lst1 = pop_item!(self, logical_or_lst1, LogicalOrLst1, context);
        let logical_or_lst1_itm1 =
            pop_item!(self, logical_or_lst1_itm1, LogicalOrLst1Itm1, context);
        let logical_or_lst1_0_built = LogicalOrLst1LogicalOrLst1Itm1LogicalOrLst1 {
            logical_or_lst1_itm1: Box::new(logical_or_lst1_itm1),
            logical_or_lst1: Box::new(logical_or_lst1),
        };
        let logical_or_lst1_0_built =
            LogicalOrLst1::LogicalOrLst1Itm1LogicalOrLst1(logical_or_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .logical_or_lst1(&logical_or_lst1_0_built)?;
        self.push(ASTType::LogicalOrLst1(logical_or_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `LogicalOrLst1Itm1: LogicalOrItem;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_lst1_itm1(&mut self, _logical_or_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_item = pop_item!(self, logical_or_item, LogicalOrItem, context);
        let logical_or_lst1_itm1_built = LogicalOrLst1Itm1 {
            logical_or_item: Box::new(logical_or_item),
        };
        // Calling user action here
        self.user_grammar
            .logical_or_lst1_itm1(&logical_or_lst1_itm1_built)?;
        self.push(
            ASTType::LogicalOrLst1Itm1(logical_or_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `LogicalOrLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_lst1_1_built = LogicalOrLst1LogicalOrLst1Empty {};
        let logical_or_lst1_1_built = LogicalOrLst1::LogicalOrLst1Empty(logical_or_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .logical_or_lst1(&logical_or_lst1_1_built)?;
        self.push(ASTType::LogicalOrLst1(logical_or_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `LogicalOrOp: "\|\|";`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_op(&mut self, logical_or_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_or_op = logical_or_op.token()?.clone();
        let logical_or_op_built = LogicalOrOp { logical_or_op };
        // Calling user action here
        self.user_grammar.logical_or_op(&logical_or_op_built)?;
        self.push(ASTType::LogicalOrOp(logical_or_op_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `LogicalOrItem: LogicalOrOp LogicalAnd;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_or_item(
        &mut self,
        _logical_or_op: &ParseTreeType<'t>,
        _logical_and: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and = pop_item!(self, logical_and, LogicalAnd, context);
        let logical_or_op = pop_item!(self, logical_or_op, LogicalOrOp, context);
        let logical_or_item_built = LogicalOrItem {
            logical_or_op: Box::new(logical_or_op),
            logical_and: Box::new(logical_and),
        };
        // Calling user action here
        self.user_grammar.logical_or_item(&logical_or_item_built)?;
        self.push(ASTType::LogicalOrItem(logical_or_item_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `LogicalAnd: BitwiseOr LogicalAndLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and(
        &mut self,
        _bitwise_or: &ParseTreeType<'t>,
        _logical_and_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_lst1 = pop_item!(self, logical_and_lst1, LogicalAndLst1, context);
        let bitwise_or = pop_item!(self, bitwise_or, BitwiseOr, context);
        let logical_and_built = LogicalAnd {
            bitwise_or: Box::new(bitwise_or),
            logical_and_lst1: Box::new(logical_and_lst1),
        };
        // Calling user action here
        self.user_grammar.logical_and(&logical_and_built)?;
        self.push(ASTType::LogicalAnd(logical_and_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `LogicalAndLst1: LogicalAndLst1Itm1 LogicalAndLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_lst1_0(
        &mut self,
        _logical_and_lst1_itm1: &ParseTreeType<'t>,
        _logical_and_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_lst1 = pop_item!(self, logical_and_lst1, LogicalAndLst1, context);
        let logical_and_lst1_itm1 =
            pop_item!(self, logical_and_lst1_itm1, LogicalAndLst1Itm1, context);
        let logical_and_lst1_0_built = LogicalAndLst1LogicalAndLst1Itm1LogicalAndLst1 {
            logical_and_lst1_itm1: Box::new(logical_and_lst1_itm1),
            logical_and_lst1: Box::new(logical_and_lst1),
        };
        let logical_and_lst1_0_built =
            LogicalAndLst1::LogicalAndLst1Itm1LogicalAndLst1(logical_and_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .logical_and_lst1(&logical_and_lst1_0_built)?;
        self.push(ASTType::LogicalAndLst1(logical_and_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `LogicalAndLst1Itm1: LogicalAndItem;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_lst1_itm1(&mut self, _logical_and_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_item = pop_item!(self, logical_and_item, LogicalAndItem, context);
        let logical_and_lst1_itm1_built = LogicalAndLst1Itm1 {
            logical_and_item: Box::new(logical_and_item),
        };
        // Calling user action here
        self.user_grammar
            .logical_and_lst1_itm1(&logical_and_lst1_itm1_built)?;
        self.push(
            ASTType::LogicalAndLst1Itm1(logical_and_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `LogicalAndLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_lst1_1_built = LogicalAndLst1LogicalAndLst1Empty {};
        let logical_and_lst1_1_built =
            LogicalAndLst1::LogicalAndLst1Empty(logical_and_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .logical_and_lst1(&logical_and_lst1_1_built)?;
        self.push(ASTType::LogicalAndLst1(logical_and_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `LogicalAndOp: "&&";`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_op(&mut self, logical_and_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical_and_op = logical_and_op.token()?.clone();
        let logical_and_op_built = LogicalAndOp { logical_and_op };
        // Calling user action here
        self.user_grammar.logical_and_op(&logical_and_op_built)?;
        self.push(ASTType::LogicalAndOp(logical_and_op_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `LogicalAndItem: LogicalAndOp BitwiseOr;`
    ///
    #[parol_runtime::function_name::named]
    fn logical_and_item(
        &mut self,
        _logical_and_op: &ParseTreeType<'t>,
        _bitwise_or: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or = pop_item!(self, bitwise_or, BitwiseOr, context);
        let logical_and_op = pop_item!(self, logical_and_op, LogicalAndOp, context);
        let logical_and_item_built = LogicalAndItem {
            logical_and_op: Box::new(logical_and_op),
            bitwise_or: Box::new(bitwise_or),
        };
        // Calling user action here
        self.user_grammar
            .logical_and_item(&logical_and_item_built)?;
        self.push(ASTType::LogicalAndItem(logical_and_item_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `BitwiseOr: BitwiseAnd BitwiseOrLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or(
        &mut self,
        _bitwise_and: &ParseTreeType<'t>,
        _bitwise_or_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_lst1 = pop_item!(self, bitwise_or_lst1, BitwiseOrLst1, context);
        let bitwise_and = pop_item!(self, bitwise_and, BitwiseAnd, context);
        let bitwise_or_built = BitwiseOr {
            bitwise_and: Box::new(bitwise_and),
            bitwise_or_lst1: Box::new(bitwise_or_lst1),
        };
        // Calling user action here
        self.user_grammar.bitwise_or(&bitwise_or_built)?;
        self.push(ASTType::BitwiseOr(bitwise_or_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `BitwiseOrLst1: BitwiseOrLst1Itm1 BitwiseOrLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or_lst1_0(
        &mut self,
        _bitwise_or_lst1_itm1: &ParseTreeType<'t>,
        _bitwise_or_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_lst1 = pop_item!(self, bitwise_or_lst1, BitwiseOrLst1, context);
        let bitwise_or_lst1_itm1 =
            pop_item!(self, bitwise_or_lst1_itm1, BitwiseOrLst1Itm1, context);
        let bitwise_or_lst1_0_built = BitwiseOrLst1BitwiseOrLst1Itm1BitwiseOrLst1 {
            bitwise_or_lst1_itm1: Box::new(bitwise_or_lst1_itm1),
            bitwise_or_lst1: Box::new(bitwise_or_lst1),
        };
        let bitwise_or_lst1_0_built =
            BitwiseOrLst1::BitwiseOrLst1Itm1BitwiseOrLst1(bitwise_or_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .bitwise_or_lst1(&bitwise_or_lst1_0_built)?;
        self.push(ASTType::BitwiseOrLst1(bitwise_or_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `BitwiseOrLst1Itm1: BitwiseOrItem;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or_lst1_itm1(&mut self, _bitwise_or_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_item = pop_item!(self, bitwise_or_item, BitwiseOrItem, context);
        let bitwise_or_lst1_itm1_built = BitwiseOrLst1Itm1 {
            bitwise_or_item: Box::new(bitwise_or_item),
        };
        // Calling user action here
        self.user_grammar
            .bitwise_or_lst1_itm1(&bitwise_or_lst1_itm1_built)?;
        self.push(
            ASTType::BitwiseOrLst1Itm1(bitwise_or_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `BitwiseOrLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_lst1_1_built = BitwiseOrLst1BitwiseOrLst1Empty {};
        let bitwise_or_lst1_1_built = BitwiseOrLst1::BitwiseOrLst1Empty(bitwise_or_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .bitwise_or_lst1(&bitwise_or_lst1_1_built)?;
        self.push(ASTType::BitwiseOrLst1(bitwise_or_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `BitwiseOrOp: "\|";`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or_op(&mut self, bitwise_or_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_or_op = bitwise_or_op.token()?.clone();
        let bitwise_or_op_built = BitwiseOrOp { bitwise_or_op };
        // Calling user action here
        self.user_grammar.bitwise_or_op(&bitwise_or_op_built)?;
        self.push(ASTType::BitwiseOrOp(bitwise_or_op_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `BitwiseOrItem: BitwiseOrOp BitwiseAnd;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_or_item(
        &mut self,
        _bitwise_or_op: &ParseTreeType<'t>,
        _bitwise_and: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and = pop_item!(self, bitwise_and, BitwiseAnd, context);
        let bitwise_or_op = pop_item!(self, bitwise_or_op, BitwiseOrOp, context);
        let bitwise_or_item_built = BitwiseOrItem {
            bitwise_or_op: Box::new(bitwise_or_op),
            bitwise_and: Box::new(bitwise_and),
        };
        // Calling user action here
        self.user_grammar.bitwise_or_item(&bitwise_or_item_built)?;
        self.push(ASTType::BitwiseOrItem(bitwise_or_item_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `BitwiseAnd: Equality BitwiseAndLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and(
        &mut self,
        _equality: &ParseTreeType<'t>,
        _bitwise_and_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_lst1 = pop_item!(self, bitwise_and_lst1, BitwiseAndLst1, context);
        let equality = pop_item!(self, equality, Equality, context);
        let bitwise_and_built = BitwiseAnd {
            equality: Box::new(equality),
            bitwise_and_lst1: Box::new(bitwise_and_lst1),
        };
        // Calling user action here
        self.user_grammar.bitwise_and(&bitwise_and_built)?;
        self.push(ASTType::BitwiseAnd(bitwise_and_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `BitwiseAndLst1: BitwiseAndLst1Itm1 BitwiseAndLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and_lst1_0(
        &mut self,
        _bitwise_and_lst1_itm1: &ParseTreeType<'t>,
        _bitwise_and_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_lst1 = pop_item!(self, bitwise_and_lst1, BitwiseAndLst1, context);
        let bitwise_and_lst1_itm1 =
            pop_item!(self, bitwise_and_lst1_itm1, BitwiseAndLst1Itm1, context);
        let bitwise_and_lst1_0_built = BitwiseAndLst1BitwiseAndLst1Itm1BitwiseAndLst1 {
            bitwise_and_lst1_itm1: Box::new(bitwise_and_lst1_itm1),
            bitwise_and_lst1: Box::new(bitwise_and_lst1),
        };
        let bitwise_and_lst1_0_built =
            BitwiseAndLst1::BitwiseAndLst1Itm1BitwiseAndLst1(bitwise_and_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .bitwise_and_lst1(&bitwise_and_lst1_0_built)?;
        self.push(ASTType::BitwiseAndLst1(bitwise_and_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `BitwiseAndLst1Itm1: BitwiseAndItem;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and_lst1_itm1(&mut self, _bitwise_and_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_item = pop_item!(self, bitwise_and_item, BitwiseAndItem, context);
        let bitwise_and_lst1_itm1_built = BitwiseAndLst1Itm1 {
            bitwise_and_item: Box::new(bitwise_and_item),
        };
        // Calling user action here
        self.user_grammar
            .bitwise_and_lst1_itm1(&bitwise_and_lst1_itm1_built)?;
        self.push(
            ASTType::BitwiseAndLst1Itm1(bitwise_and_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `BitwiseAndLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_lst1_1_built = BitwiseAndLst1BitwiseAndLst1Empty {};
        let bitwise_and_lst1_1_built =
            BitwiseAndLst1::BitwiseAndLst1Empty(bitwise_and_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .bitwise_and_lst1(&bitwise_and_lst1_1_built)?;
        self.push(ASTType::BitwiseAndLst1(bitwise_and_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `BitwiseAndOp: "&";`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and_op(&mut self, bitwise_and_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_and_op = bitwise_and_op.token()?.clone();
        let bitwise_and_op_built = BitwiseAndOp { bitwise_and_op };
        // Calling user action here
        self.user_grammar.bitwise_and_op(&bitwise_and_op_built)?;
        self.push(ASTType::BitwiseAndOp(bitwise_and_op_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `BitwiseAndItem: BitwiseAndOp Equality;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_and_item(
        &mut self,
        _bitwise_and_op: &ParseTreeType<'t>,
        _equality: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality = pop_item!(self, equality, Equality, context);
        let bitwise_and_op = pop_item!(self, bitwise_and_op, BitwiseAndOp, context);
        let bitwise_and_item_built = BitwiseAndItem {
            bitwise_and_op: Box::new(bitwise_and_op),
            equality: Box::new(equality),
        };
        // Calling user action here
        self.user_grammar
            .bitwise_and_item(&bitwise_and_item_built)?;
        self.push(ASTType::BitwiseAndItem(bitwise_and_item_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `Equality: Relational EqualityLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn equality(
        &mut self,
        _relational: &ParseTreeType<'t>,
        _equality_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality_lst1 = pop_item!(self, equality_lst1, EqualityLst1, context);
        let relational = pop_item!(self, relational, Relational, context);
        let equality_built = Equality {
            relational: Box::new(relational),
            equality_lst1: Box::new(equality_lst1),
        };
        // Calling user action here
        self.user_grammar.equality(&equality_built)?;
        self.push(ASTType::Equality(equality_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `EqualityLst1: EqualityLst1Itm1 EqualityLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn equality_lst1_0(
        &mut self,
        _equality_lst1_itm1: &ParseTreeType<'t>,
        _equality_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality_lst1 = pop_item!(self, equality_lst1, EqualityLst1, context);
        let equality_lst1_itm1 = pop_item!(self, equality_lst1_itm1, EqualityLst1Itm1, context);
        let equality_lst1_0_built = EqualityLst1EqualityLst1Itm1EqualityLst1 {
            equality_lst1_itm1: Box::new(equality_lst1_itm1),
            equality_lst1: Box::new(equality_lst1),
        };
        let equality_lst1_0_built =
            EqualityLst1::EqualityLst1Itm1EqualityLst1(equality_lst1_0_built);
        // Calling user action here
        self.user_grammar.equality_lst1(&equality_lst1_0_built)?;
        self.push(ASTType::EqualityLst1(equality_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `EqualityLst1Itm1: EqualityItem;`
    ///
    #[parol_runtime::function_name::named]
    fn equality_lst1_itm1(&mut self, _equality_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality_item = pop_item!(self, equality_item, EqualityItem, context);
        let equality_lst1_itm1_built = EqualityLst1Itm1 {
            equality_item: Box::new(equality_item),
        };
        // Calling user action here
        self.user_grammar
            .equality_lst1_itm1(&equality_lst1_itm1_built)?;
        self.push(ASTType::EqualityLst1Itm1(equality_lst1_itm1_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `EqualityLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn equality_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equality_lst1_1_built = EqualityLst1EqualityLst1Empty {};
        let equality_lst1_1_built = EqualityLst1::EqualityLst1Empty(equality_lst1_1_built);
        // Calling user action here
        self.user_grammar.equality_lst1(&equality_lst1_1_built)?;
        self.push(ASTType::EqualityLst1(equality_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `EqualityItem: EqualityOp Relational;`
    ///
    #[parol_runtime::function_name::named]
    fn equality_item(
        &mut self,
        _equality_op: &ParseTreeType<'t>,
        _relational: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational = pop_item!(self, relational, Relational, context);
        let equality_op = pop_item!(self, equality_op, EqualityOp, context);
        let equality_item_built = EqualityItem {
            equality_op: Box::new(equality_op),
            relational: Box::new(relational),
        };
        // Calling user action here
        self.user_grammar.equality_item(&equality_item_built)?;
        self.push(ASTType::EqualityItem(equality_item_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `BitwiseShiftOp: "<<|>>";`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift_op(&mut self, bitwise_shift_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_op = bitwise_shift_op.token()?.clone();
        let bitwise_shift_op_built = BitwiseShiftOp { bitwise_shift_op };
        // Calling user action here
        self.user_grammar
            .bitwise_shift_op(&bitwise_shift_op_built)?;
        self.push(ASTType::BitwiseShiftOp(bitwise_shift_op_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `Relational: BitwiseShift RelationalLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn relational(
        &mut self,
        _bitwise_shift: &ParseTreeType<'t>,
        _relational_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_lst1 = pop_item!(self, relational_lst1, RelationalLst1, context);
        let bitwise_shift = pop_item!(self, bitwise_shift, BitwiseShift, context);
        let relational_built = Relational {
            bitwise_shift: Box::new(bitwise_shift),
            relational_lst1: Box::new(relational_lst1),
        };
        // Calling user action here
        self.user_grammar.relational(&relational_built)?;
        self.push(ASTType::Relational(relational_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `RelationalLst1: RelationalLst1Itm1 RelationalLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_lst1_0(
        &mut self,
        _relational_lst1_itm1: &ParseTreeType<'t>,
        _relational_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_lst1 = pop_item!(self, relational_lst1, RelationalLst1, context);
        let relational_lst1_itm1 =
            pop_item!(self, relational_lst1_itm1, RelationalLst1Itm1, context);
        let relational_lst1_0_built = RelationalLst1RelationalLst1Itm1RelationalLst1 {
            relational_lst1_itm1: Box::new(relational_lst1_itm1),
            relational_lst1: Box::new(relational_lst1),
        };
        let relational_lst1_0_built =
            RelationalLst1::RelationalLst1Itm1RelationalLst1(relational_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .relational_lst1(&relational_lst1_0_built)?;
        self.push(ASTType::RelationalLst1(relational_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `RelationalLst1Itm1: RelationalItem;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_lst1_itm1(&mut self, _relational_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_item = pop_item!(self, relational_item, RelationalItem, context);
        let relational_lst1_itm1_built = RelationalLst1Itm1 {
            relational_item: Box::new(relational_item),
        };
        // Calling user action here
        self.user_grammar
            .relational_lst1_itm1(&relational_lst1_itm1_built)?;
        self.push(
            ASTType::RelationalLst1Itm1(relational_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `RelationalLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_lst1_1_built = RelationalLst1RelationalLst1Empty {};
        let relational_lst1_1_built = RelationalLst1::RelationalLst1Empty(relational_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .relational_lst1(&relational_lst1_1_built)?;
        self.push(ASTType::RelationalLst1(relational_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `RelationalOp: "<=|<|>=|>";`
    ///
    #[parol_runtime::function_name::named]
    fn relational_op(&mut self, relational_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relational_op = relational_op.token()?.clone();
        let relational_op_built = RelationalOp { relational_op };
        // Calling user action here
        self.user_grammar.relational_op(&relational_op_built)?;
        self.push(ASTType::RelationalOp(relational_op_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `RelationalItem: RelationalOp BitwiseShift;`
    ///
    #[parol_runtime::function_name::named]
    fn relational_item(
        &mut self,
        _relational_op: &ParseTreeType<'t>,
        _bitwise_shift: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift = pop_item!(self, bitwise_shift, BitwiseShift, context);
        let relational_op = pop_item!(self, relational_op, RelationalOp, context);
        let relational_item_built = RelationalItem {
            relational_op: Box::new(relational_op),
            bitwise_shift: Box::new(bitwise_shift),
        };
        // Calling user action here
        self.user_grammar.relational_item(&relational_item_built)?;
        self.push(ASTType::RelationalItem(relational_item_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `BitwiseShift: Summ BitwiseShiftLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift(
        &mut self,
        _summ: &ParseTreeType<'t>,
        _bitwise_shift_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_lst1 = pop_item!(self, bitwise_shift_lst1, BitwiseShiftLst1, context);
        let summ = pop_item!(self, summ, Summ, context);
        let bitwise_shift_built = BitwiseShift {
            summ: Box::new(summ),
            bitwise_shift_lst1: Box::new(bitwise_shift_lst1),
        };
        // Calling user action here
        self.user_grammar.bitwise_shift(&bitwise_shift_built)?;
        self.push(ASTType::BitwiseShift(bitwise_shift_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `BitwiseShiftLst1: BitwiseShiftLst1Itm1 BitwiseShiftLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift_lst1_0(
        &mut self,
        _bitwise_shift_lst1_itm1: &ParseTreeType<'t>,
        _bitwise_shift_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_lst1 = pop_item!(self, bitwise_shift_lst1, BitwiseShiftLst1, context);
        let bitwise_shift_lst1_itm1 =
            pop_item!(self, bitwise_shift_lst1_itm1, BitwiseShiftLst1Itm1, context);
        let bitwise_shift_lst1_0_built = BitwiseShiftLst1BitwiseShiftLst1Itm1BitwiseShiftLst1 {
            bitwise_shift_lst1_itm1: Box::new(bitwise_shift_lst1_itm1),
            bitwise_shift_lst1: Box::new(bitwise_shift_lst1),
        };
        let bitwise_shift_lst1_0_built =
            BitwiseShiftLst1::BitwiseShiftLst1Itm1BitwiseShiftLst1(bitwise_shift_lst1_0_built);
        // Calling user action here
        self.user_grammar
            .bitwise_shift_lst1(&bitwise_shift_lst1_0_built)?;
        self.push(
            ASTType::BitwiseShiftLst1(bitwise_shift_lst1_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `BitwiseShiftLst1Itm1: BitwiseShiftItem;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift_lst1_itm1(&mut self, _bitwise_shift_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_item = pop_item!(self, bitwise_shift_item, BitwiseShiftItem, context);
        let bitwise_shift_lst1_itm1_built = BitwiseShiftLst1Itm1 {
            bitwise_shift_item: Box::new(bitwise_shift_item),
        };
        // Calling user action here
        self.user_grammar
            .bitwise_shift_lst1_itm1(&bitwise_shift_lst1_itm1_built)?;
        self.push(
            ASTType::BitwiseShiftLst1Itm1(bitwise_shift_lst1_itm1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `BitwiseShiftLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bitwise_shift_lst1_1_built = BitwiseShiftLst1BitwiseShiftLst1Empty {};
        let bitwise_shift_lst1_1_built =
            BitwiseShiftLst1::BitwiseShiftLst1Empty(bitwise_shift_lst1_1_built);
        // Calling user action here
        self.user_grammar
            .bitwise_shift_lst1(&bitwise_shift_lst1_1_built)?;
        self.push(
            ASTType::BitwiseShiftLst1(bitwise_shift_lst1_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `BitwiseShiftItem: BitwiseShiftOp Summ;`
    ///
    #[parol_runtime::function_name::named]
    fn bitwise_shift_item(
        &mut self,
        _bitwise_shift_op: &ParseTreeType<'t>,
        _summ: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summ = pop_item!(self, summ, Summ, context);
        let bitwise_shift_op = pop_item!(self, bitwise_shift_op, BitwiseShiftOp, context);
        let bitwise_shift_item_built = BitwiseShiftItem {
            bitwise_shift_op: Box::new(bitwise_shift_op),
            summ: Box::new(summ),
        };
        // Calling user action here
        self.user_grammar
            .bitwise_shift_item(&bitwise_shift_item_built)?;
        self.push(ASTType::BitwiseShiftItem(bitwise_shift_item_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `Summ: Mult SummLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn summ(&mut self, _mult: &ParseTreeType<'t>, _summ_lst1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summ_lst1 = pop_item!(self, summ_lst1, SummLst1, context);
        let mult = pop_item!(self, mult, Mult, context);
        let summ_built = Summ {
            mult: Box::new(mult),
            summ_lst1: Box::new(summ_lst1),
        };
        // Calling user action here
        self.user_grammar.summ(&summ_built)?;
        self.push(ASTType::Summ(summ_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `SummLst1: SummLst1Itm1 SummLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn summ_lst1_0(
        &mut self,
        _summ_lst1_itm1: &ParseTreeType<'t>,
        _summ_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summ_lst1 = pop_item!(self, summ_lst1, SummLst1, context);
        let summ_lst1_itm1 = pop_item!(self, summ_lst1_itm1, SummLst1Itm1, context);
        let summ_lst1_0_built = SummLst1SummLst1Itm1SummLst1 {
            summ_lst1_itm1: Box::new(summ_lst1_itm1),
            summ_lst1: Box::new(summ_lst1),
        };
        let summ_lst1_0_built = SummLst1::SummLst1Itm1SummLst1(summ_lst1_0_built);
        // Calling user action here
        self.user_grammar.summ_lst1(&summ_lst1_0_built)?;
        self.push(ASTType::SummLst1(summ_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `SummLst1Itm1: SummItem;`
    ///
    #[parol_runtime::function_name::named]
    fn summ_lst1_itm1(&mut self, _summ_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summ_item = pop_item!(self, summ_item, SummItem, context);
        let summ_lst1_itm1_built = SummLst1Itm1 {
            summ_item: Box::new(summ_item),
        };
        // Calling user action here
        self.user_grammar.summ_lst1_itm1(&summ_lst1_itm1_built)?;
        self.push(ASTType::SummLst1Itm1(summ_lst1_itm1_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `SummLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn summ_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summ_lst1_1_built = SummLst1SummLst1Empty {};
        let summ_lst1_1_built = SummLst1::SummLst1Empty(summ_lst1_1_built);
        // Calling user action here
        self.user_grammar.summ_lst1(&summ_lst1_1_built)?;
        self.push(ASTType::SummLst1(summ_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Plus: "\+";`
    ///
    #[parol_runtime::function_name::named]
    fn plus(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let plus_built = Plus { plus };
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `Minus: "-";`
    ///
    #[parol_runtime::function_name::named]
    fn minus(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let minus_built = Minus { minus };
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `AddOp: Plus;`
    ///
    #[parol_runtime::function_name::named]
    fn add_op_0(&mut self, _plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let add_op_0_built = AddOpPlus {
            plus: Box::new(plus),
        };
        let add_op_0_built = AddOp::Plus(add_op_0_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_0_built)?;
        self.push(ASTType::AddOp(add_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `AddOp: Minus;`
    ///
    #[parol_runtime::function_name::named]
    fn add_op_1(&mut self, _minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let add_op_1_built = AddOpMinus {
            minus: Box::new(minus),
        };
        let add_op_1_built = AddOp::Minus(add_op_1_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_1_built)?;
        self.push(ASTType::AddOp(add_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `SummItem: AddOp Mult;`
    ///
    #[parol_runtime::function_name::named]
    fn summ_item(&mut self, _add_op: &ParseTreeType<'t>, _mult: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult = pop_item!(self, mult, Mult, context);
        let add_op = pop_item!(self, add_op, AddOp, context);
        let summ_item_built = SummItem {
            add_op: Box::new(add_op),
            mult: Box::new(mult),
        };
        // Calling user action here
        self.user_grammar.summ_item(&summ_item_built)?;
        self.push(ASTType::SummItem(summ_item_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `PowOp: "\*\*";`
    ///
    #[parol_runtime::function_name::named]
    fn pow_op(&mut self, pow_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pow_op = pow_op.token()?.clone();
        let pow_op_built = PowOp { pow_op };
        // Calling user action here
        self.user_grammar.pow_op(&pow_op_built)?;
        self.push(ASTType::PowOp(pow_op_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `Mult: Power MultLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn mult(&mut self, _power: &ParseTreeType<'t>, _mult_lst1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult_lst1 = pop_item!(self, mult_lst1, MultLst1, context);
        let power = pop_item!(self, power, Power, context);
        let mult_built = Mult {
            power: Box::new(power),
            mult_lst1: Box::new(mult_lst1),
        };
        // Calling user action here
        self.user_grammar.mult(&mult_built)?;
        self.push(ASTType::Mult(mult_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `MultLst1: MultLst1Itm1 MultLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn mult_lst1_0(
        &mut self,
        _mult_lst1_itm1: &ParseTreeType<'t>,
        _mult_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult_lst1 = pop_item!(self, mult_lst1, MultLst1, context);
        let mult_lst1_itm1 = pop_item!(self, mult_lst1_itm1, MultLst1Itm1, context);
        let mult_lst1_0_built = MultLst1MultLst1Itm1MultLst1 {
            mult_lst1_itm1: Box::new(mult_lst1_itm1),
            mult_lst1: Box::new(mult_lst1),
        };
        let mult_lst1_0_built = MultLst1::MultLst1Itm1MultLst1(mult_lst1_0_built);
        // Calling user action here
        self.user_grammar.mult_lst1(&mult_lst1_0_built)?;
        self.push(ASTType::MultLst1(mult_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `MultLst1Itm1: MultItem;`
    ///
    #[parol_runtime::function_name::named]
    fn mult_lst1_itm1(&mut self, _mult_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult_item = pop_item!(self, mult_item, MultItem, context);
        let mult_lst1_itm1_built = MultLst1Itm1 {
            mult_item: Box::new(mult_item),
        };
        // Calling user action here
        self.user_grammar.mult_lst1_itm1(&mult_lst1_itm1_built)?;
        self.push(ASTType::MultLst1Itm1(mult_lst1_itm1_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `MultLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn mult_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult_lst1_1_built = MultLst1MultLst1Empty {};
        let mult_lst1_1_built = MultLst1::MultLst1Empty(mult_lst1_1_built);
        // Calling user action here
        self.user_grammar.mult_lst1(&mult_lst1_1_built)?;
        self.push(ASTType::MultLst1(mult_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `MultOp: "\*|/|%";`
    ///
    #[parol_runtime::function_name::named]
    fn mult_op(&mut self, mult_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mult_op = mult_op.token()?.clone();
        let mult_op_built = MultOp { mult_op };
        // Calling user action here
        self.user_grammar.mult_op(&mult_op_built)?;
        self.push(ASTType::MultOp(mult_op_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `MultItem: MultOp Power;`
    ///
    #[parol_runtime::function_name::named]
    fn mult_item(
        &mut self,
        _mult_op: &ParseTreeType<'t>,
        _power: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let power = pop_item!(self, power, Power, context);
        let mult_op = pop_item!(self, mult_op, MultOp, context);
        let mult_item_built = MultItem {
            mult_op: Box::new(mult_op),
            power: Box::new(power),
        };
        // Calling user action here
        self.user_grammar.mult_item(&mult_item_built)?;
        self.push(ASTType::MultItem(mult_item_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `Power: Factor PowerLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn power(
        &mut self,
        _factor: &ParseTreeType<'t>,
        _power_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let power_lst1 = pop_item!(self, power_lst1, PowerLst1, context);
        let factor = pop_item!(self, factor, Factor, context);
        let power_built = Power {
            factor: Box::new(factor),
            power_lst1: Box::new(power_lst1),
        };
        // Calling user action here
        self.user_grammar.power(&power_built)?;
        self.push(ASTType::Power(power_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `PowerLst1: PowerLst1Itm1 PowerLst1;`
    ///
    #[parol_runtime::function_name::named]
    fn power_lst1_0(
        &mut self,
        _power_lst1_itm1: &ParseTreeType<'t>,
        _power_lst1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let power_lst1 = pop_item!(self, power_lst1, PowerLst1, context);
        let power_lst1_itm1 = pop_item!(self, power_lst1_itm1, PowerLst1Itm1, context);
        let power_lst1_0_built = PowerLst1PowerLst1Itm1PowerLst1 {
            power_lst1_itm1: Box::new(power_lst1_itm1),
            power_lst1: Box::new(power_lst1),
        };
        let power_lst1_0_built = PowerLst1::PowerLst1Itm1PowerLst1(power_lst1_0_built);
        // Calling user action here
        self.user_grammar.power_lst1(&power_lst1_0_built)?;
        self.push(ASTType::PowerLst1(power_lst1_0_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `PowerLst1Itm1: PowOp Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn power_lst1_itm1(
        &mut self,
        _pow_op: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let pow_op = pop_item!(self, pow_op, PowOp, context);
        let power_lst1_itm1_built = PowerLst1Itm1 {
            pow_op: Box::new(pow_op),
            factor: Box::new(factor),
        };
        // Calling user action here
        self.user_grammar.power_lst1_itm1(&power_lst1_itm1_built)?;
        self.push(ASTType::PowerLst1Itm1(power_lst1_itm1_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `PowerLst1: ;`
    ///
    #[parol_runtime::function_name::named]
    fn power_lst1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let power_lst1_1_built = PowerLst1PowerLst1Empty {};
        let power_lst1_1_built = PowerLst1::PowerLst1Empty(power_lst1_1_built);
        // Calling user action here
        self.user_grammar.power_lst1(&power_lst1_1_built)?;
        self.push(ASTType::PowerLst1(power_lst1_1_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `Negate: Minus;`
    ///
    #[parol_runtime::function_name::named]
    fn negate(&mut self, _minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let negate_built = Negate {
            minus: Box::new(minus),
        };
        // Calling user action here
        self.user_grammar.negate(&negate_built)?;
        self.push(ASTType::Negate(negate_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `Factor: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = FactorNumber {
            number: Box::new(number),
        };
        let factor_0_built = Factor::Number(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `Factor: IdRef;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _id_ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let id_ref = pop_item!(self, id_ref, IdRef, context);
        let factor_1_built = FactorIdRef {
            id_ref: Box::new(id_ref),
        };
        let factor_1_built = Factor::IdRef(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `Factor: Negate Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(&mut self, _negate: &ParseTreeType<'t>, _factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let negate = pop_item!(self, negate, Negate, context);
        let factor_2_built = FactorNegateFactor {
            negate: Box::new(negate),
            factor: Box::new(factor),
        };
        let factor_2_built = Factor::NegateFactor(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `Factor: "\(" LogicalOr "\)";`
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        l_paren: &ParseTreeType<'t>,
        _logical_or: &ParseTreeType<'t>,
        r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let r_paren = r_paren.token()?.clone();
        let logical_or = pop_item!(self, logical_or, LogicalOr, context);
        let factor_3_built = FactorLParenLogicalOrRParen {
            l_paren,
            logical_or: Box::new(logical_or),
            r_paren,
        };
        let factor_3_built = Factor::LParenLogicalOrRParen(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `Number: "0|[1-9][0-9]*";`
    ///
    #[parol_runtime::function_name::named]
    fn number(&mut self, number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = number.token()?.clone();
        let number_built = Number { number };
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `IdRef: Id;`
    ///
    #[parol_runtime::function_name::named]
    fn id_ref(&mut self, _id: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let id = pop_item!(self, id, Id, context);
        let id_ref_built = IdRef { id: Box::new(id) };
        // Calling user action here
        self.user_grammar.id_ref(&id_ref_built)?;
        self.push(ASTType::IdRef(id_ref_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `Id: "[a-zA-Z_][a-zA-Z0-9_]*";`
    ///
    #[parol_runtime::function_name::named]
    fn id(&mut self, id: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let id = id.token()?.clone();
        let id_built = Id { id };
        // Calling user action here
        self.user_grammar.id(&id_built)?;
        self.push(ASTType::Id(id_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for CalcGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item CalcGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.calc(&children[0]),
            1 => self.calc_lst1_0(&children[0], &children[1]),
            2 => self.calc_lst1_itm1(&children[0], &children[1]),
            3 => self.calc_lst1_1(),
            4 => self.instruction_0(&children[0]),
            5 => self.instruction_1(&children[0]),
            6 => self.equality_op(&children[0]),
            7 => self.assign_op(&children[0]),
            8 => self.assign_item(&children[0], &children[1]),
            9 => self.assignment(&children[0], &children[1], &children[2]),
            10 => self.assignment_lst1_0(&children[0], &children[1]),
            11 => self.assignment_lst1_itm1(&children[0]),
            12 => self.assignment_lst1_1(),
            13 => self.logical_or(&children[0], &children[1]),
            14 => self.logical_or_lst1_0(&children[0], &children[1]),
            15 => self.logical_or_lst1_itm1(&children[0]),
            16 => self.logical_or_lst1_1(),
            17 => self.logical_or_op(&children[0]),
            18 => self.logical_or_item(&children[0], &children[1]),
            19 => self.logical_and(&children[0], &children[1]),
            20 => self.logical_and_lst1_0(&children[0], &children[1]),
            21 => self.logical_and_lst1_itm1(&children[0]),
            22 => self.logical_and_lst1_1(),
            23 => self.logical_and_op(&children[0]),
            24 => self.logical_and_item(&children[0], &children[1]),
            25 => self.bitwise_or(&children[0], &children[1]),
            26 => self.bitwise_or_lst1_0(&children[0], &children[1]),
            27 => self.bitwise_or_lst1_itm1(&children[0]),
            28 => self.bitwise_or_lst1_1(),
            29 => self.bitwise_or_op(&children[0]),
            30 => self.bitwise_or_item(&children[0], &children[1]),
            31 => self.bitwise_and(&children[0], &children[1]),
            32 => self.bitwise_and_lst1_0(&children[0], &children[1]),
            33 => self.bitwise_and_lst1_itm1(&children[0]),
            34 => self.bitwise_and_lst1_1(),
            35 => self.bitwise_and_op(&children[0]),
            36 => self.bitwise_and_item(&children[0], &children[1]),
            37 => self.equality(&children[0], &children[1]),
            38 => self.equality_lst1_0(&children[0], &children[1]),
            39 => self.equality_lst1_itm1(&children[0]),
            40 => self.equality_lst1_1(),
            41 => self.equality_item(&children[0], &children[1]),
            42 => self.bitwise_shift_op(&children[0]),
            43 => self.relational(&children[0], &children[1]),
            44 => self.relational_lst1_0(&children[0], &children[1]),
            45 => self.relational_lst1_itm1(&children[0]),
            46 => self.relational_lst1_1(),
            47 => self.relational_op(&children[0]),
            48 => self.relational_item(&children[0], &children[1]),
            49 => self.bitwise_shift(&children[0], &children[1]),
            50 => self.bitwise_shift_lst1_0(&children[0], &children[1]),
            51 => self.bitwise_shift_lst1_itm1(&children[0]),
            52 => self.bitwise_shift_lst1_1(),
            53 => self.bitwise_shift_item(&children[0], &children[1]),
            54 => self.summ(&children[0], &children[1]),
            55 => self.summ_lst1_0(&children[0], &children[1]),
            56 => self.summ_lst1_itm1(&children[0]),
            57 => self.summ_lst1_1(),
            58 => self.plus(&children[0]),
            59 => self.minus(&children[0]),
            60 => self.add_op_0(&children[0]),
            61 => self.add_op_1(&children[0]),
            62 => self.summ_item(&children[0], &children[1]),
            63 => self.pow_op(&children[0]),
            64 => self.mult(&children[0], &children[1]),
            65 => self.mult_lst1_0(&children[0], &children[1]),
            66 => self.mult_lst1_itm1(&children[0]),
            67 => self.mult_lst1_1(),
            68 => self.mult_op(&children[0]),
            69 => self.mult_item(&children[0], &children[1]),
            70 => self.power(&children[0], &children[1]),
            71 => self.power_lst1_0(&children[0], &children[1]),
            72 => self.power_lst1_itm1(&children[0], &children[1]),
            73 => self.power_lst1_1(),
            74 => self.negate(&children[0]),
            75 => self.factor_0(&children[0]),
            76 => self.factor_1(&children[0]),
            77 => self.factor_2(&children[0], &children[1]),
            78 => self.factor_3(&children[0], &children[1], &children[2]),
            79 => self.number(&children[0]),
            80 => self.id_ref(&children[0]),
            81 => self.id(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
