// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::lr_parser::{LR1State, LRAction, LRParseTable, LRParser, LRProduction};
use parol_runtime::once_cell::sync::Lazy;
use parol_runtime::parser::parse_tree_type::TreeConstruct;
#[allow(unused_imports)]
use parol_runtime::parser::{ParseType, Production, Trans};
use parol_runtime::{ParolError, ParseTree, TerminalIndex};
use parol_runtime::{ScannerConfig, TokenStream, Tokenizer};
use std::path::Path;

use crate::list_grammar::ListGrammar;
use crate::list_grammar_trait::ListGrammarAuto;

use parol_runtime::lexer::tokenizer::{
    ERROR_TOKEN, NEW_LINE_TOKEN, UNMATCHABLE_TOKEN, WHITESPACE_TOKEN,
};

pub const TERMINALS: &[(&str, Option<(bool, &str)>); 8] = &[
    /* 0 */ (UNMATCHABLE_TOKEN, None),
    /* 1 */ (UNMATCHABLE_TOKEN, None),
    /* 2 */ (UNMATCHABLE_TOKEN, None),
    /* 3 */ (UNMATCHABLE_TOKEN, None),
    /* 4 */ (UNMATCHABLE_TOKEN, None),
    /* 5 */ (r",", None),
    /* 6 */ (r"0|[1-9][0-9]*", None),
    /* 7 */ (ERROR_TOKEN, None),
];

pub const TERMINAL_NAMES: &[&str; 8] = &[
    /* 0 */ "EndOfInput",
    /* 1 */ "Newline",
    /* 2 */ "Whitespace",
    /* 3 */ "LineComment",
    /* 4 */ "BlockComment",
    /* 5 */ "Comma",
    /* 6 */ "Num",
    /* 7 */ "Error",
];

/* SCANNER_0: "INITIAL" */
const SCANNER_0: (&[&str; 5], &[TerminalIndex; 2]) = (
    &[
        /* 0 */ UNMATCHABLE_TOKEN,
        /* 1 */ NEW_LINE_TOKEN,
        /* 2 */ WHITESPACE_TOKEN,
        /* 3 */ r"//.*(\r\n|\r|\n)?",
        /* 4 */ UNMATCHABLE_TOKEN,
    ],
    &[5 /* Comma */, 6 /* Num */],
);

pub const NON_TERMINALS: &[&str; 5] = &[
    /* 0 */ "Items",
    /* 1 */ "ItemsList",
    /* 2 */ "List",
    /* 3 */ "ListOpt",
    /* 4 */ "Num",
];

static PARSE_TABLE: LRParseTable = LRParseTable {
    actions: &[
        /* 0 */ LRAction::Shift(1),
        /* 1 */ LRAction::Shift(6),
        /* 2 */ LRAction::Reduce(0 /* Items */, 3),
        /* 3 */ LRAction::Reduce(1 /* ItemsList */, 4),
        /* 4 */ LRAction::Reduce(1 /* ItemsList */, 5),
        /* 5 */ LRAction::Reduce(3 /* ListOpt */, 1),
        /* 6 */ LRAction::Reduce(3 /* ListOpt */, 2),
        /* 7 */ LRAction::Reduce(4 /* Num */, 6),
        /* 8 */ LRAction::Accept,
    ],
    states: &[
        // State 0
        LR1State {
            actions: &[
                (0, 6), /* '<$>' => LRAction::Reduce(ListOpt, 2) */
                (6, 0), /* '0|[1-9][0-9]*' => LRAction::Shift(1) */
            ],
            gotos: &[
                (0, 2), /* Items => 2 */
                (3, 3), /* ListOpt => 3 */
                (4, 4), /* Num => 4 */
            ],
        },
        // State 1
        LR1State {
            actions: &[
                (0, 7), /* '<$>' => LRAction::Reduce(Num, 6) */
                (5, 7), /* ',' => LRAction::Reduce(Num, 6) */
            ],
            gotos: &[],
        },
        // State 2
        LR1State {
            actions: &[(0, 5) /* '<$>' => LRAction::Reduce(ListOpt, 1) */],
            gotos: &[],
        },
        // State 3
        LR1State {
            actions: &[(0, 8) /* '<$>' => LRAction::Accept */],
            gotos: &[],
        },
        // State 4
        LR1State {
            actions: &[
                (0, 4), /* '<$>' => LRAction::Reduce(ItemsList, 5) */
                (5, 4), /* ',' => LRAction::Reduce(ItemsList, 5) */
            ],
            gotos: &[(1, 5) /* ItemsList => 5 */],
        },
        // State 5
        LR1State {
            actions: &[
                (0, 2), /* '<$>' => LRAction::Reduce(Items, 3) */
                (5, 1), /* ',' => LRAction::Shift(6) */
            ],
            gotos: &[],
        },
        // State 6
        LR1State {
            actions: &[(6, 0) /* '0|[1-9][0-9]*' => LRAction::Shift(1) */],
            gotos: &[(4, 7) /* Num => 7 */],
        },
        // State 7
        LR1State {
            actions: &[
                (0, 3), /* '<$>' => LRAction::Reduce(ItemsList, 4) */
                (5, 3), /* ',' => LRAction::Reduce(ItemsList, 4) */
            ],
            gotos: &[],
        },
    ],
};

pub const PRODUCTIONS: &[LRProduction; 7] = &[
    // 0 - List: ListOpt /* Option */;
    LRProduction { lhs: 2, len: 1 },
    // 1 - ListOpt: Items : crate::list_grammar::Numbers ;
    LRProduction { lhs: 3, len: 1 },
    // 2 - ListOpt: ;
    LRProduction { lhs: 3, len: 0 },
    // 3 - Items: Num ItemsList /* Vec */;
    LRProduction { lhs: 0, len: 2 },
    // 4 - ItemsList: ItemsList ','^ /* Clipped */ Num;
    LRProduction { lhs: 1, len: 3 },
    // 5 - ItemsList: ;
    LRProduction { lhs: 1, len: 0 },
    // 6 - Num: /0|[1-9][0-9]*/;
    LRProduction { lhs: 4, len: 1 },
];

static SCANNERS: Lazy<Vec<ScannerConfig>> = Lazy::new(|| {
    vec![ScannerConfig::new(
        "INITIAL",
        Tokenizer::build(TERMINALS, SCANNER_0.0, SCANNER_0.1).unwrap(),
        &[],
    )]
});

pub fn parse<T>(
    input: &str,
    file_name: T,
    user_actions: &mut ListGrammar,
) -> Result<ParseTree, ParolError>
where
    T: AsRef<Path>,
{
    use parol_runtime::parser::parse_tree_type::SynTree;
    use parol_runtime::parser::parser_types::SynTreeFlavor;
    use parol_runtime::syntree::Builder;
    let mut builder = Builder::<SynTree, SynTreeFlavor>::new_with();
    parse_into(input, &mut builder, file_name, user_actions)?;
    Ok(builder.build()?)
}
#[allow(dead_code)]
pub fn parse_into<'t, T: TreeConstruct<'t>>(
    input: &'t str,
    tree_builder: &mut T,
    file_name: impl AsRef<Path>,
    user_actions: &mut ListGrammar,
) -> Result<(), ParolError>
where
    ParolError: From<T::Error>,
{
    let mut lr_parser = LRParser::new(2, &PARSE_TABLE, PRODUCTIONS, TERMINAL_NAMES, NON_TERMINALS);
    // Initialize wrapper
    let mut user_actions = ListGrammarAuto::new(user_actions);
    lr_parser.parse_into::<T>(
        tree_builder,
        TokenStream::new(input, file_name, &SCANNERS, 1).unwrap(),
        &mut user_actions,
    )
}
