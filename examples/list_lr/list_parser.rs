// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::{
    ParolError, ParseTree, TokenStream,
    lr_parser::{LR1State, LRAction, LRParseTable, LRParser, LRProduction},
    parser::parse_tree_type::TreeConstruct,
};
use scnr2::scanner;
use std::path::Path;

use crate::list_grammar::ListGrammar;
use crate::list_grammar_trait::ListGrammarAuto;

pub const TERMINAL_NAMES: &[&str; 8] = &[
    /* 0 */ "EndOfInput",
    /* 1 */ "Newline",
    /* 2 */ "Whitespace",
    /* 3 */ "LineComment",
    /* 4 */ "BlockComment",
    /* 5 */ "Comma",
    /* 6 */ "Num",
    /* 7 */ "Error",
];

scanner! {
    ListGrammarScanner {
        mode INITIAL {
            token r"\r\n|\r|\n" => 1; // "Newline"
            token r"[\s--\r\n]+" => 2; // "Whitespace"
            token r"//.*(\r\n|\r|\n)?" => 3; // "LineComment"
            token r"," => 5; // "Comma"
            token r"0|[1-9][0-9]*" => 6; // "Num"
            token r"." => 10; // "Num"
        }
    }
}

pub const NON_TERMINALS: &[&str; 5] = &[
    /* 0 */ "Items",
    /* 1 */ "ItemsList",
    /* 2 */ "List",
    /* 3 */ "ListOpt",
    /* 4 */ "Num",
];

static PARSE_TABLE: LRParseTable = LRParseTable {
    actions: &[
        /* 0 */ LRAction::Shift(1),
        /* 1 */ LRAction::Shift(6),
        /* 2 */ LRAction::Reduce(0 /* Items */, 3),
        /* 3 */ LRAction::Reduce(1 /* ItemsList */, 4),
        /* 4 */ LRAction::Reduce(1 /* ItemsList */, 5),
        /* 5 */ LRAction::Reduce(3 /* ListOpt */, 1),
        /* 6 */ LRAction::Reduce(3 /* ListOpt */, 2),
        /* 7 */ LRAction::Reduce(4 /* Num */, 6),
        /* 8 */ LRAction::Accept,
    ],
    states: &[
        // State 0
        LR1State {
            actions: &[
                (0, 6), /* '<$>' => LRAction::Reduce(ListOpt, 2) */
                (6, 0), /* '0|[1-9][0-9]*' => LRAction::Shift(1) */
            ],
            gotos: &[
                (0, 2), /* Items => 2 */
                (3, 3), /* ListOpt => 3 */
                (4, 4), /* Num => 4 */
            ],
        },
        // State 1
        LR1State {
            actions: &[
                (0, 7), /* '<$>' => LRAction::Reduce(Num, 6) */
                (5, 7), /* ',' => LRAction::Reduce(Num, 6) */
            ],
            gotos: &[],
        },
        // State 2
        LR1State {
            actions: &[(0, 5) /* '<$>' => LRAction::Reduce(ListOpt, 1) */],
            gotos: &[],
        },
        // State 3
        LR1State {
            actions: &[(0, 8) /* '<$>' => LRAction::Accept */],
            gotos: &[],
        },
        // State 4
        LR1State {
            actions: &[
                (0, 4), /* '<$>' => LRAction::Reduce(ItemsList, 5) */
                (5, 4), /* ',' => LRAction::Reduce(ItemsList, 5) */
            ],
            gotos: &[(1, 5) /* ItemsList => 5 */],
        },
        // State 5
        LR1State {
            actions: &[
                (0, 2), /* '<$>' => LRAction::Reduce(Items, 3) */
                (5, 1), /* ',' => LRAction::Shift(6) */
            ],
            gotos: &[],
        },
        // State 6
        LR1State {
            actions: &[(6, 0) /* '0|[1-9][0-9]*' => LRAction::Shift(1) */],
            gotos: &[(4, 7) /* Num => 7 */],
        },
        // State 7
        LR1State {
            actions: &[
                (0, 3), /* '<$>' => LRAction::Reduce(ItemsList, 4) */
                (5, 3), /* ',' => LRAction::Reduce(ItemsList, 4) */
            ],
            gotos: &[],
        },
    ],
};

pub const PRODUCTIONS: &[LRProduction; 7] = &[
    // 0 - List: ListOpt /* Option */;
    LRProduction { lhs: 2, len: 1 },
    // 1 - ListOpt: Items : crate::list_grammar::Numbers ;
    LRProduction { lhs: 3, len: 1 },
    // 2 - ListOpt: ;
    LRProduction { lhs: 3, len: 0 },
    // 3 - Items: Num ItemsList /* Vec */;
    LRProduction { lhs: 0, len: 2 },
    // 4 - ItemsList: ItemsList ','^ /* Clipped */ Num;
    LRProduction { lhs: 1, len: 3 },
    // 5 - ItemsList: ;
    LRProduction { lhs: 1, len: 0 },
    // 6 - Num: /0|[1-9][0-9]*/;
    LRProduction { lhs: 4, len: 1 },
];

pub fn parse<T>(
    input: &str,
    file_name: T,
    user_actions: &mut ListGrammar,
) -> Result<ParseTree, ParolError>
where
    T: AsRef<Path>,
{
    use parol_runtime::{
        parser::{parse_tree_type::SynTree, parser_types::SynTreeFlavor},
        syntree::Builder,
    };
    let mut builder = Builder::<SynTree, SynTreeFlavor>::new_with();
    parse_into(input, &mut builder, file_name, user_actions)?;
    Ok(builder.build()?)
}
#[allow(dead_code)]
pub fn parse_into<'t, T: TreeConstruct<'t>>(
    input: &'t str,
    tree_builder: &mut T,
    file_name: impl AsRef<Path>,
    user_actions: &mut ListGrammar,
) -> Result<(), ParolError>
where
    ParolError: From<T::Error>,
{
    use list_grammar_scanner::ListGrammarScanner;
    let mut lr_parser = LRParser::new(2, &PARSE_TABLE, PRODUCTIONS, TERMINAL_NAMES, NON_TERMINALS);
    // Initialize wrapper
    let mut user_actions = ListGrammarAuto::new(user_actions);
    let scanner = ListGrammarScanner::new();
    lr_parser.parse_into(
        tree_builder,
        TokenStream::new(
            input,
            file_name,
            scanner.scanner_impl.clone(),
            &ListGrammarScanner::match_function,
            1,
        )
        .unwrap(),
        &mut user_actions,
    )
}
