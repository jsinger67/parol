// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::id_tree::Tree;

use crate::json_grammar::JsonGrammar;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use parol_runtime::{ParolError, ParserError};

///
/// The `JsonGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait JsonGrammarTrait {
    /// Semantic action for production 0:
    ///
    /// Json: Value;
    ///
    fn json(
        &mut self,
        _value: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Object: "\{" ObjectSuffix;
    ///
    fn object(
        &mut self,
        _l_brace: &ParseTreeStackEntry,
        _object_suffix: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ObjectSuffix: Pair ObjectList /* Vec */ "\}";
    ///
    fn object_suffix_0(
        &mut self,
        _pair: &ParseTreeStackEntry,
        _object_list: &ParseTreeStackEntry,
        _r_brace: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ObjectSuffix: "\}";
    ///
    fn object_suffix_1(
        &mut self,
        _r_brace: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ObjectList /* Vec<T>::Push */: "," Pair ObjectList;
    ///
    fn object_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry,
        _pair: &ParseTreeStackEntry,
        _object_list: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ObjectList /* Vec<T>::New */: ;
    ///
    fn object_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Pair: String ":" Value;
    ///
    fn pair(
        &mut self,
        _string: &ParseTreeStackEntry,
        _colon: &ParseTreeStackEntry,
        _value: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Array: "\[" ArraySuffix;
    ///
    fn array(
        &mut self,
        _l_bracket: &ParseTreeStackEntry,
        _array_suffix: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// ArraySuffix: Value ArrayList /* Vec */ "\]";
    ///
    fn array_suffix_0(
        &mut self,
        _value: &ParseTreeStackEntry,
        _array_list: &ParseTreeStackEntry,
        _r_bracket: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// ArraySuffix: "\]";
    ///
    fn array_suffix_1(
        &mut self,
        _r_bracket: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ArrayList /* Vec<T>::Push */: "," Value ArrayList;
    ///
    fn array_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry,
        _value: &ParseTreeStackEntry,
        _array_list: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ArrayList /* Vec<T>::New */: ;
    ///
    fn array_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Value: String;
    ///
    fn value_0(
        &mut self,
        _string: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Value: Number;
    ///
    fn value_1(
        &mut self,
        _number: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Value: Object;
    ///
    fn value_2(
        &mut self,
        _object: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Value: Array;
    ///
    fn value_3(
        &mut self,
        _array: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Value: "true";
    ///
    fn value_4(
        &mut self,
        _true: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Value: "false";
    ///
    fn value_5(
        &mut self,
        _false: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Value: "null";
    ///
    fn value_6(
        &mut self,
        _null: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// String: "\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}";
    ///
    fn string(
        &mut self,
        _string: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Number: "-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][-+]?(?:0|[1-9][0-9]*)?)?";
    ///
    fn number(
        &mut self,
        _number: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        Ok(())
    }
}

impl UserActionsTrait<'_> for JsonGrammar {
    ///
    /// This function is implemented automatically for the user's item JsonGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<(), ParolError> {
        match prod_num {
            0 => self.json(&children[0], parse_tree),
            1 => self.object(&children[0], &children[1], parse_tree),
            2 => self.object_suffix_0(&children[0], &children[1], &children[2], parse_tree),
            3 => self.object_suffix_1(&children[0], parse_tree),
            4 => self.object_list_0(&children[0], &children[1], &children[2], parse_tree),
            5 => self.object_list_1(parse_tree),
            6 => self.pair(&children[0], &children[1], &children[2], parse_tree),
            7 => self.array(&children[0], &children[1], parse_tree),
            8 => self.array_suffix_0(&children[0], &children[1], &children[2], parse_tree),
            9 => self.array_suffix_1(&children[0], parse_tree),
            10 => self.array_list_0(&children[0], &children[1], &children[2], parse_tree),
            11 => self.array_list_1(parse_tree),
            12 => self.value_0(&children[0], parse_tree),
            13 => self.value_1(&children[0], parse_tree),
            14 => self.value_2(&children[0], parse_tree),
            15 => self.value_3(&children[0], parse_tree),
            16 => self.value_4(&children[0], parse_tree),
            17 => self.value_5(&children[0], parse_tree),
            18 => self.value_6(&children[0], parse_tree),
            19 => self.string(&children[0], parse_tree),
            20 => self.number(&children[0], parse_tree),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
}
