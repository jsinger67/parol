// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait Oberon2GrammarTrait<'t> {
    /// Semantic action for non-terminal 'KwBegin'
    fn kw_begin(&mut self, _arg: &KwBegin) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwCase'
    fn kw_case(&mut self, _arg: &KwCase) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwDo'
    fn kw_do(&mut self, _arg: &KwDo) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwElse'
    fn kw_else(&mut self, _arg: &KwElse) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwElsif'
    fn kw_elsif(&mut self, _arg: &KwElsif) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwEnd'
    fn kw_end(&mut self, _arg: &KwEnd) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwIf'
    fn kw_if(&mut self, _arg: &KwIf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwOf'
    fn kw_of(&mut self, _arg: &KwOf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwProcedure'
    fn kw_procedure(&mut self, _arg: &KwProcedure) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwThen'
    fn kw_then(&mut self, _arg: &KwThen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwTo'
    fn kw_to(&mut self, _arg: &KwTo) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwVar'
    fn kw_var(&mut self, _arg: &KwVar) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Oberon2'
    fn oberon2(&mut self, _arg: &Oberon2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleHead'
    fn module_head(&mut self, _arg: &ModuleHead<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleBody'
    fn module_body(&mut self, _arg: &ModuleBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportList'
    fn import_list(&mut self, _arg: &ImportList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeclSeq'
    fn decl_seq(&mut self, _arg: &DeclSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeclBlock'
    fn decl_block(&mut self, _arg: &DeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDeclBlock'
    fn const_decl_block(&mut self, _arg: &ConstDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDeclBlock'
    fn type_decl_block(&mut self, _arg: &TypeDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDeclBlock'
    fn var_decl_block(&mut self, _arg: &VarDeclBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDecl'
    fn const_decl(&mut self, _arg: &ConstDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDecl'
    fn type_decl(&mut self, _arg: &TypeDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDecl'
    fn var_decl(&mut self, _arg: &VarDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcDecl'
    fn proc_decl(&mut self, _arg: &ProcDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcedureHeading'
    fn procedure_heading(&mut self, _arg: &ProcedureHeading<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProcedureBody'
    fn procedure_body(&mut self, _arg: &ProcedureBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementBlock'
    fn statement_block(&mut self, _arg: &StatementBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForwardDecl'
    fn forward_decl(&mut self, _arg: &ForwardDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FormalPars'
    fn formal_pars(&mut self, _arg: &FormalPars<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FPSection'
    fn f_p_section(&mut self, _arg: &FPSection<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Receiver'
    fn receiver(&mut self, _arg: &Receiver<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReceiverVarDecl'
    fn receiver_var_decl(&mut self, _arg: &ReceiverVarDecl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDef'
    fn type_def(&mut self, _arg: &TypeDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FieldList'
    fn field_list(&mut self, _arg: &FieldList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementSeq'
    fn statement_seq(&mut self, _arg: &StatementSeq<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ThenBlock'
    fn then_block(&mut self, _arg: &ThenBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Cases'
    fn cases(&mut self, _arg: &Cases<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElsifPart'
    fn elsif_part(&mut self, _arg: &ElsifPart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElsePart'
    fn else_part(&mut self, _arg: &ElsePart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OptElsePartEnd'
    fn opt_else_part_end(&mut self, _arg: &OptElsePartEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoBlock'
    fn do_block(&mut self, _arg: &DoBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GuardedDoBlock'
    fn guarded_do_block(&mut self, _arg: &GuardedDoBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForInit'
    fn for_init(&mut self, _arg: &ForInit<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForStep'
    fn for_step(&mut self, _arg: &ForStep<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseLabels'
    fn case_labels(&mut self, _arg: &CaseLabels<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Guard'
    fn guard(&mut self, _arg: &Guard<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstExpr'
    fn const_expr(&mut self, _arg: &ConstExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expr'
    fn expr(&mut self, _arg: &Expr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleExpr'
    fn simple_expr(&mut self, _arg: &SimpleExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Term'
    fn term(&mut self, _arg: &Term<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Set'
    fn set(&mut self, _arg: &Set<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Element'
    fn element(&mut self, _arg: &Element<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relation'
    fn relation(&mut self, _arg: &Relation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AddOp'
    fn add_op(&mut self, _arg: &AddOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MulOp'
    fn mul_op(&mut self, _arg: &MulOp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Designator'
    fn designator(&mut self, _arg: &Designator<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DesignatorSuffix'
    fn designator_suffix(&mut self, _arg: &DesignatorSuffix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExprList'
    fn expr_list(&mut self, _arg: &ExprList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentList'
    fn ident_list(&mut self, _arg: &IdentList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualIdent'
    fn qual_ident(&mut self, _arg: &QualIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentDef'
    fn ident_def(&mut self, _arg: &IdentDef<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Real'
    fn real(&mut self, _arg: &Real<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Character'
    fn character(&mut self, _arg: &Character<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QIdent'
    fn q_ident(&mut self, _arg: &QIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InOp'
    fn in_op(&mut self, _arg: &InOp) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 26
///
/// `DeclSeqList0Group: ProcDecl ";"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclSeqList0GroupProcDeclSemicolon<'t> {
    pub proc_decl: Box<ProcDecl<'t>>,
}

///
/// Type derived for production 27
///
/// `DeclSeqList0Group: ForwardDecl ";"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclSeqList0GroupForwardDeclSemicolon<'t> {
    pub forward_decl: ForwardDecl<'t>,
}

///
/// Type derived for production 31
///
/// `DeclBlock: ConstDeclBlock;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclBlockConstDeclBlock<'t> {
    pub const_decl_block: ConstDeclBlock<'t>,
}

///
/// Type derived for production 32
///
/// `DeclBlock: TypeDeclBlock;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclBlockTypeDeclBlock<'t> {
    pub type_decl_block: TypeDeclBlock<'t>,
}

///
/// Type derived for production 33
///
/// `DeclBlock: VarDeclBlock;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclBlockVarDeclBlock<'t> {
    pub var_decl_block: VarDeclBlock<'t>,
}

///
/// Type derived for production 77
///
/// `TypeDef: QualIdent;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefQualIdent<'t> {
    pub qual_ident: QualIdent<'t>,
}

///
/// Type derived for production 78
///
/// `TypeDef: "ARRAY"^ /* Clipped */ TypeDefOpt /* Option */ KwOf^ /* Clipped */ TypeDef;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefARRAYTypeDefOptKwOfTypeDef<'t> {
    pub type_def_opt: Option<Box<TypeDefOpt<'t>>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 79
///
/// `TypeDef: "RECORD"^ /* Clipped */ TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ KwEnd^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefRECORDTypeDefOpt0FieldListTypeDefListKwEnd<'t> {
    pub type_def_opt0: Option<Box<TypeDefOpt0<'t>>>,
    pub field_list: Box<FieldList<'t>>,
    pub type_def_list: Vec<TypeDefList<'t>>,
}

///
/// Type derived for production 82
///
/// `TypeDef: "POINTER"^ /* Clipped */ KwTo^ /* Clipped */ TypeDef;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefPOINTERKwToTypeDef<'t> {
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for production 83
///
/// `TypeDef: KwProcedure^ /* Clipped */ TypeDefOpt1 /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefKwProcedureTypeDefOpt1<'t> {
    pub type_def_opt1: Option<Box<TypeDefOpt1<'t>>>,
}

///
/// Type derived for production 100
///
/// `StatementOptGroup: Designator StatementOptGroupSuffix;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupDesignatorStatementOptGroupSuffix<'t> {
    pub designator: Box<Designator<'t>>,
    pub statement_opt_group_suffix: StatementOptGroupSuffix<'t>,
}

///
/// Type derived for production 101
///
/// `StatementOptGroupSuffix: ":="^ /* Clipped */ Expr;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupSuffixColonEquExpr<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 102
///
/// `StatementOptGroupSuffix: StatementOpt0 /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupSuffixStatementOpt0<'t> {
    pub statement_opt0: Option<Box<StatementOpt0<'t>>>,
}

///
/// Type derived for production 103
///
/// `StatementOptGroup: KwIf^ /* Clipped */ Expr ThenBlock StatementOptGroupList /* Vec */ OptElsePartEnd;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupKwIfExprThenBlockStatementOptGroupListOptElsePartEnd<'t> {
    pub expr: Box<Expr<'t>>,
    pub then_block: Box<ThenBlock<'t>>,
    pub statement_opt_group_list: Vec<StatementOptGroupList<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 104
///
/// `StatementOptGroup: KwCase^ /* Clipped */ Expr KwOf^ /* Clipped */ Cases OptElsePartEnd;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupKwCaseExprKwOfCasesOptElsePartEnd<'t> {
    pub expr: Box<Expr<'t>>,
    pub cases: Box<Cases<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 105
///
/// `StatementOptGroup: "WHILE"^ /* Clipped */ Expr DoBlock;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupWHILEExprDoBlock<'t> {
    pub expr: Box<Expr<'t>>,
    pub do_block: Box<DoBlock<'t>>,
}

///
/// Type derived for production 106
///
/// `StatementOptGroup: "REPEAT"^ /* Clipped */ StatementSeq "UNTIL"^ /* Clipped */ Expr;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupREPEATStatementSeqUNTILExpr<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 107
///
/// `StatementOptGroup: "FOR"^ /* Clipped */ ForInit StatementOpt1 /* Option */ DoBlock;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupFORForInitStatementOpt1DoBlock<'t> {
    pub for_init: ForInit<'t>,
    pub statement_opt1: Option<Box<StatementOpt1<'t>>>,
    pub do_block: Box<DoBlock<'t>>,
}

///
/// Type derived for production 108
///
/// `StatementOptGroup: "LOOP"^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupLOOPStatementSeqKwEnd<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for production 109
///
/// `StatementOptGroup: "WITH"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0 /* Vec */ OptElsePartEnd;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupWITHGuardedDoBlockStatementOptGroupList0OptElsePartEnd<'t> {
    pub guarded_do_block: Box<GuardedDoBlock<'t>>,
    pub statement_opt_group_list0: Vec<StatementOptGroupList0<'t>>,
    pub opt_else_part_end: Box<OptElsePartEnd<'t>>,
}

///
/// Type derived for production 110
///
/// `StatementOptGroup: "EXIT"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupEXIT {}

///
/// Type derived for production 111
///
/// `StatementOptGroup: "RETURN"^ /* Clipped */ StatementOpt2 /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupRETURNStatementOpt2<'t> {
    pub statement_opt2: Option<Box<StatementOpt2<'t>>>,
}

///
/// Type derived for production 155
///
/// `SimpleExprOptGroup: "\+";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExprOptGroupPlus<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 156
///
/// `SimpleExprOptGroup: "-";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExprOptGroupMinus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 161
///
/// `Factor: Designator FactorOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorDesignatorFactorOpt<'t> {
    pub designator: Box<Designator<'t>>,
    pub factor_opt: Option<Box<FactorOpt<'t>>>,
}

///
/// Type derived for production 162
///
/// `Factor: Number;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNumber<'t> {
    pub number: Number<'t>,
}

///
/// Type derived for production 163
///
/// `Factor: Character;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorCharacter<'t> {
    pub character: Character<'t>,
}

///
/// Type derived for production 164
///
/// `Factor: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 165
///
/// `Factor: "NIL"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNIL {}

///
/// Type derived for production 166
///
/// `Factor: Set;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorSet<'t> {
    pub set: Box<Set<'t>>,
}

///
/// Type derived for production 167
///
/// `Factor: "\("^ /* Clipped */ Expr "\)"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenExprRParen<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for production 168
///
/// `Factor: "~"^ /* Clipped */ Factor;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorTildeFactor<'t> {
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for production 181
///
/// `Relation: "="^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationEqu {}

///
/// Type derived for production 182
///
/// `Relation: "#";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationHash<'t> {
    pub hash: Token<'t>, /* # */
}

///
/// Type derived for production 183
///
/// `Relation: "<";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationLT<'t> {
    pub l_t: Token<'t>, /* < */
}

///
/// Type derived for production 184
///
/// `Relation: "<=";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationLTEqu<'t> {
    pub l_t_equ: Token<'t>, /* <= */
}

///
/// Type derived for production 185
///
/// `Relation: ">";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationGT<'t> {
    pub g_t: Token<'t>, /* > */
}

///
/// Type derived for production 186
///
/// `Relation: ">=";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationGTEqu<'t> {
    pub g_t_equ: Token<'t>, /* >= */
}

///
/// Type derived for production 187
///
/// `Relation: InOp;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationInOp {
    pub in_op: InOp,
}

///
/// Type derived for production 188
///
/// `Relation: "IS";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationIS<'t> {
    pub i_s: Token<'t>, /* IS */
}

///
/// Type derived for production 189
///
/// `AddOp: "\+";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOpPlus<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for production 190
///
/// `AddOp: "-";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOpMinus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 191
///
/// `AddOp: "OR";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AddOpOR<'t> {
    pub o_r: Token<'t>, /* OR */
}

///
/// Type derived for production 192
///
/// `MulOp: "\*";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOpStar<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 193
///
/// `MulOp: "/";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOpSlash<'t> {
    pub slash: Token<'t>, /* / */
}

///
/// Type derived for production 194
///
/// `MulOp: "DIV";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOpDIV<'t> {
    pub d_i_v: Token<'t>, /* DIV */
}

///
/// Type derived for production 195
///
/// `MulOp: "MOD";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOpMOD<'t> {
    pub m_o_d: Token<'t>, /* MOD */
}

///
/// Type derived for production 196
///
/// `MulOp: "&";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MulOpAmp<'t> {
    pub amp: Token<'t>, /* & */
}

///
/// Type derived for production 200
///
/// `DesignatorSuffix: "\."^ /* Clipped */ Ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DesignatorSuffixDotIdent<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for production 201
///
/// `DesignatorSuffix: "\["^ /* Clipped */ ExprList "\]"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DesignatorSuffixLBracketExprListRBracket<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for production 202
///
/// `DesignatorSuffix: "\^"^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DesignatorSuffixCircumflex {}

///
/// Type derived for production 209
///
/// `QualIdent: Ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualIdentIdent<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for production 210
///
/// `QualIdent: QIdent;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualIdentQIdent<'t> {
    pub q_ident: QIdent<'t>,
}

///
/// Type derived for production 213
///
/// `IdentDefOptGroup: "\*";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentDefOptGroupStar<'t> {
    pub star: Token<'t>, /* \* */
}

///
/// Type derived for production 214
///
/// `IdentDefOptGroup: "-";`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentDefOptGroupMinus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for production 216
///
/// `Number: Integer;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberInteger<'t> {
    pub integer: Integer<'t>,
}

///
/// Type derived for production 217
///
/// `Number: Real;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberReal<'t> {
    pub real: Real<'t>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AddOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AddOp<'t> {
    Plus(AddOpPlus<'t>),
    Minus(AddOpMinus<'t>),
    OR(AddOpOR<'t>),
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Case<'t> {
    pub case_opt: Option<Box<CaseOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabels
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseLabels<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub case_labels_opt: Option<Box<CaseLabelsOpt<'t>>>,
}

///
/// Type derived for non-terminal CaseLabelsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseLabelsOpt<'t> {
    pub dot_dot: Token<'t>, /* \.\. */
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal CaseOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseOpt<'t> {
    pub case_labels: CaseLabels<'t>,
    pub case_opt_list: Vec<CaseOptList<'t>>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal CaseOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseOptList<'t> {
    pub case_labels: CaseLabels<'t>,
}

///
/// Type derived for non-terminal Cases
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Cases<'t> {
    pub case: Box<Case<'t>>,
    pub cases_list: Vec<CasesList<'t>>,
}

///
/// Type derived for non-terminal CasesList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CasesList<'t> {
    pub case: Box<Case<'t>>,
}

///
/// Type derived for non-terminal Character
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Character<'t> {
    pub character: Token<'t>, /* [0-9][0-9A-F]*X */
}

///
/// Type derived for non-terminal ConstDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstDecl<'t> {
    pub ident_def: IdentDef<'t>,
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal ConstDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstDeclBlock<'t> {
    pub const_decl_block_list: Vec<ConstDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal ConstDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstDeclBlockList<'t> {
    pub const_decl: ConstDecl<'t>,
}

///
/// Type derived for non-terminal ConstExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstExpr<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal DeclBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclBlock<'t> {
    ConstDeclBlock(DeclBlockConstDeclBlock<'t>),
    TypeDeclBlock(DeclBlockTypeDeclBlock<'t>),
    VarDeclBlock(DeclBlockVarDeclBlock<'t>),
}

///
/// Type derived for non-terminal DeclSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclSeq<'t> {
    pub decl_seq_list: Vec<DeclSeqList<'t>>,
    pub decl_seq_list0: Vec<DeclSeqList0<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclSeqList<'t> {
    pub decl_block: DeclBlock<'t>,
}

///
/// Type derived for non-terminal DeclSeqList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclSeqList0<'t> {
    pub decl_seq_list0_group: Box<DeclSeqList0Group<'t>>,
}

///
/// Type derived for non-terminal DeclSeqList0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DeclSeqList0Group<'t> {
    ProcDeclSemicolon(DeclSeqList0GroupProcDeclSemicolon<'t>),
    ForwardDeclSemicolon(DeclSeqList0GroupForwardDeclSemicolon<'t>),
}

///
/// Type derived for non-terminal Designator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Designator<'t> {
    pub qual_ident: QualIdent<'t>,
    pub designator_list: Vec<DesignatorList<'t>>,
}

///
/// Type derived for non-terminal DesignatorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DesignatorList<'t> {
    pub designator_suffix: Box<DesignatorSuffix<'t>>,
}

///
/// Type derived for non-terminal DesignatorSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DesignatorSuffix<'t> {
    DotIdent(DesignatorSuffixDotIdent<'t>),
    LBracketExprListRBracket(DesignatorSuffixLBracketExprListRBracket<'t>),
    Circumflex(DesignatorSuffixCircumflex),
}

///
/// Type derived for non-terminal DoBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoBlock<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal Element
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Element<'t> {
    pub expr: Box<Expr<'t>>,
    pub element_opt: Option<Box<ElementOpt<'t>>>,
}

///
/// Type derived for non-terminal ElementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementOpt<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ElsePart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElsePart<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal ElsifPart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElsifPart<'t> {
    pub expr: Box<Expr<'t>>,
    pub then_block: Box<ThenBlock<'t>>,
}

///
/// Type derived for non-terminal Expr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expr<'t> {
    pub simple_expr: Box<SimpleExpr<'t>>,
    pub expr_opt: Option<Box<ExprOpt<'t>>>,
}

///
/// Type derived for non-terminal ExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprList<'t> {
    pub expr: Box<Expr<'t>>,
    pub expr_list_list: Vec<ExprListList<'t>>,
}

///
/// Type derived for non-terminal ExprListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprListList<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprOpt<'t> {
    pub relation: Relation<'t>,
    pub simple_expr: Box<SimpleExpr<'t>>,
}

///
/// Type derived for non-terminal FPSection
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FPSection<'t> {
    pub f_p_section_opt: Option<Box<FPSectionOpt>>,
    pub ident: Ident<'t>,
    pub f_p_section_list: Vec<FPSectionList<'t>>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal FPSectionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FPSectionList<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal FPSectionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FPSectionOpt {}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    DesignatorFactorOpt(FactorDesignatorFactorOpt<'t>),
    Number(FactorNumber<'t>),
    Character(FactorCharacter<'t>),
    String(FactorString<'t>),
    NIL(FactorNIL),
    Set(FactorSet<'t>),
    LParenExprRParen(FactorLParenExprRParen<'t>),
    TildeFactor(FactorTildeFactor<'t>),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt<'t> {
    pub factor_opt0: Option<Box<FactorOpt0<'t>>>,
}

///
/// Type derived for non-terminal FactorOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt0<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal FieldList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FieldList<'t> {
    pub field_list_opt: Option<Box<FieldListOpt<'t>>>,
}

///
/// Type derived for non-terminal FieldListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FieldListOpt<'t> {
    pub ident_list: IdentList<'t>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal ForInit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForInit<'t> {
    pub ident: Ident<'t>,
    pub expr: Box<Expr<'t>>,
    pub expr0: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ForStep
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStep<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal FormalPars
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormalPars<'t> {
    pub formal_pars_opt: Option<Box<FormalParsOpt<'t>>>,
    pub formal_pars_opt0: Option<Box<FormalParsOpt0<'t>>>,
}

///
/// Type derived for non-terminal FormalParsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormalParsOpt<'t> {
    pub f_p_section: Box<FPSection<'t>>,
    pub formal_pars_opt_list: Vec<FormalParsOptList<'t>>,
}

///
/// Type derived for non-terminal FormalParsOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormalParsOpt0<'t> {
    pub qual_ident: QualIdent<'t>,
}

///
/// Type derived for non-terminal FormalParsOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormalParsOptList<'t> {
    pub f_p_section: Box<FPSection<'t>>,
}

///
/// Type derived for non-terminal ForwardDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForwardDecl<'t> {
    pub circumflex: Token<'t>, /* \^ */
    pub forward_decl_opt: Option<Box<ForwardDeclOpt<'t>>>,
    pub ident_def: IdentDef<'t>,
    pub forward_decl_opt0: Option<Box<ForwardDeclOpt0<'t>>>,
}

///
/// Type derived for non-terminal ForwardDeclOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForwardDeclOpt<'t> {
    pub receiver: Receiver<'t>,
}

///
/// Type derived for non-terminal ForwardDeclOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForwardDeclOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal Guard
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Guard<'t> {
    pub qual_ident: QualIdent<'t>,
    pub qual_ident0: QualIdent<'t>,
}

///
/// Type derived for non-terminal GuardedDoBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GuardedDoBlock<'t> {
    pub guard: Guard<'t>,
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal IdentDef
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentDef<'t> {
    pub ident: Ident<'t>,
    pub ident_def_opt: Option<Box<IdentDefOpt<'t>>>,
}

///
/// Type derived for non-terminal IdentDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentDefOpt<'t> {
    pub ident_def_opt_group: IdentDefOptGroup<'t>,
}

///
/// Type derived for non-terminal IdentDefOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentDefOptGroup<'t> {
    Star(IdentDefOptGroupStar<'t>),
    Minus(IdentDefOptGroupMinus<'t>),
}

///
/// Type derived for non-terminal IdentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentList<'t> {
    pub ident_def: IdentDef<'t>,
    pub ident_list_list: Vec<IdentListList<'t>>,
}

///
/// Type derived for non-terminal IdentListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentListList<'t> {
    pub ident_def: IdentDef<'t>,
}

///
/// Type derived for non-terminal ImportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportList<'t> {
    pub import_list_opt: Option<Box<ImportListOpt<'t>>>,
    pub ident: Ident<'t>,
    pub import_list_list: Vec<ImportListList<'t>>,
}

///
/// Type derived for non-terminal ImportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportListList<'t> {
    pub import_list_opt0: Option<Box<ImportListOpt0<'t>>>,
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal ImportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportListOpt<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal ImportListOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportListOpt0<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal InOp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InOp {}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* [0-9][0-9]*|[0-9][0-9A-F]*H */
}

///
/// Type derived for non-terminal KwBegin
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwBegin {}

///
/// Type derived for non-terminal KwCase
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwCase {}

///
/// Type derived for non-terminal KwDo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwDo {}

///
/// Type derived for non-terminal KwElse
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwElse {}

///
/// Type derived for non-terminal KwElsif
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwElsif {}

///
/// Type derived for non-terminal KwEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwEnd {}

///
/// Type derived for non-terminal KwIf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwIf {}

///
/// Type derived for non-terminal KwOf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwOf {}

///
/// Type derived for non-terminal KwProcedure
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwProcedure {}

///
/// Type derived for non-terminal KwThen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwThen {}

///
/// Type derived for non-terminal KwTo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwTo {}

///
/// Type derived for non-terminal KwVar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwVar {}

///
/// Type derived for non-terminal ModuleBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleBody<'t> {
    pub statement_block: StatementBlock<'t>,
}

///
/// Type derived for non-terminal ModuleHead
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleHead<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal MulOp
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MulOp<'t> {
    Star(MulOpStar<'t>),
    Slash(MulOpSlash<'t>),
    DIV(MulOpDIV<'t>),
    MOD(MulOpMOD<'t>),
    Amp(MulOpAmp<'t>),
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number<'t> {
    Integer(NumberInteger<'t>),
    Real(NumberReal<'t>),
}

///
/// Type derived for non-terminal Oberon2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Oberon2<'t> {
    pub module_head: ModuleHead<'t>,
    pub oberon2_opt: Option<Box<Oberon2Opt<'t>>>,
    pub decl_seq: Box<DeclSeq<'t>>,
    pub module_body: ModuleBody<'t>,
}

///
/// Type derived for non-terminal Oberon2Opt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Oberon2Opt<'t> {
    pub import_list: ImportList<'t>,
}

///
/// Type derived for non-terminal OptElsePartEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OptElsePartEnd<'t> {
    pub opt_else_part_end_opt: Option<Box<OptElsePartEndOpt<'t>>>,
}

///
/// Type derived for non-terminal OptElsePartEndOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OptElsePartEndOpt<'t> {
    pub else_part: Box<ElsePart<'t>>,
}

///
/// Type derived for non-terminal ProcDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProcDecl<'t> {
    pub procedure_heading: ProcedureHeading<'t>,
    pub procedure_body: Box<ProcedureBody<'t>>,
}

///
/// Type derived for non-terminal ProcedureBody
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProcedureBody<'t> {
    pub decl_seq: Box<DeclSeq<'t>>,
    pub statement_block: StatementBlock<'t>,
}

///
/// Type derived for non-terminal ProcedureHeading
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProcedureHeading<'t> {
    pub procedure_heading_opt: Option<Box<ProcedureHeadingOpt<'t>>>,
    pub ident_def: IdentDef<'t>,
    pub procedure_heading_opt0: Option<Box<ProcedureHeadingOpt0<'t>>>,
}

///
/// Type derived for non-terminal ProcedureHeadingOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProcedureHeadingOpt<'t> {
    pub receiver: Receiver<'t>,
}

///
/// Type derived for non-terminal ProcedureHeadingOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProcedureHeadingOpt0<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal QIdent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QIdent<'t> {
    pub q_ident: Token<'t>, /* [a-zA-Z_]\w*\.[a-zA-Z_]\w* */
}

///
/// Type derived for non-terminal QualIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QualIdent<'t> {
    Ident(QualIdentIdent<'t>),
    QIdent(QualIdentQIdent<'t>),
}

///
/// Type derived for non-terminal Real
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Real<'t> {
    pub real: Token<'t>, /* [0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)? */
}

///
/// Type derived for non-terminal Receiver
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Receiver<'t> {
    pub receiver_opt: Option<Box<ReceiverOpt>>,
    pub receiver_var_decl: ReceiverVarDecl<'t>,
}

///
/// Type derived for non-terminal ReceiverOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReceiverOpt {}

///
/// Type derived for non-terminal ReceiverVarDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReceiverVarDecl<'t> {
    pub ident: Ident<'t>,
    pub ident0: Ident<'t>,
}

///
/// Type derived for non-terminal Relation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Relation<'t> {
    Equ(RelationEqu),
    Hash(RelationHash<'t>),
    LT(RelationLT<'t>),
    LTEqu(RelationLTEqu<'t>),
    GT(RelationGT<'t>),
    GTEqu(RelationGTEqu<'t>),
    InOp(RelationInOp),
    IS(RelationIS<'t>),
}

///
/// Type derived for non-terminal Set
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Set<'t> {
    pub set_opt: Option<Box<SetOpt<'t>>>,
}

///
/// Type derived for non-terminal SetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SetOpt<'t> {
    pub element: Box<Element<'t>>,
    pub set_opt_list: Vec<SetOptList<'t>>,
}

///
/// Type derived for non-terminal SetOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SetOptList<'t> {
    pub element: Box<Element<'t>>,
}

///
/// Type derived for non-terminal SimpleExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExpr<'t> {
    pub simple_expr_opt: Option<Box<SimpleExprOpt<'t>>>,
    pub term: Box<Term<'t>>,
    pub simple_expr_list: Vec<SimpleExprList<'t>>,
}

///
/// Type derived for non-terminal SimpleExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExprList<'t> {
    pub add_op: AddOp<'t>,
    pub term: Box<Term<'t>>,
}

///
/// Type derived for non-terminal SimpleExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleExprOpt<'t> {
    pub simple_expr_opt_group: SimpleExprOptGroup<'t>,
}

///
/// Type derived for non-terminal SimpleExprOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SimpleExprOptGroup<'t> {
    Plus(SimpleExprOptGroupPlus<'t>),
    Minus(SimpleExprOptGroupMinus<'t>),
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Statement<'t> {
    pub statement_opt: Option<Box<StatementOpt<'t>>>,
}

///
/// Type derived for non-terminal StatementBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementBlock<'t> {
    pub statement_block_opt: Option<Box<StatementBlockOpt<'t>>>,
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal StatementBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementBlockOpt<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal StatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOpt<'t> {
    pub statement_opt_group: Box<StatementOptGroup<'t>>,
}

///
/// Type derived for non-terminal StatementOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOpt0<'t> {
    pub statement_opt3: Option<Box<StatementOpt3<'t>>>,
}

///
/// Type derived for non-terminal StatementOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOpt1<'t> {
    pub for_step: ForStep<'t>,
}

///
/// Type derived for non-terminal StatementOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOpt2<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal StatementOpt3
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOpt3<'t> {
    pub expr_list: Box<ExprList<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementOptGroup<'t> {
    DesignatorStatementOptGroupSuffix(StatementOptGroupDesignatorStatementOptGroupSuffix<'t>),
    KwIfExprThenBlockStatementOptGroupListOptElsePartEnd(
        StatementOptGroupKwIfExprThenBlockStatementOptGroupListOptElsePartEnd<'t>,
    ),
    KwCaseExprKwOfCasesOptElsePartEnd(StatementOptGroupKwCaseExprKwOfCasesOptElsePartEnd<'t>),
    WHILEExprDoBlock(StatementOptGroupWHILEExprDoBlock<'t>),
    REPEATStatementSeqUNTILExpr(StatementOptGroupREPEATStatementSeqUNTILExpr<'t>),
    FORForInitStatementOpt1DoBlock(StatementOptGroupFORForInitStatementOpt1DoBlock<'t>),
    LOOPStatementSeqKwEnd(StatementOptGroupLOOPStatementSeqKwEnd<'t>),
    WITHGuardedDoBlockStatementOptGroupList0OptElsePartEnd(
        StatementOptGroupWITHGuardedDoBlockStatementOptGroupList0OptElsePartEnd<'t>,
    ),
    EXIT(StatementOptGroupEXIT),
    RETURNStatementOpt2(StatementOptGroupRETURNStatementOpt2<'t>),
}

///
/// Type derived for non-terminal StatementOptGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupList<'t> {
    pub elsif_part: Box<ElsifPart<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroupList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementOptGroupList0<'t> {
    pub guarded_do_block: Box<GuardedDoBlock<'t>>,
}

///
/// Type derived for non-terminal StatementOptGroupSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementOptGroupSuffix<'t> {
    ColonEquExpr(StatementOptGroupSuffixColonEquExpr<'t>),
    StatementOpt0(StatementOptGroupSuffixStatementOpt0<'t>),
}

///
/// Type derived for non-terminal StatementSeq
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementSeq<'t> {
    pub statement: Box<Statement<'t>>,
    pub statement_seq_list: Vec<StatementSeqList<'t>>,
}

///
/// Type derived for non-terminal StatementSeqList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementSeqList<'t> {
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String<'t> {
    pub string: Token<'t>, /* \u{0022}[^\u{0022}]*\u{0022}|'[^']*' */
}

///
/// Type derived for non-terminal Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Term<'t> {
    pub factor: Box<Factor<'t>>,
    pub term_list: Vec<TermList<'t>>,
}

///
/// Type derived for non-terminal TermList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermList<'t> {
    pub mul_op: MulOp<'t>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal ThenBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ThenBlock<'t> {
    pub statement_seq: Box<StatementSeq<'t>>,
}

///
/// Type derived for non-terminal TypeDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDecl<'t> {
    pub ident_def: IdentDef<'t>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal TypeDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDeclBlock<'t> {
    pub type_decl_block_list: Vec<TypeDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal TypeDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDeclBlockList<'t> {
    pub type_decl: TypeDecl<'t>,
}

///
/// Type derived for non-terminal TypeDef
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeDef<'t> {
    QualIdent(TypeDefQualIdent<'t>),
    ARRAYTypeDefOptKwOfTypeDef(TypeDefARRAYTypeDefOptKwOfTypeDef<'t>),
    RECORDTypeDefOpt0FieldListTypeDefListKwEnd(
        TypeDefRECORDTypeDefOpt0FieldListTypeDefListKwEnd<'t>,
    ),
    POINTERKwToTypeDef(TypeDefPOINTERKwToTypeDef<'t>),
    KwProcedureTypeDefOpt1(TypeDefKwProcedureTypeDefOpt1<'t>),
}

///
/// Type derived for non-terminal TypeDefList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefList<'t> {
    pub field_list: Box<FieldList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefOpt<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
    pub type_def_opt_list: Vec<TypeDefOptList<'t>>,
}

///
/// Type derived for non-terminal TypeDefOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefOpt0<'t> {
    pub qual_ident: QualIdent<'t>,
}

///
/// Type derived for non-terminal TypeDefOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefOpt1<'t> {
    pub formal_pars: Box<FormalPars<'t>>,
}

///
/// Type derived for non-terminal TypeDefOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDefOptList<'t> {
    pub const_expr: Box<ConstExpr<'t>>,
}

///
/// Type derived for non-terminal VarDecl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDecl<'t> {
    pub ident_list: IdentList<'t>,
    pub type_def: Box<TypeDef<'t>>,
}

///
/// Type derived for non-terminal VarDeclBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclBlock<'t> {
    pub var_decl_block_list: Vec<VarDeclBlockList<'t>>,
}

///
/// Type derived for non-terminal VarDeclBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclBlockList<'t> {
    pub var_decl: VarDecl<'t>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AddOp(AddOp<'t>),
    Case(Case<'t>),
    CaseLabels(CaseLabels<'t>),
    CaseLabelsOpt(Option<Box<CaseLabelsOpt<'t>>>),
    CaseOpt(Option<Box<CaseOpt<'t>>>),
    CaseOptList(Vec<CaseOptList<'t>>),
    Cases(Cases<'t>),
    CasesList(Vec<CasesList<'t>>),
    Character(Character<'t>),
    ConstDecl(ConstDecl<'t>),
    ConstDeclBlock(ConstDeclBlock<'t>),
    ConstDeclBlockList(Vec<ConstDeclBlockList<'t>>),
    ConstExpr(ConstExpr<'t>),
    DeclBlock(DeclBlock<'t>),
    DeclSeq(DeclSeq<'t>),
    DeclSeqList(Vec<DeclSeqList<'t>>),
    DeclSeqList0(Vec<DeclSeqList0<'t>>),
    DeclSeqList0Group(DeclSeqList0Group<'t>),
    Designator(Designator<'t>),
    DesignatorList(Vec<DesignatorList<'t>>),
    DesignatorSuffix(DesignatorSuffix<'t>),
    DoBlock(DoBlock<'t>),
    Element(Element<'t>),
    ElementOpt(Option<Box<ElementOpt<'t>>>),
    ElsePart(ElsePart<'t>),
    ElsifPart(ElsifPart<'t>),
    Expr(Expr<'t>),
    ExprList(ExprList<'t>),
    ExprListList(Vec<ExprListList<'t>>),
    ExprOpt(Option<Box<ExprOpt<'t>>>),
    FPSection(FPSection<'t>),
    FPSectionList(Vec<FPSectionList<'t>>),
    FPSectionOpt(Option<Box<FPSectionOpt>>),
    Factor(Factor<'t>),
    FactorOpt(Option<Box<FactorOpt<'t>>>),
    FactorOpt0(Option<Box<FactorOpt0<'t>>>),
    FieldList(FieldList<'t>),
    FieldListOpt(Option<Box<FieldListOpt<'t>>>),
    ForInit(ForInit<'t>),
    ForStep(ForStep<'t>),
    FormalPars(FormalPars<'t>),
    FormalParsOpt(Option<Box<FormalParsOpt<'t>>>),
    FormalParsOpt0(Option<Box<FormalParsOpt0<'t>>>),
    FormalParsOptList(Vec<FormalParsOptList<'t>>),
    ForwardDecl(ForwardDecl<'t>),
    ForwardDeclOpt(Option<Box<ForwardDeclOpt<'t>>>),
    ForwardDeclOpt0(Option<Box<ForwardDeclOpt0<'t>>>),
    Guard(Guard<'t>),
    GuardedDoBlock(GuardedDoBlock<'t>),
    Ident(Ident<'t>),
    IdentDef(IdentDef<'t>),
    IdentDefOpt(Option<Box<IdentDefOpt<'t>>>),
    IdentDefOptGroup(IdentDefOptGroup<'t>),
    IdentList(IdentList<'t>),
    IdentListList(Vec<IdentListList<'t>>),
    ImportList(ImportList<'t>),
    ImportListList(Vec<ImportListList<'t>>),
    ImportListOpt(Option<Box<ImportListOpt<'t>>>),
    ImportListOpt0(Option<Box<ImportListOpt0<'t>>>),
    InOp(InOp),
    Integer(Integer<'t>),
    KwBegin(KwBegin),
    KwCase(KwCase),
    KwDo(KwDo),
    KwElse(KwElse),
    KwElsif(KwElsif),
    KwEnd(KwEnd),
    KwIf(KwIf),
    KwOf(KwOf),
    KwProcedure(KwProcedure),
    KwThen(KwThen),
    KwTo(KwTo),
    KwVar(KwVar),
    ModuleBody(ModuleBody<'t>),
    ModuleHead(ModuleHead<'t>),
    MulOp(MulOp<'t>),
    Number(Number<'t>),
    Oberon2(Oberon2<'t>),
    Oberon2Opt(Option<Box<Oberon2Opt<'t>>>),
    OptElsePartEnd(OptElsePartEnd<'t>),
    OptElsePartEndOpt(Option<Box<OptElsePartEndOpt<'t>>>),
    ProcDecl(ProcDecl<'t>),
    ProcedureBody(ProcedureBody<'t>),
    ProcedureHeading(ProcedureHeading<'t>),
    ProcedureHeadingOpt(Option<Box<ProcedureHeadingOpt<'t>>>),
    ProcedureHeadingOpt0(Option<Box<ProcedureHeadingOpt0<'t>>>),
    QIdent(QIdent<'t>),
    QualIdent(QualIdent<'t>),
    Real(Real<'t>),
    Receiver(Receiver<'t>),
    ReceiverOpt(Option<Box<ReceiverOpt>>),
    ReceiverVarDecl(ReceiverVarDecl<'t>),
    Relation(Relation<'t>),
    Set(Set<'t>),
    SetOpt(Option<Box<SetOpt<'t>>>),
    SetOptList(Vec<SetOptList<'t>>),
    SimpleExpr(SimpleExpr<'t>),
    SimpleExprList(Vec<SimpleExprList<'t>>),
    SimpleExprOpt(Option<Box<SimpleExprOpt<'t>>>),
    SimpleExprOptGroup(SimpleExprOptGroup<'t>),
    Statement(Statement<'t>),
    StatementBlock(StatementBlock<'t>),
    StatementBlockOpt(Option<Box<StatementBlockOpt<'t>>>),
    StatementOpt(Option<Box<StatementOpt<'t>>>),
    StatementOpt0(Option<Box<StatementOpt0<'t>>>),
    StatementOpt1(Option<Box<StatementOpt1<'t>>>),
    StatementOpt2(Option<Box<StatementOpt2<'t>>>),
    StatementOpt3(Option<Box<StatementOpt3<'t>>>),
    StatementOptGroup(StatementOptGroup<'t>),
    StatementOptGroupList(Vec<StatementOptGroupList<'t>>),
    StatementOptGroupList0(Vec<StatementOptGroupList0<'t>>),
    StatementOptGroupSuffix(StatementOptGroupSuffix<'t>),
    StatementSeq(StatementSeq<'t>),
    StatementSeqList(Vec<StatementSeqList<'t>>),
    String(String<'t>),
    Term(Term<'t>),
    TermList(Vec<TermList<'t>>),
    ThenBlock(ThenBlock<'t>),
    TypeDecl(TypeDecl<'t>),
    TypeDeclBlock(TypeDeclBlock<'t>),
    TypeDeclBlockList(Vec<TypeDeclBlockList<'t>>),
    TypeDef(TypeDef<'t>),
    TypeDefList(Vec<TypeDefList<'t>>),
    TypeDefOpt(Option<Box<TypeDefOpt<'t>>>),
    TypeDefOpt0(Option<Box<TypeDefOpt0<'t>>>),
    TypeDefOpt1(Option<Box<TypeDefOpt1<'t>>>),
    TypeDefOptList(Vec<TypeDefOptList<'t>>),
    VarDecl(VarDecl<'t>),
    VarDeclBlock(VarDeclBlock<'t>),
    VarDeclBlockList(Vec<VarDeclBlockList<'t>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct Oberon2GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `Oberon2GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> Oberon2GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn Oberon2GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `KwBegin: "BEGIN"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_begin(&mut self, _kw_begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_begin_built = KwBegin {
        // Ignore clipped member 'kw_begin'
        };
        // Calling user action here
        self.user_grammar.kw_begin(&kw_begin_built)?;
        self.push(ASTType::KwBegin(kw_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `KwCase: "CASE"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_case(&mut self, _kw_case: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_case_built = KwCase {
        // Ignore clipped member 'kw_case'
        };
        // Calling user action here
        self.user_grammar.kw_case(&kw_case_built)?;
        self.push(ASTType::KwCase(kw_case_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `KwDo: "DO"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_do(&mut self, _kw_do: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_do_built = KwDo {
        // Ignore clipped member 'kw_do'
        };
        // Calling user action here
        self.user_grammar.kw_do(&kw_do_built)?;
        self.push(ASTType::KwDo(kw_do_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `KwElse: "ELSE"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_else(&mut self, _kw_else: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_else_built = KwElse {
        // Ignore clipped member 'kw_else'
        };
        // Calling user action here
        self.user_grammar.kw_else(&kw_else_built)?;
        self.push(ASTType::KwElse(kw_else_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `KwElsif: "ELSIF"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_elsif(&mut self, _kw_elsif: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_elsif_built = KwElsif {
        // Ignore clipped member 'kw_elsif'
        };
        // Calling user action here
        self.user_grammar.kw_elsif(&kw_elsif_built)?;
        self.push(ASTType::KwElsif(kw_elsif_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `KwEnd: "END"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_end(&mut self, _kw_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_end_built = KwEnd {
        // Ignore clipped member 'kw_end'
        };
        // Calling user action here
        self.user_grammar.kw_end(&kw_end_built)?;
        self.push(ASTType::KwEnd(kw_end_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `KwIf: "IF"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_if(&mut self, _kw_if: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_if_built = KwIf {
        // Ignore clipped member 'kw_if'
        };
        // Calling user action here
        self.user_grammar.kw_if(&kw_if_built)?;
        self.push(ASTType::KwIf(kw_if_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `KwOf: "OF"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_of(&mut self, _kw_of: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_of_built = KwOf {
        // Ignore clipped member 'kw_of'
        };
        // Calling user action here
        self.user_grammar.kw_of(&kw_of_built)?;
        self.push(ASTType::KwOf(kw_of_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `KwProcedure: "PROCEDURE"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_procedure(&mut self, _kw_procedure: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_procedure_built = KwProcedure {
        // Ignore clipped member 'kw_procedure'
        };
        // Calling user action here
        self.user_grammar.kw_procedure(&kw_procedure_built)?;
        self.push(ASTType::KwProcedure(kw_procedure_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `KwThen: "THEN"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_then(&mut self, _kw_then: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_then_built = KwThen {
        // Ignore clipped member 'kw_then'
        };
        // Calling user action here
        self.user_grammar.kw_then(&kw_then_built)?;
        self.push(ASTType::KwThen(kw_then_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `KwTo: "TO"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_to(&mut self, _kw_to: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_to_built = KwTo {
        // Ignore clipped member 'kw_to'
        };
        // Calling user action here
        self.user_grammar.kw_to(&kw_to_built)?;
        self.push(ASTType::KwTo(kw_to_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `KwVar: "VAR"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn kw_var(&mut self, _kw_var: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_var_built = KwVar {
        // Ignore clipped member 'kw_var'
        };
        // Calling user action here
        self.user_grammar.kw_var(&kw_var_built)?;
        self.push(ASTType::KwVar(kw_var_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `Oberon2: ModuleHead Oberon2Opt /* Option */ DeclSeq ModuleBody;`
    ///
    #[parol_runtime::function_name::named]
    fn oberon2(
        &mut self,
        _module_head: &ParseTreeType<'t>,
        _oberon2_opt: &ParseTreeType<'t>,
        _decl_seq: &ParseTreeType<'t>,
        _module_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_body = pop_item!(self, module_body, ModuleBody, context);
        let decl_seq = pop_item!(self, decl_seq, DeclSeq, context);
        let oberon2_opt = pop_item!(self, oberon2_opt, Oberon2Opt, context);
        let module_head = pop_item!(self, module_head, ModuleHead, context);
        let oberon2_built = Oberon2 {
            module_head,
            oberon2_opt,
            decl_seq: Box::new(decl_seq),
            module_body,
        };
        // Calling user action here
        self.user_grammar.oberon2(&oberon2_built)?;
        self.push(ASTType::Oberon2(oberon2_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `Oberon2Opt /* Option<T>::Some */: ImportList;`
    ///
    #[parol_runtime::function_name::named]
    fn oberon2_opt_0(&mut self, _import_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list = pop_item!(self, import_list, ImportList, context);
        let oberon2_opt_0_built = Oberon2Opt { import_list };
        self.push(
            ASTType::Oberon2Opt(Some(Box::new(oberon2_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Oberon2Opt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn oberon2_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Oberon2Opt(None), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `ModuleHead: "MODULE"^ /* Clipped */ Ident ";"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn module_head(
        &mut self,
        _m_o_d_u_l_e: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let module_head_built = ModuleHead {
            // Ignore clipped member 'm_o_d_u_l_e'
            ident,
            // Ignore clipped member 'semicolon'
        };
        // Calling user action here
        self.user_grammar.module_head(&module_head_built)?;
        self.push(ASTType::ModuleHead(module_head_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `ModuleBody: StatementBlock "\."^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn module_body(
        &mut self,
        _statement_block: &ParseTreeType<'t>,
        _dot: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let module_body_built = ModuleBody {
            statement_block,
            // Ignore clipped member 'dot'
        };
        // Calling user action here
        self.user_grammar.module_body(&module_body_built)?;
        self.push(ASTType::ModuleBody(module_body_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `ImportList: "IMPORT"^ /* Clipped */ ImportListOpt /* Option */ Ident ImportListList /* Vec */ ";"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list(
        &mut self,
        _i_m_p_o_r_t: &ParseTreeType<'t>,
        _import_list_opt: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list =
            pop_and_reverse_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt = pop_item!(self, import_list_opt, ImportListOpt, context);
        let import_list_built = ImportList {
            // Ignore clipped member 'i_m_p_o_r_t'
            import_list_opt,
            ident,
            import_list_list,
            // Ignore clipped member 'semicolon'
        };
        // Calling user action here
        self.user_grammar.import_list(&import_list_built)?;
        self.push(ASTType::ImportList(import_list_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `ImportListList /* Vec<T>::Push */: ","^ /* Clipped */ ImportListOpt0 /* Option */ Ident ImportListList;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _import_list_opt0: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _import_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut import_list_list = pop_item!(self, import_list_list, ImportListList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt0 = pop_item!(self, import_list_opt0, ImportListOpt0, context);
        let import_list_list_0_built = ImportListList {
            ident,
            import_list_opt0,
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        import_list_list.push(import_list_list_0_built);
        self.push(ASTType::ImportListList(import_list_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `ImportListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_list_list_1_built = Vec::new();
        self.push(ASTType::ImportListList(import_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `ImportListOpt0 /* Option<T>::Some */: Ident ":="^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_opt0_0(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon_equ: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt0_0_built = ImportListOpt0 {
            ident,
            // Ignore clipped member 'colon_equ'
        };
        self.push(
            ASTType::ImportListOpt0(Some(Box::new(import_list_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `ImportListOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `ImportListOpt /* Option<T>::Some */: Ident ":="^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_opt_0(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon_equ: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let import_list_opt_0_built = ImportListOpt {
            ident,
            // Ignore clipped member 'colon_equ'
        };
        self.push(
            ASTType::ImportListOpt(Some(Box::new(import_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `ImportListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `DeclSeq: DeclSeqList /* Vec */ DeclSeqList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq(
        &mut self,
        _decl_seq_list: &ParseTreeType<'t>,
        _decl_seq_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0 = pop_and_reverse_item!(self, decl_seq_list0, DeclSeqList0, context);
        let decl_seq_list = pop_and_reverse_item!(self, decl_seq_list, DeclSeqList, context);
        let decl_seq_built = DeclSeq {
            decl_seq_list,
            decl_seq_list0,
        };
        // Calling user action here
        self.user_grammar.decl_seq(&decl_seq_built)?;
        self.push(ASTType::DeclSeq(decl_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `DeclSeqList0 /* Vec<T>::Push */: DeclSeqList0Group DeclSeqList0;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list0_0(
        &mut self,
        _decl_seq_list0_group: &ParseTreeType<'t>,
        _decl_seq_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list0 = pop_item!(self, decl_seq_list0, DeclSeqList0, context);
        let decl_seq_list0_group =
            pop_item!(self, decl_seq_list0_group, DeclSeqList0Group, context);
        let decl_seq_list0_0_built = DeclSeqList0 {
            decl_seq_list0_group: Box::new(decl_seq_list0_group),
        };
        // Add an element to the vector
        decl_seq_list0.push(decl_seq_list0_0_built);
        self.push(ASTType::DeclSeqList0(decl_seq_list0), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `DeclSeqList0Group: ProcDecl ";"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list0_group_0(
        &mut self,
        _proc_decl: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proc_decl = pop_item!(self, proc_decl, ProcDecl, context);
        let decl_seq_list0_group_0_built = DeclSeqList0GroupProcDeclSemicolon {
            proc_decl: Box::new(proc_decl),
            // Ignore clipped member 'semicolon'
        };
        let decl_seq_list0_group_0_built =
            DeclSeqList0Group::ProcDeclSemicolon(decl_seq_list0_group_0_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `DeclSeqList0Group: ForwardDecl ";"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list0_group_1(
        &mut self,
        _forward_decl: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let forward_decl = pop_item!(self, forward_decl, ForwardDecl, context);
        let decl_seq_list0_group_1_built = DeclSeqList0GroupForwardDeclSemicolon {
            forward_decl,
            // Ignore clipped member 'semicolon'
        };
        let decl_seq_list0_group_1_built =
            DeclSeqList0Group::ForwardDeclSemicolon(decl_seq_list0_group_1_built);
        self.push(
            ASTType::DeclSeqList0Group(decl_seq_list0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `DeclSeqList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list0_1_built = Vec::new();
        self.push(ASTType::DeclSeqList0(decl_seq_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `DeclSeqList /* Vec<T>::Push */: DeclBlock DeclSeqList;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list_0(
        &mut self,
        _decl_block: &ParseTreeType<'t>,
        _decl_seq_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut decl_seq_list = pop_item!(self, decl_seq_list, DeclSeqList, context);
        let decl_block = pop_item!(self, decl_block, DeclBlock, context);
        let decl_seq_list_0_built = DeclSeqList { decl_block };
        // Add an element to the vector
        decl_seq_list.push(decl_seq_list_0_built);
        self.push(ASTType::DeclSeqList(decl_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `DeclSeqList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_seq_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decl_seq_list_1_built = Vec::new();
        self.push(ASTType::DeclSeqList(decl_seq_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `DeclBlock: ConstDeclBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_block_0(&mut self, _const_decl_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block = pop_item!(self, const_decl_block, ConstDeclBlock, context);
        let decl_block_0_built = DeclBlockConstDeclBlock { const_decl_block };
        let decl_block_0_built = DeclBlock::ConstDeclBlock(decl_block_0_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_0_built)?;
        self.push(ASTType::DeclBlock(decl_block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `DeclBlock: TypeDeclBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_block_1(&mut self, _type_decl_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block = pop_item!(self, type_decl_block, TypeDeclBlock, context);
        let decl_block_1_built = DeclBlockTypeDeclBlock { type_decl_block };
        let decl_block_1_built = DeclBlock::TypeDeclBlock(decl_block_1_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_1_built)?;
        self.push(ASTType::DeclBlock(decl_block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `DeclBlock: VarDeclBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn decl_block_2(&mut self, _var_decl_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block = pop_item!(self, var_decl_block, VarDeclBlock, context);
        let decl_block_2_built = DeclBlockVarDeclBlock { var_decl_block };
        let decl_block_2_built = DeclBlock::VarDeclBlock(decl_block_2_built);
        // Calling user action here
        self.user_grammar.decl_block(&decl_block_2_built)?;
        self.push(ASTType::DeclBlock(decl_block_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `ConstDeclBlock: "CONST"^ /* Clipped */ ConstDeclBlockList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_decl_block(
        &mut self,
        _c_o_n_s_t: &ParseTreeType<'t>,
        _const_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block_list =
            pop_and_reverse_item!(self, const_decl_block_list, ConstDeclBlockList, context);
        let const_decl_block_built = ConstDeclBlock {
            // Ignore clipped member 'c_o_n_s_t'
            const_decl_block_list,
        };
        // Calling user action here
        self.user_grammar
            .const_decl_block(&const_decl_block_built)?;
        self.push(ASTType::ConstDeclBlock(const_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `ConstDeclBlockList /* Vec<T>::Push */: ConstDecl ";"^ /* Clipped */ ConstDeclBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn const_decl_block_list_0(
        &mut self,
        _const_decl: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _const_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut const_decl_block_list =
            pop_item!(self, const_decl_block_list, ConstDeclBlockList, context);
        let const_decl = pop_item!(self, const_decl, ConstDecl, context);
        let const_decl_block_list_0_built = ConstDeclBlockList {
            // Ignore clipped member 'semicolon'
            const_decl,
        };
        // Add an element to the vector
        const_decl_block_list.push(const_decl_block_list_0_built);
        self.push(ASTType::ConstDeclBlockList(const_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `ConstDeclBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn const_decl_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::ConstDeclBlockList(const_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `TypeDeclBlock: "TYPE"^ /* Clipped */ TypeDeclBlockList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_decl_block(
        &mut self,
        _t_y_p_e: &ParseTreeType<'t>,
        _type_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block_list =
            pop_and_reverse_item!(self, type_decl_block_list, TypeDeclBlockList, context);
        let type_decl_block_built = TypeDeclBlock {
            // Ignore clipped member 't_y_p_e'
            type_decl_block_list,
        };
        // Calling user action here
        self.user_grammar.type_decl_block(&type_decl_block_built)?;
        self.push(ASTType::TypeDeclBlock(type_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `TypeDeclBlockList /* Vec<T>::Push */: TypeDecl ";"^ /* Clipped */ TypeDeclBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn type_decl_block_list_0(
        &mut self,
        _type_decl: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _type_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_decl_block_list =
            pop_item!(self, type_decl_block_list, TypeDeclBlockList, context);
        let type_decl = pop_item!(self, type_decl, TypeDecl, context);
        let type_decl_block_list_0_built = TypeDeclBlockList {
            // Ignore clipped member 'semicolon'
            type_decl,
        };
        // Add an element to the vector
        type_decl_block_list.push(type_decl_block_list_0_built);
        self.push(ASTType::TypeDeclBlockList(type_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `TypeDeclBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_decl_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::TypeDeclBlockList(type_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `VarDeclBlock: KwVar^ /* Clipped */ VarDeclBlockList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn var_decl_block(
        &mut self,
        _kw_var: &ParseTreeType<'t>,
        _var_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block_list =
            pop_and_reverse_item!(self, var_decl_block_list, VarDeclBlockList, context);
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let var_decl_block_built = VarDeclBlock {
            // Ignore clipped member 'kw_var'
            var_decl_block_list,
        };
        // Calling user action here
        self.user_grammar.var_decl_block(&var_decl_block_built)?;
        self.push(ASTType::VarDeclBlock(var_decl_block_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `VarDeclBlockList /* Vec<T>::Push */: VarDecl ";"^ /* Clipped */ VarDeclBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn var_decl_block_list_0(
        &mut self,
        _var_decl: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _var_decl_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut var_decl_block_list =
            pop_item!(self, var_decl_block_list, VarDeclBlockList, context);
        let var_decl = pop_item!(self, var_decl, VarDecl, context);
        let var_decl_block_list_0_built = VarDeclBlockList {
            // Ignore clipped member 'semicolon'
            var_decl,
        };
        // Add an element to the vector
        var_decl_block_list.push(var_decl_block_list_0_built);
        self.push(ASTType::VarDeclBlockList(var_decl_block_list), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `VarDeclBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn var_decl_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_decl_block_list_1_built = Vec::new();
        self.push(
            ASTType::VarDeclBlockList(var_decl_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `ConstDecl: IdentDef "="^ /* Clipped */ ConstExpr;`
    ///
    #[parol_runtime::function_name::named]
    fn const_decl(
        &mut self,
        _ident_def: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _const_expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let const_decl_built = ConstDecl {
            ident_def,
            // Ignore clipped member 'equ'
            const_expr: Box::new(const_expr),
        };
        // Calling user action here
        self.user_grammar.const_decl(&const_decl_built)?;
        self.push(ASTType::ConstDecl(const_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `TypeDecl: IdentDef "="^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn type_decl(
        &mut self,
        _ident_def: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let type_decl_built = TypeDecl {
            ident_def,
            // Ignore clipped member 'equ'
            type_def: Box::new(type_def),
        };
        // Calling user action here
        self.user_grammar.type_decl(&type_decl_built)?;
        self.push(ASTType::TypeDecl(type_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `VarDecl: IdentList ":"^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn var_decl(
        &mut self,
        _ident_list: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_list = pop_item!(self, ident_list, IdentList, context);
        let var_decl_built = VarDecl {
            ident_list,
            // Ignore clipped member 'colon'
            type_def: Box::new(type_def),
        };
        // Calling user action here
        self.user_grammar.var_decl(&var_decl_built)?;
        self.push(ASTType::VarDecl(var_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `ProcDecl: ProcedureHeading ";"^ /* Clipped */ ProcedureBody;`
    ///
    #[parol_runtime::function_name::named]
    fn proc_decl(
        &mut self,
        _procedure_heading: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _procedure_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let procedure_body = pop_item!(self, procedure_body, ProcedureBody, context);
        let procedure_heading = pop_item!(self, procedure_heading, ProcedureHeading, context);
        let proc_decl_built = ProcDecl {
            procedure_heading,
            // Ignore clipped member 'semicolon'
            procedure_body: Box::new(procedure_body),
        };
        // Calling user action here
        self.user_grammar.proc_decl(&proc_decl_built)?;
        self.push(ASTType::ProcDecl(proc_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `ProcedureHeading: KwProcedure^ /* Clipped */ ProcedureHeadingOpt /* Option */ IdentDef ProcedureHeadingOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_heading(
        &mut self,
        _kw_procedure: &ParseTreeType<'t>,
        _procedure_heading_opt: &ParseTreeType<'t>,
        _ident_def: &ParseTreeType<'t>,
        _procedure_heading_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let procedure_heading_opt0 =
            pop_item!(self, procedure_heading_opt0, ProcedureHeadingOpt0, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let procedure_heading_opt =
            pop_item!(self, procedure_heading_opt, ProcedureHeadingOpt, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let procedure_heading_built = ProcedureHeading {
            // Ignore clipped member 'kw_procedure'
            procedure_heading_opt,
            ident_def,
            procedure_heading_opt0,
        };
        // Calling user action here
        self.user_grammar
            .procedure_heading(&procedure_heading_built)?;
        self.push(ASTType::ProcedureHeading(procedure_heading_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `ProcedureHeadingOpt0 /* Option<T>::Some */: FormalPars;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_heading_opt0_0(&mut self, _formal_pars: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let procedure_heading_opt0_0_built = ProcedureHeadingOpt0 {
            formal_pars: Box::new(formal_pars),
        };
        self.push(
            ASTType::ProcedureHeadingOpt0(Some(Box::new(procedure_heading_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `ProcedureHeadingOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_heading_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcedureHeadingOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `ProcedureHeadingOpt /* Option<T>::Some */: Receiver;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_heading_opt_0(&mut self, _receiver: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = pop_item!(self, receiver, Receiver, context);
        let procedure_heading_opt_0_built = ProcedureHeadingOpt { receiver };
        self.push(
            ASTType::ProcedureHeadingOpt(Some(Box::new(procedure_heading_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `ProcedureHeadingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_heading_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProcedureHeadingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `ProcedureBody: DeclSeq StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn procedure_body(
        &mut self,
        _decl_seq: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let decl_seq = pop_item!(self, decl_seq, DeclSeq, context);
        let procedure_body_built = ProcedureBody {
            decl_seq: Box::new(decl_seq),
            statement_block,
        };
        // Calling user action here
        self.user_grammar.procedure_body(&procedure_body_built)?;
        self.push(ASTType::ProcedureBody(procedure_body_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `StatementBlock: StatementBlockOpt /* Option */ KwEnd^ /* Clipped */ Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block(
        &mut self,
        _statement_block_opt: &ParseTreeType<'t>,
        _kw_end: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_block_opt = pop_item!(self, statement_block_opt, StatementBlockOpt, context);
        let statement_block_built = StatementBlock {
            statement_block_opt,
            // Ignore clipped member 'kw_end'
            ident,
        };
        // Calling user action here
        self.user_grammar.statement_block(&statement_block_built)?;
        self.push(ASTType::StatementBlock(statement_block_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `StatementBlockOpt /* Option<T>::Some */: KwBegin^ /* Clipped */ StatementSeq;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_opt_0(
        &mut self,
        _kw_begin: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_begin'
        self.pop(context);
        let statement_block_opt_0_built = StatementBlockOpt {
            // Ignore clipped member 'kw_begin'
            statement_seq: Box::new(statement_seq),
        };
        self.push(
            ASTType::StatementBlockOpt(Some(Box::new(statement_block_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `StatementBlockOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `ForwardDecl: KwProcedure^ /* Clipped */ "\^" ForwardDeclOpt /* Option */ IdentDef ForwardDeclOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn forward_decl(
        &mut self,
        _kw_procedure: &ParseTreeType<'t>,
        circumflex: &ParseTreeType<'t>,
        _forward_decl_opt: &ParseTreeType<'t>,
        _ident_def: &ParseTreeType<'t>,
        _forward_decl_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = circumflex.token()?.clone();
        let forward_decl_opt0 = pop_item!(self, forward_decl_opt0, ForwardDeclOpt0, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let forward_decl_opt = pop_item!(self, forward_decl_opt, ForwardDeclOpt, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let forward_decl_built = ForwardDecl {
            // Ignore clipped member 'kw_procedure'
            circumflex,
            forward_decl_opt,
            ident_def,
            forward_decl_opt0,
        };
        // Calling user action here
        self.user_grammar.forward_decl(&forward_decl_built)?;
        self.push(ASTType::ForwardDecl(forward_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `ForwardDeclOpt0 /* Option<T>::Some */: FormalPars;`
    ///
    #[parol_runtime::function_name::named]
    fn forward_decl_opt0_0(&mut self, _formal_pars: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let forward_decl_opt0_0_built = ForwardDeclOpt0 {
            formal_pars: Box::new(formal_pars),
        };
        self.push(
            ASTType::ForwardDeclOpt0(Some(Box::new(forward_decl_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `ForwardDeclOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn forward_decl_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `ForwardDeclOpt /* Option<T>::Some */: Receiver;`
    ///
    #[parol_runtime::function_name::named]
    fn forward_decl_opt_0(&mut self, _receiver: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver = pop_item!(self, receiver, Receiver, context);
        let forward_decl_opt_0_built = ForwardDeclOpt { receiver };
        self.push(
            ASTType::ForwardDeclOpt(Some(Box::new(forward_decl_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `ForwardDeclOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn forward_decl_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForwardDeclOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `FormalPars: "\("^ /* Clipped */ FormalParsOpt /* Option */ "\)"^ /* Clipped */ FormalParsOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _formal_pars_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _formal_pars_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt0 = pop_item!(self, formal_pars_opt0, FormalParsOpt0, context);
        let formal_pars_opt = pop_item!(self, formal_pars_opt, FormalParsOpt, context);
        let formal_pars_built = FormalPars {
            // Ignore clipped member 'l_paren'
            formal_pars_opt,
            // Ignore clipped member 'r_paren'
            formal_pars_opt0,
        };
        // Calling user action here
        self.user_grammar.formal_pars(&formal_pars_built)?;
        self.push(ASTType::FormalPars(formal_pars_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `FormalParsOpt0 /* Option<T>::Some */: ":"^ /* Clipped */ QualIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt0_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _qual_ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let formal_pars_opt0_0_built = FormalParsOpt0 {
            // Ignore clipped member 'colon'
            qual_ident,
        };
        self.push(
            ASTType::FormalParsOpt0(Some(Box::new(formal_pars_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `FormalParsOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `FormalParsOpt /* Option<T>::Some */: FPSection FormalParsOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt_0(
        &mut self,
        _f_p_section: &ParseTreeType<'t>,
        _formal_pars_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list =
            pop_and_reverse_item!(self, formal_pars_opt_list, FormalParsOptList, context);
        let f_p_section = pop_item!(self, f_p_section, FPSection, context);
        let formal_pars_opt_0_built = FormalParsOpt {
            f_p_section: Box::new(f_p_section),
            formal_pars_opt_list,
        };
        self.push(
            ASTType::FormalParsOpt(Some(Box::new(formal_pars_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `FormalParsOptList /* Vec<T>::Push */: ";"^ /* Clipped */ FPSection FormalParsOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt_list_0(
        &mut self,
        _semicolon: &ParseTreeType<'t>,
        _f_p_section: &ParseTreeType<'t>,
        _formal_pars_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut formal_pars_opt_list =
            pop_item!(self, formal_pars_opt_list, FormalParsOptList, context);
        let f_p_section = pop_item!(self, f_p_section, FPSection, context);
        let formal_pars_opt_list_0_built = FormalParsOptList {
            f_p_section: Box::new(f_p_section),
            // Ignore clipped member 'semicolon'
        };
        // Add an element to the vector
        formal_pars_opt_list.push(formal_pars_opt_list_0_built);
        self.push(ASTType::FormalParsOptList(formal_pars_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `FormalParsOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars_opt_list_1_built = Vec::new();
        self.push(
            ASTType::FormalParsOptList(formal_pars_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `FormalParsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn formal_pars_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FormalParsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `FPSection: FPSectionOpt /* Option */ Ident FPSectionList /* Vec */ ":"^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn f_p_section(
        &mut self,
        _f_p_section_opt: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _f_p_section_list: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let f_p_section_list =
            pop_and_reverse_item!(self, f_p_section_list, FPSectionList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let f_p_section_opt = pop_item!(self, f_p_section_opt, FPSectionOpt, context);
        let f_p_section_built = FPSection {
            f_p_section_opt,
            ident,
            f_p_section_list,
            // Ignore clipped member 'colon'
            type_def: Box::new(type_def),
        };
        // Calling user action here
        self.user_grammar.f_p_section(&f_p_section_built)?;
        self.push(ASTType::FPSection(f_p_section_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `FPSectionList /* Vec<T>::Push */: ","^ /* Clipped */ Ident FPSectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn f_p_section_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _f_p_section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut f_p_section_list = pop_item!(self, f_p_section_list, FPSectionList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let f_p_section_list_0_built = FPSectionList {
            ident,
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        f_p_section_list.push(f_p_section_list_0_built);
        self.push(ASTType::FPSectionList(f_p_section_list), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `FPSectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn f_p_section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f_p_section_list_1_built = Vec::new();
        self.push(ASTType::FPSectionList(f_p_section_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `FPSectionOpt /* Option<T>::Some */: KwVar^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn f_p_section_opt_0(&mut self, _kw_var: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let f_p_section_opt_0_built = FPSectionOpt {
        // Ignore clipped member 'kw_var'
        };
        self.push(
            ASTType::FPSectionOpt(Some(Box::new(f_p_section_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `FPSectionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn f_p_section_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FPSectionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `Receiver: "\("^ /* Clipped */ ReceiverOpt /* Option */ ReceiverVarDecl "\)"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn receiver(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _receiver_opt: &ParseTreeType<'t>,
        _receiver_var_decl: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let receiver_var_decl = pop_item!(self, receiver_var_decl, ReceiverVarDecl, context);
        let receiver_opt = pop_item!(self, receiver_opt, ReceiverOpt, context);
        let receiver_built = Receiver {
            // Ignore clipped member 'l_paren'
            receiver_opt,
            receiver_var_decl,
            // Ignore clipped member 'r_paren'
        };
        // Calling user action here
        self.user_grammar.receiver(&receiver_built)?;
        self.push(ASTType::Receiver(receiver_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `ReceiverOpt /* Option<T>::Some */: KwVar^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn receiver_opt_0(&mut self, _kw_var: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_var'
        self.pop(context);
        let receiver_opt_0_built = ReceiverOpt {
        // Ignore clipped member 'kw_var'
        };
        self.push(
            ASTType::ReceiverOpt(Some(Box::new(receiver_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `ReceiverOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn receiver_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ReceiverOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `ReceiverVarDecl: Ident ":"^ /* Clipped */ Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn receiver_var_decl(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _ident0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident0 = pop_item!(self, ident0, Ident, context);
        let ident = pop_item!(self, ident, Ident, context);
        let receiver_var_decl_built = ReceiverVarDecl {
            ident,
            // Ignore clipped member 'colon'
            ident0,
        };
        // Calling user action here
        self.user_grammar
            .receiver_var_decl(&receiver_var_decl_built)?;
        self.push(ASTType::ReceiverVarDecl(receiver_var_decl_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `TypeDef: QualIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_0(&mut self, _qual_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let type_def_0_built = TypeDefQualIdent { qual_ident };
        let type_def_0_built = TypeDef::QualIdent(type_def_0_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_0_built)?;
        self.push(ASTType::TypeDef(type_def_0_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `TypeDef: "ARRAY"^ /* Clipped */ TypeDefOpt /* Option */ KwOf^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_1(
        &mut self,
        _a_r_r_a_y: &ParseTreeType<'t>,
        _type_def_opt: &ParseTreeType<'t>,
        _kw_of: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        // Ignore clipped member 'kw_of'
        self.pop(context);
        let type_def_opt = pop_item!(self, type_def_opt, TypeDefOpt, context);
        let type_def_1_built = TypeDefARRAYTypeDefOptKwOfTypeDef {
            // Ignore clipped member 'a_r_r_a_y'
            type_def_opt,
            // Ignore clipped member 'kw_of'
            type_def: Box::new(type_def),
        };
        let type_def_1_built = TypeDef::ARRAYTypeDefOptKwOfTypeDef(type_def_1_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_1_built)?;
        self.push(ASTType::TypeDef(type_def_1_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `TypeDef: "RECORD"^ /* Clipped */ TypeDefOpt0 /* Option */ FieldList TypeDefList /* Vec */ KwEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_2(
        &mut self,
        _r_e_c_o_r_d: &ParseTreeType<'t>,
        _type_def_opt0: &ParseTreeType<'t>,
        _field_list: &ParseTreeType<'t>,
        _type_def_list: &ParseTreeType<'t>,
        _kw_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let type_def_list = pop_and_reverse_item!(self, type_def_list, TypeDefList, context);
        let field_list = pop_item!(self, field_list, FieldList, context);
        let type_def_opt0 = pop_item!(self, type_def_opt0, TypeDefOpt0, context);
        let type_def_2_built = TypeDefRECORDTypeDefOpt0FieldListTypeDefListKwEnd {
            // Ignore clipped member 'r_e_c_o_r_d'
            type_def_opt0,
            field_list: Box::new(field_list),
            type_def_list,
            // Ignore clipped member 'kw_end'
        };
        let type_def_2_built =
            TypeDef::RECORDTypeDefOpt0FieldListTypeDefListKwEnd(type_def_2_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_2_built)?;
        self.push(ASTType::TypeDef(type_def_2_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `TypeDefList /* Vec<T>::Push */: ";"^ /* Clipped */ FieldList TypeDefList;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_list_0(
        &mut self,
        _semicolon: &ParseTreeType<'t>,
        _field_list: &ParseTreeType<'t>,
        _type_def_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_def_list = pop_item!(self, type_def_list, TypeDefList, context);
        let field_list = pop_item!(self, field_list, FieldList, context);
        let type_def_list_0_built = TypeDefList {
            field_list: Box::new(field_list),
            // Ignore clipped member 'semicolon'
        };
        // Add an element to the vector
        type_def_list.push(type_def_list_0_built);
        self.push(ASTType::TypeDefList(type_def_list), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `TypeDefList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_list_1_built = Vec::new();
        self.push(ASTType::TypeDefList(type_def_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `TypeDef: "POINTER"^ /* Clipped */ KwTo^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_3(
        &mut self,
        _p_o_i_n_t_e_r: &ParseTreeType<'t>,
        _kw_to: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        // Ignore clipped member 'kw_to'
        self.pop(context);
        let type_def_3_built = TypeDefPOINTERKwToTypeDef {
            // Ignore clipped member 'p_o_i_n_t_e_r'
            // Ignore clipped member 'kw_to'
            type_def: Box::new(type_def),
        };
        let type_def_3_built = TypeDef::POINTERKwToTypeDef(type_def_3_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_3_built)?;
        self.push(ASTType::TypeDef(type_def_3_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `TypeDef: KwProcedure^ /* Clipped */ TypeDefOpt1 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_4(
        &mut self,
        _kw_procedure: &ParseTreeType<'t>,
        _type_def_opt1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt1 = pop_item!(self, type_def_opt1, TypeDefOpt1, context);
        // Ignore clipped member 'kw_procedure'
        self.pop(context);
        let type_def_4_built = TypeDefKwProcedureTypeDefOpt1 {
            // Ignore clipped member 'kw_procedure'
            type_def_opt1,
        };
        let type_def_4_built = TypeDef::KwProcedureTypeDefOpt1(type_def_4_built);
        // Calling user action here
        self.user_grammar.type_def(&type_def_4_built)?;
        self.push(ASTType::TypeDef(type_def_4_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `TypeDefOpt1 /* Option<T>::Some */: FormalPars;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt1_0(&mut self, _formal_pars: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let formal_pars = pop_item!(self, formal_pars, FormalPars, context);
        let type_def_opt1_0_built = TypeDefOpt1 {
            formal_pars: Box::new(formal_pars),
        };
        self.push(
            ASTType::TypeDefOpt1(Some(Box::new(type_def_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `TypeDefOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `TypeDefOpt0 /* Option<T>::Some */: "\("^ /* Clipped */ QualIdent "\)"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt0_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _qual_ident: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let type_def_opt0_0_built = TypeDefOpt0 {
            // Ignore clipped member 'l_paren'
            qual_ident,
            // Ignore clipped member 'r_paren'
        };
        self.push(
            ASTType::TypeDefOpt0(Some(Box::new(type_def_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `TypeDefOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `TypeDefOpt /* Option<T>::Some */: ConstExpr TypeDefOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt_0(
        &mut self,
        _const_expr: &ParseTreeType<'t>,
        _type_def_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list =
            pop_and_reverse_item!(self, type_def_opt_list, TypeDefOptList, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let type_def_opt_0_built = TypeDefOpt {
            const_expr: Box::new(const_expr),
            type_def_opt_list,
        };
        self.push(
            ASTType::TypeDefOpt(Some(Box::new(type_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `TypeDefOptList /* Vec<T>::Push */: ","^ /* Clipped */ ConstExpr TypeDefOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _const_expr: &ParseTreeType<'t>,
        _type_def_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_def_opt_list = pop_item!(self, type_def_opt_list, TypeDefOptList, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let type_def_opt_list_0_built = TypeDefOptList {
            const_expr: Box::new(const_expr),
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        type_def_opt_list.push(type_def_opt_list_0_built);
        self.push(ASTType::TypeDefOptList(type_def_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `TypeDefOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_opt_list_1_built = Vec::new();
        self.push(ASTType::TypeDefOptList(type_def_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `TypeDefOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TypeDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `FieldList: FieldListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn field_list(&mut self, _field_list_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let field_list_opt = pop_item!(self, field_list_opt, FieldListOpt, context);
        let field_list_built = FieldList { field_list_opt };
        // Calling user action here
        self.user_grammar.field_list(&field_list_built)?;
        self.push(ASTType::FieldList(field_list_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `FieldListOpt /* Option<T>::Some */: IdentList ":"^ /* Clipped */ TypeDef;`
    ///
    #[parol_runtime::function_name::named]
    fn field_list_opt_0(
        &mut self,
        _ident_list: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _type_def: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def = pop_item!(self, type_def, TypeDef, context);
        let ident_list = pop_item!(self, ident_list, IdentList, context);
        let field_list_opt_0_built = FieldListOpt {
            ident_list,
            // Ignore clipped member 'colon'
            type_def: Box::new(type_def),
        };
        self.push(
            ASTType::FieldListOpt(Some(Box::new(field_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `FieldListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn field_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FieldListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `StatementSeq: Statement StatementSeqList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_seq(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _statement_seq_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list =
            pop_and_reverse_item!(self, statement_seq_list, StatementSeqList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let statement_seq_built = StatementSeq {
            statement: Box::new(statement),
            statement_seq_list,
        };
        // Calling user action here
        self.user_grammar.statement_seq(&statement_seq_built)?;
        self.push(ASTType::StatementSeq(statement_seq_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `StatementSeqList /* Vec<T>::Push */: ";"^ /* Clipped */ Statement StatementSeqList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_seq_list_0(
        &mut self,
        _semicolon: &ParseTreeType<'t>,
        _statement: &ParseTreeType<'t>,
        _statement_seq_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_seq_list = pop_item!(self, statement_seq_list, StatementSeqList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let statement_seq_list_0_built = StatementSeqList {
            statement: Box::new(statement),
            // Ignore clipped member 'semicolon'
        };
        // Add an element to the vector
        statement_seq_list.push(statement_seq_list_0_built);
        self.push(ASTType::StatementSeqList(statement_seq_list), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `StatementSeqList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_seq_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq_list_1_built = Vec::new();
        self.push(
            ASTType::StatementSeqList(statement_seq_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `Statement: StatementOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement(&mut self, _statement_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt = pop_item!(self, statement_opt, StatementOpt, context);
        let statement_built = Statement { statement_opt };
        // Calling user action here
        self.user_grammar.statement(&statement_built)?;
        self.push(ASTType::Statement(statement_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `StatementOpt /* Option<T>::Some */: StatementOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_0(&mut self, _statement_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group = pop_item!(self, statement_opt_group, StatementOptGroup, context);
        let statement_opt_0_built = StatementOpt {
            statement_opt_group: Box::new(statement_opt_group),
        };
        self.push(
            ASTType::StatementOpt(Some(Box::new(statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `StatementOptGroup: Designator StatementOptGroupSuffix;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_0(
        &mut self,
        _designator: &ParseTreeType<'t>,
        _statement_opt_group_suffix: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_suffix = pop_item!(
            self,
            statement_opt_group_suffix,
            StatementOptGroupSuffix,
            context
        );
        let designator = pop_item!(self, designator, Designator, context);
        let statement_opt_group_0_built = StatementOptGroupDesignatorStatementOptGroupSuffix {
            designator: Box::new(designator),
            statement_opt_group_suffix,
        };
        let statement_opt_group_0_built =
            StatementOptGroup::DesignatorStatementOptGroupSuffix(statement_opt_group_0_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `StatementOptGroupSuffix: ":="^ /* Clipped */ Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_suffix_0(
        &mut self,
        _colon_equ: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt_group_suffix_0_built = StatementOptGroupSuffixColonEquExpr {
            // Ignore clipped member 'colon_equ'
            expr: Box::new(expr),
        };
        let statement_opt_group_suffix_0_built =
            StatementOptGroupSuffix::ColonEquExpr(statement_opt_group_suffix_0_built);
        self.push(
            ASTType::StatementOptGroupSuffix(statement_opt_group_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `StatementOptGroupSuffix: StatementOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_suffix_1(&mut self, _statement_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt0 = pop_item!(self, statement_opt0, StatementOpt0, context);
        let statement_opt_group_suffix_1_built =
            StatementOptGroupSuffixStatementOpt0 { statement_opt0 };
        let statement_opt_group_suffix_1_built =
            StatementOptGroupSuffix::StatementOpt0(statement_opt_group_suffix_1_built);
        self.push(
            ASTType::StatementOptGroupSuffix(statement_opt_group_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `StatementOptGroup: KwIf^ /* Clipped */ Expr ThenBlock StatementOptGroupList /* Vec */ OptElsePartEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_1(
        &mut self,
        _kw_if: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _then_block: &ParseTreeType<'t>,
        _statement_opt_group_list: &ParseTreeType<'t>,
        _opt_else_part_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let statement_opt_group_list = pop_and_reverse_item!(
            self,
            statement_opt_group_list,
            StatementOptGroupList,
            context
        );
        let then_block = pop_item!(self, then_block, ThenBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_if'
        self.pop(context);
        let statement_opt_group_1_built =
            StatementOptGroupKwIfExprThenBlockStatementOptGroupListOptElsePartEnd {
                // Ignore clipped member 'kw_if'
                expr: Box::new(expr),
                then_block: Box::new(then_block),
                statement_opt_group_list,
                opt_else_part_end: Box::new(opt_else_part_end),
            };
        let statement_opt_group_1_built =
            StatementOptGroup::KwIfExprThenBlockStatementOptGroupListOptElsePartEnd(
                statement_opt_group_1_built,
            );
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `StatementOptGroup: KwCase^ /* Clipped */ Expr KwOf^ /* Clipped */ Cases OptElsePartEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_2(
        &mut self,
        _kw_case: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _kw_of: &ParseTreeType<'t>,
        _cases: &ParseTreeType<'t>,
        _opt_else_part_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let cases = pop_item!(self, cases, Cases, context);
        // Ignore clipped member 'kw_of'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_case'
        self.pop(context);
        let statement_opt_group_2_built = StatementOptGroupKwCaseExprKwOfCasesOptElsePartEnd {
            // Ignore clipped member 'kw_case'
            expr: Box::new(expr),
            // Ignore clipped member 'kw_of'
            cases: Box::new(cases),
            opt_else_part_end: Box::new(opt_else_part_end),
        };
        let statement_opt_group_2_built =
            StatementOptGroup::KwCaseExprKwOfCasesOptElsePartEnd(statement_opt_group_2_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `StatementOptGroup: "WHILE"^ /* Clipped */ Expr DoBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_3(
        &mut self,
        _w_h_i_l_e: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _do_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let do_block = pop_item!(self, do_block, DoBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt_group_3_built = StatementOptGroupWHILEExprDoBlock {
            // Ignore clipped member 'w_h_i_l_e'
            expr: Box::new(expr),
            do_block: Box::new(do_block),
        };
        let statement_opt_group_3_built =
            StatementOptGroup::WHILEExprDoBlock(statement_opt_group_3_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `StatementOptGroup: "REPEAT"^ /* Clipped */ StatementSeq "UNTIL"^ /* Clipped */ Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_4(
        &mut self,
        _r_e_p_e_a_t: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
        _u_n_t_i_l: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let statement_opt_group_4_built = StatementOptGroupREPEATStatementSeqUNTILExpr {
            // Ignore clipped member 'r_e_p_e_a_t'
            statement_seq: Box::new(statement_seq),
            // Ignore clipped member 'u_n_t_i_l'
            expr: Box::new(expr),
        };
        let statement_opt_group_4_built =
            StatementOptGroup::REPEATStatementSeqUNTILExpr(statement_opt_group_4_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `StatementOptGroup: "FOR"^ /* Clipped */ ForInit StatementOpt1 /* Option */ DoBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_5(
        &mut self,
        _f_o_r: &ParseTreeType<'t>,
        _for_init: &ParseTreeType<'t>,
        _statement_opt1: &ParseTreeType<'t>,
        _do_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let do_block = pop_item!(self, do_block, DoBlock, context);
        let statement_opt1 = pop_item!(self, statement_opt1, StatementOpt1, context);
        let for_init = pop_item!(self, for_init, ForInit, context);
        let statement_opt_group_5_built = StatementOptGroupFORForInitStatementOpt1DoBlock {
            // Ignore clipped member 'f_o_r'
            for_init,
            statement_opt1,
            do_block: Box::new(do_block),
        };
        let statement_opt_group_5_built =
            StatementOptGroup::FORForInitStatementOpt1DoBlock(statement_opt_group_5_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `StatementOptGroup: "LOOP"^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_6(
        &mut self,
        _l_o_o_p: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
        _kw_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let statement_opt_group_6_built = StatementOptGroupLOOPStatementSeqKwEnd {
            // Ignore clipped member 'l_o_o_p'
            statement_seq: Box::new(statement_seq),
            // Ignore clipped member 'kw_end'
        };
        let statement_opt_group_6_built =
            StatementOptGroup::LOOPStatementSeqKwEnd(statement_opt_group_6_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `StatementOptGroup: "WITH"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0 /* Vec */ OptElsePartEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_7(
        &mut self,
        _w_i_t_h: &ParseTreeType<'t>,
        _guarded_do_block: &ParseTreeType<'t>,
        _statement_opt_group_list0: &ParseTreeType<'t>,
        _opt_else_part_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let opt_else_part_end = pop_item!(self, opt_else_part_end, OptElsePartEnd, context);
        let statement_opt_group_list0 = pop_and_reverse_item!(
            self,
            statement_opt_group_list0,
            StatementOptGroupList0,
            context
        );
        let guarded_do_block = pop_item!(self, guarded_do_block, GuardedDoBlock, context);
        let statement_opt_group_7_built =
            StatementOptGroupWITHGuardedDoBlockStatementOptGroupList0OptElsePartEnd {
                // Ignore clipped member 'w_i_t_h'
                guarded_do_block: Box::new(guarded_do_block),
                statement_opt_group_list0,
                opt_else_part_end: Box::new(opt_else_part_end),
            };
        let statement_opt_group_7_built =
            StatementOptGroup::WITHGuardedDoBlockStatementOptGroupList0OptElsePartEnd(
                statement_opt_group_7_built,
            );
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_7_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `StatementOptGroup: "EXIT"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_8(&mut self, _e_x_i_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_8_built = StatementOptGroupEXIT {
        // Ignore clipped member 'e_x_i_t'
        };
        let statement_opt_group_8_built = StatementOptGroup::EXIT(statement_opt_group_8_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_8_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `StatementOptGroup: "RETURN"^ /* Clipped */ StatementOpt2 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_9(
        &mut self,
        _r_e_t_u_r_n: &ParseTreeType<'t>,
        _statement_opt2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt2 = pop_item!(self, statement_opt2, StatementOpt2, context);
        let statement_opt_group_9_built = StatementOptGroupRETURNStatementOpt2 {
            // Ignore clipped member 'r_e_t_u_r_n'
            statement_opt2,
        };
        let statement_opt_group_9_built =
            StatementOptGroup::RETURNStatementOpt2(statement_opt_group_9_built);
        self.push(
            ASTType::StatementOptGroup(statement_opt_group_9_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `StatementOptGroupList /* Vec<T>::Push */: ElsifPart StatementOptGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_list_0(
        &mut self,
        _elsif_part: &ParseTreeType<'t>,
        _statement_opt_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_opt_group_list = pop_item!(
            self,
            statement_opt_group_list,
            StatementOptGroupList,
            context
        );
        let elsif_part = pop_item!(self, elsif_part, ElsifPart, context);
        let statement_opt_group_list_0_built = StatementOptGroupList {
            elsif_part: Box::new(elsif_part),
        };
        // Add an element to the vector
        statement_opt_group_list.push(statement_opt_group_list_0_built);
        self.push(
            ASTType::StatementOptGroupList(statement_opt_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `StatementOptGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_list_1_built = Vec::new();
        self.push(
            ASTType::StatementOptGroupList(statement_opt_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `StatementOptGroupList0 /* Vec<T>::Push */: "\|"^ /* Clipped */ GuardedDoBlock StatementOptGroupList0;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_list0_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _guarded_do_block: &ParseTreeType<'t>,
        _statement_opt_group_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_opt_group_list0 = pop_item!(
            self,
            statement_opt_group_list0,
            StatementOptGroupList0,
            context
        );
        let guarded_do_block = pop_item!(self, guarded_do_block, GuardedDoBlock, context);
        let statement_opt_group_list0_0_built = StatementOptGroupList0 {
            guarded_do_block: Box::new(guarded_do_block),
            // Ignore clipped member 'or'
        };
        // Add an element to the vector
        statement_opt_group_list0.push(statement_opt_group_list0_0_built);
        self.push(
            ASTType::StatementOptGroupList0(statement_opt_group_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `StatementOptGroupList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_group_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt_group_list0_1_built = Vec::new();
        self.push(
            ASTType::StatementOptGroupList0(statement_opt_group_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `StatementOpt2 /* Option<T>::Some */: Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt2_0(&mut self, _expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let statement_opt2_0_built = StatementOpt2 {
            expr: Box::new(expr),
        };
        self.push(
            ASTType::StatementOpt2(Some(Box::new(statement_opt2_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `StatementOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `StatementOpt1 /* Option<T>::Some */: ForStep;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt1_0(&mut self, _for_step: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_step = pop_item!(self, for_step, ForStep, context);
        let statement_opt1_0_built = StatementOpt1 { for_step };
        self.push(
            ASTType::StatementOpt1(Some(Box::new(statement_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `StatementOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `StatementOpt0 /* Option<T>::Some */: "\("^ /* Clipped */ StatementOpt3 /* Option */ "\)"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt0_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _statement_opt3: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_opt3 = pop_item!(self, statement_opt3, StatementOpt3, context);
        let statement_opt0_0_built = StatementOpt0 {
            // Ignore clipped member 'l_paren'
            statement_opt3,
            // Ignore clipped member 'r_paren'
        };
        self.push(
            ASTType::StatementOpt0(Some(Box::new(statement_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `StatementOpt3 /* Option<T>::Some */: ExprList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt3_0(&mut self, _expr_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let statement_opt3_0_built = StatementOpt3 {
            expr_list: Box::new(expr_list),
        };
        self.push(
            ASTType::StatementOpt3(Some(Box::new(statement_opt3_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `StatementOpt3 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt3_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt3(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `StatementOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `StatementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `ThenBlock: KwThen^ /* Clipped */ StatementSeq;`
    ///
    #[parol_runtime::function_name::named]
    fn then_block(
        &mut self,
        _kw_then: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_then'
        self.pop(context);
        let then_block_built = ThenBlock {
            // Ignore clipped member 'kw_then'
            statement_seq: Box::new(statement_seq),
        };
        // Calling user action here
        self.user_grammar.then_block(&then_block_built)?;
        self.push(ASTType::ThenBlock(then_block_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `Cases: Case CasesList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn cases(&mut self, _case: &ParseTreeType<'t>, _cases_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cases_list = pop_and_reverse_item!(self, cases_list, CasesList, context);
        let case = pop_item!(self, case, Case, context);
        let cases_built = Cases {
            case: Box::new(case),
            cases_list,
        };
        // Calling user action here
        self.user_grammar.cases(&cases_built)?;
        self.push(ASTType::Cases(cases_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `CasesList /* Vec<T>::Push */: "\|"^ /* Clipped */ Case CasesList;`
    ///
    #[parol_runtime::function_name::named]
    fn cases_list_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _case: &ParseTreeType<'t>,
        _cases_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut cases_list = pop_item!(self, cases_list, CasesList, context);
        let case = pop_item!(self, case, Case, context);
        let cases_list_0_built = CasesList {
            case: Box::new(case),
            // Ignore clipped member 'or'
        };
        // Add an element to the vector
        cases_list.push(cases_list_0_built);
        self.push(ASTType::CasesList(cases_list), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `CasesList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn cases_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cases_list_1_built = Vec::new();
        self.push(ASTType::CasesList(cases_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `ElsifPart: KwElsif^ /* Clipped */ Expr ThenBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn elsif_part(
        &mut self,
        _kw_elsif: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _then_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let then_block = pop_item!(self, then_block, ThenBlock, context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'kw_elsif'
        self.pop(context);
        let elsif_part_built = ElsifPart {
            // Ignore clipped member 'kw_elsif'
            expr: Box::new(expr),
            then_block: Box::new(then_block),
        };
        // Calling user action here
        self.user_grammar.elsif_part(&elsif_part_built)?;
        self.push(ASTType::ElsifPart(elsif_part_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `ElsePart: KwElse^ /* Clipped */ StatementSeq;`
    ///
    #[parol_runtime::function_name::named]
    fn else_part(
        &mut self,
        _kw_else: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_else'
        self.pop(context);
        let else_part_built = ElsePart {
            // Ignore clipped member 'kw_else'
            statement_seq: Box::new(statement_seq),
        };
        // Calling user action here
        self.user_grammar.else_part(&else_part_built)?;
        self.push(ASTType::ElsePart(else_part_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `OptElsePartEnd: OptElsePartEndOpt /* Option */ KwEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn opt_else_part_end(
        &mut self,
        _opt_else_part_end_opt: &ParseTreeType<'t>,
        _kw_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let opt_else_part_end_opt =
            pop_item!(self, opt_else_part_end_opt, OptElsePartEndOpt, context);
        let opt_else_part_end_built = OptElsePartEnd {
            opt_else_part_end_opt,
            // Ignore clipped member 'kw_end'
        };
        // Calling user action here
        self.user_grammar
            .opt_else_part_end(&opt_else_part_end_built)?;
        self.push(ASTType::OptElsePartEnd(opt_else_part_end_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `OptElsePartEndOpt /* Option<T>::Some */: ElsePart;`
    ///
    #[parol_runtime::function_name::named]
    fn opt_else_part_end_opt_0(&mut self, _else_part: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_part = pop_item!(self, else_part, ElsePart, context);
        let opt_else_part_end_opt_0_built = OptElsePartEndOpt {
            else_part: Box::new(else_part),
        };
        self.push(
            ASTType::OptElsePartEndOpt(Some(Box::new(opt_else_part_end_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `OptElsePartEndOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn opt_else_part_end_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OptElsePartEndOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `DoBlock: KwDo^ /* Clipped */ StatementSeq KwEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn do_block(
        &mut self,
        _kw_do: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
        _kw_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'kw_end'
        self.pop(context);
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_do'
        self.pop(context);
        let do_block_built = DoBlock {
            // Ignore clipped member 'kw_do'
            statement_seq: Box::new(statement_seq),
            // Ignore clipped member 'kw_end'
        };
        // Calling user action here
        self.user_grammar.do_block(&do_block_built)?;
        self.push(ASTType::DoBlock(do_block_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `GuardedDoBlock: Guard KwDo^ /* Clipped */ StatementSeq;`
    ///
    #[parol_runtime::function_name::named]
    fn guarded_do_block(
        &mut self,
        _guard: &ParseTreeType<'t>,
        _kw_do: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        // Ignore clipped member 'kw_do'
        self.pop(context);
        let guard = pop_item!(self, guard, Guard, context);
        let guarded_do_block_built = GuardedDoBlock {
            guard,
            // Ignore clipped member 'kw_do'
            statement_seq: Box::new(statement_seq),
        };
        // Calling user action here
        self.user_grammar
            .guarded_do_block(&guarded_do_block_built)?;
        self.push(ASTType::GuardedDoBlock(guarded_do_block_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `ForInit: Ident ":="^ /* Clipped */ Expr KwTo^ /* Clipped */ Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn for_init(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon_equ: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _kw_to: &ParseTreeType<'t>,
        _expr0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr0 = pop_item!(self, expr0, Expr, context);
        // Ignore clipped member 'kw_to'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        let ident = pop_item!(self, ident, Ident, context);
        let for_init_built = ForInit {
            ident,
            // Ignore clipped member 'colon_equ'
            expr: Box::new(expr),
            // Ignore clipped member 'kw_to'
            expr0: Box::new(expr0),
        };
        // Calling user action here
        self.user_grammar.for_init(&for_init_built)?;
        self.push(ASTType::ForInit(for_init_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `ForStep: "BY"^ /* Clipped */ ConstExpr;`
    ///
    #[parol_runtime::function_name::named]
    fn for_step(
        &mut self,
        _b_y: &ParseTreeType<'t>,
        _const_expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let for_step_built = ForStep {
            // Ignore clipped member 'b_y'
            const_expr: Box::new(const_expr),
        };
        // Calling user action here
        self.user_grammar.for_step(&for_step_built)?;
        self.push(ASTType::ForStep(for_step_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `Case: CaseOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn case(&mut self, _case_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt = pop_item!(self, case_opt, CaseOpt, context);
        let case_built = Case { case_opt };
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `CaseOpt /* Option<T>::Some */: CaseLabels CaseOptList /* Vec */ ":"^ /* Clipped */ StatementSeq;`
    ///
    #[parol_runtime::function_name::named]
    fn case_opt_0(
        &mut self,
        _case_labels: &ParseTreeType<'t>,
        _case_opt_list: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _statement_seq: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_seq = pop_item!(self, statement_seq, StatementSeq, context);
        let case_opt_list = pop_and_reverse_item!(self, case_opt_list, CaseOptList, context);
        let case_labels = pop_item!(self, case_labels, CaseLabels, context);
        let case_opt_0_built = CaseOpt {
            case_labels,
            case_opt_list,
            // Ignore clipped member 'colon'
            statement_seq: Box::new(statement_seq),
        };
        self.push(ASTType::CaseOpt(Some(Box::new(case_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `CaseOptList /* Vec<T>::Push */: ","^ /* Clipped */ CaseLabels CaseOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn case_opt_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _case_labels: &ParseTreeType<'t>,
        _case_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_opt_list = pop_item!(self, case_opt_list, CaseOptList, context);
        let case_labels = pop_item!(self, case_labels, CaseLabels, context);
        let case_opt_list_0_built = CaseOptList {
            case_labels,
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        case_opt_list.push(case_opt_list_0_built);
        self.push(ASTType::CaseOptList(case_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `CaseOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_opt_list_1_built = Vec::new();
        self.push(ASTType::CaseOptList(case_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `CaseOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `CaseLabels: ConstExpr CaseLabelsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn case_labels(
        &mut self,
        _const_expr: &ParseTreeType<'t>,
        _case_labels_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_labels_opt = pop_item!(self, case_labels_opt, CaseLabelsOpt, context);
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let case_labels_built = CaseLabels {
            const_expr: Box::new(const_expr),
            case_labels_opt,
        };
        // Calling user action here
        self.user_grammar.case_labels(&case_labels_built)?;
        self.push(ASTType::CaseLabels(case_labels_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `CaseLabelsOpt /* Option<T>::Some */: "\.\." ConstExpr;`
    ///
    #[parol_runtime::function_name::named]
    fn case_labels_opt_0(
        &mut self,
        dot_dot: &ParseTreeType<'t>,
        _const_expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = dot_dot.token()?.clone();
        let const_expr = pop_item!(self, const_expr, ConstExpr, context);
        let case_labels_opt_0_built = CaseLabelsOpt {
            dot_dot,
            const_expr: Box::new(const_expr),
        };
        self.push(
            ASTType::CaseLabelsOpt(Some(Box::new(case_labels_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `CaseLabelsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_labels_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseLabelsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `Guard: QualIdent ":"^ /* Clipped */ QualIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn guard(
        &mut self,
        _qual_ident: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _qual_ident0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qual_ident0 = pop_item!(self, qual_ident0, QualIdent, context);
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let guard_built = Guard {
            qual_ident,
            // Ignore clipped member 'colon'
            qual_ident0,
        };
        // Calling user action here
        self.user_grammar.guard(&guard_built)?;
        self.push(ASTType::Guard(guard_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `ConstExpr: Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn const_expr(&mut self, _expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let const_expr_built = ConstExpr {
            expr: Box::new(expr),
        };
        // Calling user action here
        self.user_grammar.const_expr(&const_expr_built)?;
        self.push(ASTType::ConstExpr(const_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `Expr: SimpleExpr ExprOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn expr(
        &mut self,
        _simple_expr: &ParseTreeType<'t>,
        _expr_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_opt = pop_item!(self, expr_opt, ExprOpt, context);
        let simple_expr = pop_item!(self, simple_expr, SimpleExpr, context);
        let expr_built = Expr {
            simple_expr: Box::new(simple_expr),
            expr_opt,
        };
        // Calling user action here
        self.user_grammar.expr(&expr_built)?;
        self.push(ASTType::Expr(expr_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `ExprOpt /* Option<T>::Some */: Relation SimpleExpr;`
    ///
    #[parol_runtime::function_name::named]
    fn expr_opt_0(
        &mut self,
        _relation: &ParseTreeType<'t>,
        _simple_expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr = pop_item!(self, simple_expr, SimpleExpr, context);
        let relation = pop_item!(self, relation, Relation, context);
        let expr_opt_0_built = ExprOpt {
            relation,
            simple_expr: Box::new(simple_expr),
        };
        self.push(ASTType::ExprOpt(Some(Box::new(expr_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `ExprOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expr_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `SimpleExpr: SimpleExprOpt /* Option */ Term SimpleExprList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr(
        &mut self,
        _simple_expr_opt: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _simple_expr_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list =
            pop_and_reverse_item!(self, simple_expr_list, SimpleExprList, context);
        let term = pop_item!(self, term, Term, context);
        let simple_expr_opt = pop_item!(self, simple_expr_opt, SimpleExprOpt, context);
        let simple_expr_built = SimpleExpr {
            simple_expr_opt,
            term: Box::new(term),
            simple_expr_list,
        };
        // Calling user action here
        self.user_grammar.simple_expr(&simple_expr_built)?;
        self.push(ASTType::SimpleExpr(simple_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `SimpleExprList /* Vec<T>::Push */: AddOp Term SimpleExprList;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_list_0(
        &mut self,
        _add_op: &ParseTreeType<'t>,
        _term: &ParseTreeType<'t>,
        _simple_expr_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut simple_expr_list = pop_item!(self, simple_expr_list, SimpleExprList, context);
        let term = pop_item!(self, term, Term, context);
        let add_op = pop_item!(self, add_op, AddOp, context);
        let simple_expr_list_0_built = SimpleExprList {
            term: Box::new(term),
            add_op,
        };
        // Add an element to the vector
        simple_expr_list.push(simple_expr_list_0_built);
        self.push(ASTType::SimpleExprList(simple_expr_list), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `SimpleExprList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_list_1_built = Vec::new();
        self.push(ASTType::SimpleExprList(simple_expr_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `SimpleExprOpt /* Option<T>::Some */: SimpleExprOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_opt_0(&mut self, _simple_expr_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_expr_opt_group =
            pop_item!(self, simple_expr_opt_group, SimpleExprOptGroup, context);
        let simple_expr_opt_0_built = SimpleExprOpt {
            simple_expr_opt_group,
        };
        self.push(
            ASTType::SimpleExprOpt(Some(Box::new(simple_expr_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `SimpleExprOptGroup: "\+";`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_opt_group_0(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let simple_expr_opt_group_0_built = SimpleExprOptGroupPlus { plus };
        let simple_expr_opt_group_0_built = SimpleExprOptGroup::Plus(simple_expr_opt_group_0_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `SimpleExprOptGroup: "-";`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_opt_group_1(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let simple_expr_opt_group_1_built = SimpleExprOptGroupMinus { minus };
        let simple_expr_opt_group_1_built =
            SimpleExprOptGroup::Minus(simple_expr_opt_group_1_built);
        self.push(
            ASTType::SimpleExprOptGroup(simple_expr_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `SimpleExprOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_expr_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// `Term: Factor TermList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn term(&mut self, _factor: &ParseTreeType<'t>, _term_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list = pop_and_reverse_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let term_built = Term {
            factor: Box::new(factor),
            term_list,
        };
        // Calling user action here
        self.user_grammar.term(&term_built)?;
        self.push(ASTType::Term(term_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// `TermList /* Vec<T>::Push */: MulOp Factor TermList;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_0(
        &mut self,
        _mul_op: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _term_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut term_list = pop_item!(self, term_list, TermList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let mul_op = pop_item!(self, mul_op, MulOp, context);
        let term_list_0_built = TermList {
            factor: Box::new(factor),
            mul_op,
        };
        // Add an element to the vector
        term_list.push(term_list_0_built);
        self.push(ASTType::TermList(term_list), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// `TermList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn term_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_list_1_built = Vec::new();
        self.push(ASTType::TermList(term_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// `Factor: Designator FactorOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _designator: &ParseTreeType<'t>,
        _factor_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt = pop_item!(self, factor_opt, FactorOpt, context);
        let designator = pop_item!(self, designator, Designator, context);
        let factor_0_built = FactorDesignatorFactorOpt {
            designator: Box::new(designator),
            factor_opt,
        };
        let factor_0_built = Factor::DesignatorFactorOpt(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// `Factor: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_1_built = FactorNumber { number };
        let factor_1_built = Factor::Number(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// `Factor: Character;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(&mut self, _character: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = pop_item!(self, character, Character, context);
        let factor_2_built = FactorCharacter { character };
        let factor_2_built = Factor::Character(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// `Factor: String;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let factor_3_built = FactorString { string };
        let factor_3_built = Factor::String(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// `Factor: "NIL"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_4(&mut self, _n_i_l: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_4_built = FactorNIL {
        // Ignore clipped member 'n_i_l'
        };
        let factor_4_built = Factor::NIL(factor_4_built);
        // Calling user action here
        self.user_grammar.factor(&factor_4_built)?;
        self.push(ASTType::Factor(factor_4_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// `Factor: Set;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_5(&mut self, _set: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set = pop_item!(self, set, Set, context);
        let factor_5_built = FactorSet { set: Box::new(set) };
        let factor_5_built = Factor::Set(factor_5_built);
        // Calling user action here
        self.user_grammar.factor(&factor_5_built)?;
        self.push(ASTType::Factor(factor_5_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// `Factor: "\("^ /* Clipped */ Expr "\)"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_6(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let factor_6_built = FactorLParenExprRParen {
            // Ignore clipped member 'l_paren'
            expr: Box::new(expr),
            // Ignore clipped member 'r_paren'
        };
        let factor_6_built = Factor::LParenExprRParen(factor_6_built);
        // Calling user action here
        self.user_grammar.factor(&factor_6_built)?;
        self.push(ASTType::Factor(factor_6_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// `Factor: "~"^ /* Clipped */ Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_7(&mut self, _tilde: &ParseTreeType<'t>, _factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let factor_7_built = FactorTildeFactor {
            // Ignore clipped member 'tilde'
            factor: Box::new(factor),
        };
        let factor_7_built = Factor::TildeFactor(factor_7_built);
        // Calling user action here
        self.user_grammar.factor(&factor_7_built)?;
        self.push(ASTType::Factor(factor_7_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// `FactorOpt /* Option<T>::Some */: "\("^ /* Clipped */ FactorOpt0 /* Option */ "\)"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _factor_opt0: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt0 = pop_item!(self, factor_opt0, FactorOpt0, context);
        let factor_opt_0_built = FactorOpt {
            // Ignore clipped member 'l_paren'
            factor_opt0,
            // Ignore clipped member 'r_paren'
        };
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// `FactorOpt0 /* Option<T>::Some */: ExprList;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt0_0(&mut self, _expr_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let factor_opt0_0_built = FactorOpt0 {
            expr_list: Box::new(expr_list),
        };
        self.push(
            ASTType::FactorOpt0(Some(Box::new(factor_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// `FactorOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// `FactorOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// `Set: "\{"^ /* Clipped */ SetOpt /* Option */ "\}"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn set(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _set_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt = pop_item!(self, set_opt, SetOpt, context);
        let set_built = Set {
            // Ignore clipped member 'l_brace'
            set_opt,
            // Ignore clipped member 'r_brace'
        };
        // Calling user action here
        self.user_grammar.set(&set_built)?;
        self.push(ASTType::Set(set_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// `SetOpt /* Option<T>::Some */: Element SetOptList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn set_opt_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        _set_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list = pop_and_reverse_item!(self, set_opt_list, SetOptList, context);
        let element = pop_item!(self, element, Element, context);
        let set_opt_0_built = SetOpt {
            element: Box::new(element),
            set_opt_list,
        };
        self.push(ASTType::SetOpt(Some(Box::new(set_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// `SetOptList /* Vec<T>::Push */: ","^ /* Clipped */ Element SetOptList;`
    ///
    #[parol_runtime::function_name::named]
    fn set_opt_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _element: &ParseTreeType<'t>,
        _set_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut set_opt_list = pop_item!(self, set_opt_list, SetOptList, context);
        let element = pop_item!(self, element, Element, context);
        let set_opt_list_0_built = SetOptList {
            element: Box::new(element),
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        set_opt_list.push(set_opt_list_0_built);
        self.push(ASTType::SetOptList(set_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// `SetOptList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn set_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let set_opt_list_1_built = Vec::new();
        self.push(ASTType::SetOptList(set_opt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// `SetOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn set_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// `Element: Expr ElementOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn element(
        &mut self,
        _expr: &ParseTreeType<'t>,
        _element_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_opt = pop_item!(self, element_opt, ElementOpt, context);
        let expr = pop_item!(self, expr, Expr, context);
        let element_built = Element {
            expr: Box::new(expr),
            element_opt,
        };
        // Calling user action here
        self.user_grammar.element(&element_built)?;
        self.push(ASTType::Element(element_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// `ElementOpt /* Option<T>::Some */: "\.\."^ /* Clipped */ Expr;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt_0(
        &mut self,
        _dot_dot: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        let element_opt_0_built = ElementOpt {
            // Ignore clipped member 'dot_dot'
            expr: Box::new(expr),
        };
        self.push(
            ASTType::ElementOpt(Some(Box::new(element_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// `ElementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn element_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ElementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// `Relation: "="^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_0(&mut self, _equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation_0_built = RelationEqu {
        // Ignore clipped member 'equ'
        };
        let relation_0_built = Relation::Equ(relation_0_built);
        // Calling user action here
        self.user_grammar.relation(&relation_0_built)?;
        self.push(ASTType::Relation(relation_0_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// `Relation: "#";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_1(&mut self, hash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token()?.clone();
        let relation_1_built = RelationHash { hash };
        let relation_1_built = Relation::Hash(relation_1_built);
        // Calling user action here
        self.user_grammar.relation(&relation_1_built)?;
        self.push(ASTType::Relation(relation_1_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// `Relation: "<";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_2(&mut self, l_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token()?.clone();
        let relation_2_built = RelationLT { l_t };
        let relation_2_built = Relation::LT(relation_2_built);
        // Calling user action here
        self.user_grammar.relation(&relation_2_built)?;
        self.push(ASTType::Relation(relation_2_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// `Relation: "<=";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_3(&mut self, l_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = l_t_equ.token()?.clone();
        let relation_3_built = RelationLTEqu { l_t_equ };
        let relation_3_built = Relation::LTEqu(relation_3_built);
        // Calling user action here
        self.user_grammar.relation(&relation_3_built)?;
        self.push(ASTType::Relation(relation_3_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// `Relation: ">";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_4(&mut self, g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t.token()?.clone();
        let relation_4_built = RelationGT { g_t };
        let relation_4_built = Relation::GT(relation_4_built);
        // Calling user action here
        self.user_grammar.relation(&relation_4_built)?;
        self.push(ASTType::Relation(relation_4_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// `Relation: ">=";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_5(&mut self, g_t_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = g_t_equ.token()?.clone();
        let relation_5_built = RelationGTEqu { g_t_equ };
        let relation_5_built = Relation::GTEqu(relation_5_built);
        // Calling user action here
        self.user_grammar.relation(&relation_5_built)?;
        self.push(ASTType::Relation(relation_5_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// `Relation: InOp;`
    ///
    #[parol_runtime::function_name::named]
    fn relation_6(&mut self, _in_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_op = pop_item!(self, in_op, InOp, context);
        let relation_6_built = RelationInOp { in_op };
        let relation_6_built = Relation::InOp(relation_6_built);
        // Calling user action here
        self.user_grammar.relation(&relation_6_built)?;
        self.push(ASTType::Relation(relation_6_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// `Relation: "IS";`
    ///
    #[parol_runtime::function_name::named]
    fn relation_7(&mut self, i_s: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_s = i_s.token()?.clone();
        let relation_7_built = RelationIS { i_s };
        let relation_7_built = Relation::IS(relation_7_built);
        // Calling user action here
        self.user_grammar.relation(&relation_7_built)?;
        self.push(ASTType::Relation(relation_7_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// `AddOp: "\+";`
    ///
    #[parol_runtime::function_name::named]
    fn add_op_0(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let add_op_0_built = AddOpPlus { plus };
        let add_op_0_built = AddOp::Plus(add_op_0_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_0_built)?;
        self.push(ASTType::AddOp(add_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// `AddOp: "-";`
    ///
    #[parol_runtime::function_name::named]
    fn add_op_1(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let add_op_1_built = AddOpMinus { minus };
        let add_op_1_built = AddOp::Minus(add_op_1_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_1_built)?;
        self.push(ASTType::AddOp(add_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// `AddOp: "OR";`
    ///
    #[parol_runtime::function_name::named]
    fn add_op_2(&mut self, o_r: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let o_r = o_r.token()?.clone();
        let add_op_2_built = AddOpOR { o_r };
        let add_op_2_built = AddOp::OR(add_op_2_built);
        // Calling user action here
        self.user_grammar.add_op(&add_op_2_built)?;
        self.push(ASTType::AddOp(add_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// `MulOp: "\*";`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token()?.clone();
        let mul_op_0_built = MulOpStar { star };
        let mul_op_0_built = MulOp::Star(mul_op_0_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_0_built)?;
        self.push(ASTType::MulOp(mul_op_0_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// `MulOp: "/";`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op_1(&mut self, slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash.token()?.clone();
        let mul_op_1_built = MulOpSlash { slash };
        let mul_op_1_built = MulOp::Slash(mul_op_1_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_1_built)?;
        self.push(ASTType::MulOp(mul_op_1_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// `MulOp: "DIV";`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op_2(&mut self, d_i_v: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let d_i_v = d_i_v.token()?.clone();
        let mul_op_2_built = MulOpDIV { d_i_v };
        let mul_op_2_built = MulOp::DIV(mul_op_2_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_2_built)?;
        self.push(ASTType::MulOp(mul_op_2_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// `MulOp: "MOD";`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op_3(&mut self, m_o_d: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_o_d = m_o_d.token()?.clone();
        let mul_op_3_built = MulOpMOD { m_o_d };
        let mul_op_3_built = MulOp::MOD(mul_op_3_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_3_built)?;
        self.push(ASTType::MulOp(mul_op_3_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// `MulOp: "&";`
    ///
    #[parol_runtime::function_name::named]
    fn mul_op_4(&mut self, amp: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = amp.token()?.clone();
        let mul_op_4_built = MulOpAmp { amp };
        let mul_op_4_built = MulOp::Amp(mul_op_4_built);
        // Calling user action here
        self.user_grammar.mul_op(&mul_op_4_built)?;
        self.push(ASTType::MulOp(mul_op_4_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// `Designator: QualIdent DesignatorList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn designator(
        &mut self,
        _qual_ident: &ParseTreeType<'t>,
        _designator_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list = pop_and_reverse_item!(self, designator_list, DesignatorList, context);
        let qual_ident = pop_item!(self, qual_ident, QualIdent, context);
        let designator_built = Designator {
            qual_ident,
            designator_list,
        };
        // Calling user action here
        self.user_grammar.designator(&designator_built)?;
        self.push(ASTType::Designator(designator_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// `DesignatorList /* Vec<T>::Push */: DesignatorSuffix DesignatorList;`
    ///
    #[parol_runtime::function_name::named]
    fn designator_list_0(
        &mut self,
        _designator_suffix: &ParseTreeType<'t>,
        _designator_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut designator_list = pop_item!(self, designator_list, DesignatorList, context);
        let designator_suffix = pop_item!(self, designator_suffix, DesignatorSuffix, context);
        let designator_list_0_built = DesignatorList {
            designator_suffix: Box::new(designator_suffix),
        };
        // Add an element to the vector
        designator_list.push(designator_list_0_built);
        self.push(ASTType::DesignatorList(designator_list), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// `DesignatorList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn designator_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_list_1_built = Vec::new();
        self.push(ASTType::DesignatorList(designator_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// `DesignatorSuffix: "\."^ /* Clipped */ Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn designator_suffix_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let designator_suffix_0_built = DesignatorSuffixDotIdent {
            // Ignore clipped member 'dot'
            ident,
        };
        let designator_suffix_0_built = DesignatorSuffix::DotIdent(designator_suffix_0_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_0_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// `DesignatorSuffix: "\["^ /* Clipped */ ExprList "\]"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn designator_suffix_1(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expr_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list = pop_item!(self, expr_list, ExprList, context);
        let designator_suffix_1_built = DesignatorSuffixLBracketExprListRBracket {
            // Ignore clipped member 'l_bracket'
            expr_list: Box::new(expr_list),
            // Ignore clipped member 'r_bracket'
        };
        let designator_suffix_1_built =
            DesignatorSuffix::LBracketExprListRBracket(designator_suffix_1_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_1_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// `DesignatorSuffix: "\^"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn designator_suffix_2(&mut self, _circumflex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let designator_suffix_2_built = DesignatorSuffixCircumflex {
        // Ignore clipped member 'circumflex'
        };
        let designator_suffix_2_built = DesignatorSuffix::Circumflex(designator_suffix_2_built);
        // Calling user action here
        self.user_grammar
            .designator_suffix(&designator_suffix_2_built)?;
        self.push(
            ASTType::DesignatorSuffix(designator_suffix_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// `ExprList: Expr ExprListList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expr_list(
        &mut self,
        _expr: &ParseTreeType<'t>,
        _expr_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list = pop_and_reverse_item!(self, expr_list_list, ExprListList, context);
        let expr = pop_item!(self, expr, Expr, context);
        let expr_list_built = ExprList {
            expr: Box::new(expr),
            expr_list_list,
        };
        // Calling user action here
        self.user_grammar.expr_list(&expr_list_built)?;
        self.push(ASTType::ExprList(expr_list_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// `ExprListList /* Vec<T>::Push */: ","^ /* Clipped */ Expr ExprListList;`
    ///
    #[parol_runtime::function_name::named]
    fn expr_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _expr_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expr_list_list = pop_item!(self, expr_list_list, ExprListList, context);
        let expr = pop_item!(self, expr, Expr, context);
        let expr_list_list_0_built = ExprListList {
            expr: Box::new(expr),
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        expr_list_list.push(expr_list_list_0_built);
        self.push(ASTType::ExprListList(expr_list_list), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// `ExprListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expr_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr_list_list_1_built = Vec::new();
        self.push(ASTType::ExprListList(expr_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// `IdentList: IdentDef IdentListList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_list(
        &mut self,
        _ident_def: &ParseTreeType<'t>,
        _ident_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list = pop_and_reverse_item!(self, ident_list_list, IdentListList, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let ident_list_built = IdentList {
            ident_def,
            ident_list_list,
        };
        // Calling user action here
        self.user_grammar.ident_list(&ident_list_built)?;
        self.push(ASTType::IdentList(ident_list_built), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// `IdentListList /* Vec<T>::Push */: ","^ /* Clipped */ IdentDef IdentListList;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _ident_def: &ParseTreeType<'t>,
        _ident_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut ident_list_list = pop_item!(self, ident_list_list, IdentListList, context);
        let ident_def = pop_item!(self, ident_def, IdentDef, context);
        let ident_list_list_0_built = IdentListList {
            ident_def,
            // Ignore clipped member 'comma'
        };
        // Add an element to the vector
        ident_list_list.push(ident_list_list_0_built);
        self.push(ASTType::IdentListList(ident_list_list), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// `IdentListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list_1_built = Vec::new();
        self.push(ASTType::IdentListList(ident_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// `QualIdent: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn qual_ident_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let qual_ident_0_built = QualIdentIdent { ident };
        let qual_ident_0_built = QualIdent::Ident(qual_ident_0_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_0_built)?;
        self.push(ASTType::QualIdent(qual_ident_0_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// `QualIdent: QIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn qual_ident_1(&mut self, _q_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = pop_item!(self, q_ident, QIdent, context);
        let qual_ident_1_built = QualIdentQIdent { q_ident };
        let qual_ident_1_built = QualIdent::QIdent(qual_ident_1_built);
        // Calling user action here
        self.user_grammar.qual_ident(&qual_ident_1_built)?;
        self.push(ASTType::QualIdent(qual_ident_1_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// `IdentDef: Ident IdentDefOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_def(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _ident_def_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt = pop_item!(self, ident_def_opt, IdentDefOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let ident_def_built = IdentDef {
            ident,
            ident_def_opt,
        };
        // Calling user action here
        self.user_grammar.ident_def(&ident_def_built)?;
        self.push(ASTType::IdentDef(ident_def_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// `IdentDefOpt /* Option<T>::Some */: IdentDefOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_def_opt_0(&mut self, _ident_def_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_def_opt_group = pop_item!(self, ident_def_opt_group, IdentDefOptGroup, context);
        let ident_def_opt_0_built = IdentDefOpt {
            ident_def_opt_group,
        };
        self.push(
            ASTType::IdentDefOpt(Some(Box::new(ident_def_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// `IdentDefOptGroup: "\*";`
    ///
    #[parol_runtime::function_name::named]
    fn ident_def_opt_group_0(&mut self, star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token()?.clone();
        let ident_def_opt_group_0_built = IdentDefOptGroupStar { star };
        let ident_def_opt_group_0_built = IdentDefOptGroup::Star(ident_def_opt_group_0_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// `IdentDefOptGroup: "-";`
    ///
    #[parol_runtime::function_name::named]
    fn ident_def_opt_group_1(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let ident_def_opt_group_1_built = IdentDefOptGroupMinus { minus };
        let ident_def_opt_group_1_built = IdentDefOptGroup::Minus(ident_def_opt_group_1_built);
        self.push(
            ASTType::IdentDefOptGroup(ident_def_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// `IdentDefOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn ident_def_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IdentDefOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// `Number: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn number_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let number_0_built = NumberInteger { integer };
        let number_0_built = Number::Integer(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// `Number: Real;`
    ///
    #[parol_runtime::function_name::named]
    fn number_1(&mut self, _real: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = pop_item!(self, real, Real, context);
        let number_1_built = NumberReal { real };
        let number_1_built = Number::Real(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// `Real: "[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?";`
    ///
    #[parol_runtime::function_name::named]
    fn real(&mut self, real: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real = real.token()?.clone();
        let real_built = Real { real };
        // Calling user action here
        self.user_grammar.real(&real_built)?;
        self.push(ASTType::Real(real_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// `Character: "[0-9][0-9A-F]*X";`
    ///
    #[parol_runtime::function_name::named]
    fn character(&mut self, character: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let character = character.token()?.clone();
        let character_built = Character { character };
        // Calling user action here
        self.user_grammar.character(&character_built)?;
        self.push(ASTType::Character(character_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// `Integer: "[0-9][0-9]*|[0-9][0-9A-F]*H";`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// `QIdent: "[a-zA-Z_]\w*\.[a-zA-Z_]\w*";`
    ///
    #[parol_runtime::function_name::named]
    fn q_ident(&mut self, q_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_ident = q_ident.token()?.clone();
        let q_ident_built = QIdent { q_ident };
        // Calling user action here
        self.user_grammar.q_ident(&q_ident_built)?;
        self.push(ASTType::QIdent(q_ident_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// `Ident: "[a-zA-Z_]\w*";`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// `String: "\u{0022}[^\u{0022}]*\u{0022}|'[^']*'";`
    ///
    #[parol_runtime::function_name::named]
    fn string(&mut self, string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string.token()?.clone();
        let string_built = String { string };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// `InOp: "IN"^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn in_op(&mut self, _in_op: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_op_built = InOp {
        // Ignore clipped member 'in_op'
        };
        // Calling user action here
        self.user_grammar.in_op(&in_op_built)?;
        self.push(ASTType::InOp(in_op_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for Oberon2GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Oberon2Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.kw_begin(&children[0]),
            1 => self.kw_case(&children[0]),
            2 => self.kw_do(&children[0]),
            3 => self.kw_else(&children[0]),
            4 => self.kw_elsif(&children[0]),
            5 => self.kw_end(&children[0]),
            6 => self.kw_if(&children[0]),
            7 => self.kw_of(&children[0]),
            8 => self.kw_procedure(&children[0]),
            9 => self.kw_then(&children[0]),
            10 => self.kw_to(&children[0]),
            11 => self.kw_var(&children[0]),
            12 => self.oberon2(&children[0], &children[1], &children[2], &children[3]),
            13 => self.oberon2_opt_0(&children[0]),
            14 => self.oberon2_opt_1(),
            15 => self.module_head(&children[0], &children[1], &children[2]),
            16 => self.module_body(&children[0], &children[1]),
            17 => self.import_list(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            18 => self.import_list_list_0(&children[0], &children[1], &children[2], &children[3]),
            19 => self.import_list_list_1(),
            20 => self.import_list_opt0_0(&children[0], &children[1]),
            21 => self.import_list_opt0_1(),
            22 => self.import_list_opt_0(&children[0], &children[1]),
            23 => self.import_list_opt_1(),
            24 => self.decl_seq(&children[0], &children[1]),
            25 => self.decl_seq_list0_0(&children[0], &children[1]),
            26 => self.decl_seq_list0_group_0(&children[0], &children[1]),
            27 => self.decl_seq_list0_group_1(&children[0], &children[1]),
            28 => self.decl_seq_list0_1(),
            29 => self.decl_seq_list_0(&children[0], &children[1]),
            30 => self.decl_seq_list_1(),
            31 => self.decl_block_0(&children[0]),
            32 => self.decl_block_1(&children[0]),
            33 => self.decl_block_2(&children[0]),
            34 => self.const_decl_block(&children[0], &children[1]),
            35 => self.const_decl_block_list_0(&children[0], &children[1], &children[2]),
            36 => self.const_decl_block_list_1(),
            37 => self.type_decl_block(&children[0], &children[1]),
            38 => self.type_decl_block_list_0(&children[0], &children[1], &children[2]),
            39 => self.type_decl_block_list_1(),
            40 => self.var_decl_block(&children[0], &children[1]),
            41 => self.var_decl_block_list_0(&children[0], &children[1], &children[2]),
            42 => self.var_decl_block_list_1(),
            43 => self.const_decl(&children[0], &children[1], &children[2]),
            44 => self.type_decl(&children[0], &children[1], &children[2]),
            45 => self.var_decl(&children[0], &children[1], &children[2]),
            46 => self.proc_decl(&children[0], &children[1], &children[2]),
            47 => self.procedure_heading(&children[0], &children[1], &children[2], &children[3]),
            48 => self.procedure_heading_opt0_0(&children[0]),
            49 => self.procedure_heading_opt0_1(),
            50 => self.procedure_heading_opt_0(&children[0]),
            51 => self.procedure_heading_opt_1(),
            52 => self.procedure_body(&children[0], &children[1]),
            53 => self.statement_block(&children[0], &children[1], &children[2]),
            54 => self.statement_block_opt_0(&children[0], &children[1]),
            55 => self.statement_block_opt_1(),
            56 => self.forward_decl(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            57 => self.forward_decl_opt0_0(&children[0]),
            58 => self.forward_decl_opt0_1(),
            59 => self.forward_decl_opt_0(&children[0]),
            60 => self.forward_decl_opt_1(),
            61 => self.formal_pars(&children[0], &children[1], &children[2], &children[3]),
            62 => self.formal_pars_opt0_0(&children[0], &children[1]),
            63 => self.formal_pars_opt0_1(),
            64 => self.formal_pars_opt_0(&children[0], &children[1]),
            65 => self.formal_pars_opt_list_0(&children[0], &children[1], &children[2]),
            66 => self.formal_pars_opt_list_1(),
            67 => self.formal_pars_opt_1(),
            68 => self.f_p_section(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            69 => self.f_p_section_list_0(&children[0], &children[1], &children[2]),
            70 => self.f_p_section_list_1(),
            71 => self.f_p_section_opt_0(&children[0]),
            72 => self.f_p_section_opt_1(),
            73 => self.receiver(&children[0], &children[1], &children[2], &children[3]),
            74 => self.receiver_opt_0(&children[0]),
            75 => self.receiver_opt_1(),
            76 => self.receiver_var_decl(&children[0], &children[1], &children[2]),
            77 => self.type_def_0(&children[0]),
            78 => self.type_def_1(&children[0], &children[1], &children[2], &children[3]),
            79 => self.type_def_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            80 => self.type_def_list_0(&children[0], &children[1], &children[2]),
            81 => self.type_def_list_1(),
            82 => self.type_def_3(&children[0], &children[1], &children[2]),
            83 => self.type_def_4(&children[0], &children[1]),
            84 => self.type_def_opt1_0(&children[0]),
            85 => self.type_def_opt1_1(),
            86 => self.type_def_opt0_0(&children[0], &children[1], &children[2]),
            87 => self.type_def_opt0_1(),
            88 => self.type_def_opt_0(&children[0], &children[1]),
            89 => self.type_def_opt_list_0(&children[0], &children[1], &children[2]),
            90 => self.type_def_opt_list_1(),
            91 => self.type_def_opt_1(),
            92 => self.field_list(&children[0]),
            93 => self.field_list_opt_0(&children[0], &children[1], &children[2]),
            94 => self.field_list_opt_1(),
            95 => self.statement_seq(&children[0], &children[1]),
            96 => self.statement_seq_list_0(&children[0], &children[1], &children[2]),
            97 => self.statement_seq_list_1(),
            98 => self.statement(&children[0]),
            99 => self.statement_opt_0(&children[0]),
            100 => self.statement_opt_group_0(&children[0], &children[1]),
            101 => self.statement_opt_group_suffix_0(&children[0], &children[1]),
            102 => self.statement_opt_group_suffix_1(&children[0]),
            103 => self.statement_opt_group_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            104 => self.statement_opt_group_2(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            105 => self.statement_opt_group_3(&children[0], &children[1], &children[2]),
            106 => {
                self.statement_opt_group_4(&children[0], &children[1], &children[2], &children[3])
            }
            107 => {
                self.statement_opt_group_5(&children[0], &children[1], &children[2], &children[3])
            }
            108 => self.statement_opt_group_6(&children[0], &children[1], &children[2]),
            109 => {
                self.statement_opt_group_7(&children[0], &children[1], &children[2], &children[3])
            }
            110 => self.statement_opt_group_8(&children[0]),
            111 => self.statement_opt_group_9(&children[0], &children[1]),
            112 => self.statement_opt_group_list_0(&children[0], &children[1]),
            113 => self.statement_opt_group_list_1(),
            114 => self.statement_opt_group_list0_0(&children[0], &children[1], &children[2]),
            115 => self.statement_opt_group_list0_1(),
            116 => self.statement_opt2_0(&children[0]),
            117 => self.statement_opt2_1(),
            118 => self.statement_opt1_0(&children[0]),
            119 => self.statement_opt1_1(),
            120 => self.statement_opt0_0(&children[0], &children[1], &children[2]),
            121 => self.statement_opt3_0(&children[0]),
            122 => self.statement_opt3_1(),
            123 => self.statement_opt0_1(),
            124 => self.statement_opt_1(),
            125 => self.then_block(&children[0], &children[1]),
            126 => self.cases(&children[0], &children[1]),
            127 => self.cases_list_0(&children[0], &children[1], &children[2]),
            128 => self.cases_list_1(),
            129 => self.elsif_part(&children[0], &children[1], &children[2]),
            130 => self.else_part(&children[0], &children[1]),
            131 => self.opt_else_part_end(&children[0], &children[1]),
            132 => self.opt_else_part_end_opt_0(&children[0]),
            133 => self.opt_else_part_end_opt_1(),
            134 => self.do_block(&children[0], &children[1], &children[2]),
            135 => self.guarded_do_block(&children[0], &children[1], &children[2]),
            136 => self.for_init(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            137 => self.for_step(&children[0], &children[1]),
            138 => self.case(&children[0]),
            139 => self.case_opt_0(&children[0], &children[1], &children[2], &children[3]),
            140 => self.case_opt_list_0(&children[0], &children[1], &children[2]),
            141 => self.case_opt_list_1(),
            142 => self.case_opt_1(),
            143 => self.case_labels(&children[0], &children[1]),
            144 => self.case_labels_opt_0(&children[0], &children[1]),
            145 => self.case_labels_opt_1(),
            146 => self.guard(&children[0], &children[1], &children[2]),
            147 => self.const_expr(&children[0]),
            148 => self.expr(&children[0], &children[1]),
            149 => self.expr_opt_0(&children[0], &children[1]),
            150 => self.expr_opt_1(),
            151 => self.simple_expr(&children[0], &children[1], &children[2]),
            152 => self.simple_expr_list_0(&children[0], &children[1], &children[2]),
            153 => self.simple_expr_list_1(),
            154 => self.simple_expr_opt_0(&children[0]),
            155 => self.simple_expr_opt_group_0(&children[0]),
            156 => self.simple_expr_opt_group_1(&children[0]),
            157 => self.simple_expr_opt_1(),
            158 => self.term(&children[0], &children[1]),
            159 => self.term_list_0(&children[0], &children[1], &children[2]),
            160 => self.term_list_1(),
            161 => self.factor_0(&children[0], &children[1]),
            162 => self.factor_1(&children[0]),
            163 => self.factor_2(&children[0]),
            164 => self.factor_3(&children[0]),
            165 => self.factor_4(&children[0]),
            166 => self.factor_5(&children[0]),
            167 => self.factor_6(&children[0], &children[1], &children[2]),
            168 => self.factor_7(&children[0], &children[1]),
            169 => self.factor_opt_0(&children[0], &children[1], &children[2]),
            170 => self.factor_opt0_0(&children[0]),
            171 => self.factor_opt0_1(),
            172 => self.factor_opt_1(),
            173 => self.set(&children[0], &children[1], &children[2]),
            174 => self.set_opt_0(&children[0], &children[1]),
            175 => self.set_opt_list_0(&children[0], &children[1], &children[2]),
            176 => self.set_opt_list_1(),
            177 => self.set_opt_1(),
            178 => self.element(&children[0], &children[1]),
            179 => self.element_opt_0(&children[0], &children[1]),
            180 => self.element_opt_1(),
            181 => self.relation_0(&children[0]),
            182 => self.relation_1(&children[0]),
            183 => self.relation_2(&children[0]),
            184 => self.relation_3(&children[0]),
            185 => self.relation_4(&children[0]),
            186 => self.relation_5(&children[0]),
            187 => self.relation_6(&children[0]),
            188 => self.relation_7(&children[0]),
            189 => self.add_op_0(&children[0]),
            190 => self.add_op_1(&children[0]),
            191 => self.add_op_2(&children[0]),
            192 => self.mul_op_0(&children[0]),
            193 => self.mul_op_1(&children[0]),
            194 => self.mul_op_2(&children[0]),
            195 => self.mul_op_3(&children[0]),
            196 => self.mul_op_4(&children[0]),
            197 => self.designator(&children[0], &children[1]),
            198 => self.designator_list_0(&children[0], &children[1]),
            199 => self.designator_list_1(),
            200 => self.designator_suffix_0(&children[0], &children[1]),
            201 => self.designator_suffix_1(&children[0], &children[1], &children[2]),
            202 => self.designator_suffix_2(&children[0]),
            203 => self.expr_list(&children[0], &children[1]),
            204 => self.expr_list_list_0(&children[0], &children[1], &children[2]),
            205 => self.expr_list_list_1(),
            206 => self.ident_list(&children[0], &children[1]),
            207 => self.ident_list_list_0(&children[0], &children[1], &children[2]),
            208 => self.ident_list_list_1(),
            209 => self.qual_ident_0(&children[0]),
            210 => self.qual_ident_1(&children[0]),
            211 => self.ident_def(&children[0], &children[1]),
            212 => self.ident_def_opt_0(&children[0]),
            213 => self.ident_def_opt_group_0(&children[0]),
            214 => self.ident_def_opt_group_1(&children[0]),
            215 => self.ident_def_opt_1(),
            216 => self.number_0(&children[0]),
            217 => self.number_1(&children[0]),
            218 => self.real(&children[0]),
            219 => self.character(&children[0]),
            220 => self.integer(&children[0]),
            221 => self.q_ident(&children[0]),
            222 => self.ident(&children[0]),
            223 => self.string(&children[0]),
            224 => self.in_op(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
