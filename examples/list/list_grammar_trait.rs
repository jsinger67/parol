// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ListGrammarTrait<'t> {
    /// Semantic action for non-terminal 'List'
    fn list(&mut self, _arg: &List<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ListRest'
    fn list_rest(&mut self, _arg: &ListRest<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Num'
    fn num(&mut self, _arg: &Num<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct List<'t> {
    pub list_opt: Option<ListOpt<'t>>,
}

///
/// Type derived for non-terminal ListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListOpt<'t> {
    pub num: Box<Num<'t>>,
    pub list_rest: Box<ListRest<'t>>,
    pub list_opt0: Option<ListOpt0<'t>>,
}

///
/// Type derived for non-terminal ListOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListOpt0<'t> {
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal ListRest
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListRest<'t> {
    pub list_rest_opt: Option<ListRestOpt<'t>>,
}

///
/// Type derived for non-terminal ListRestOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListRestOpt<'t> {
    pub comma: Token<'t>, /* , */
    pub num: Box<Num<'t>>,
    pub list_rest: Box<ListRest<'t>>,
}

///
/// Type derived for non-terminal Num
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Num<'t> {
    pub num: Token<'t>, /* 0|[1-9][0-9]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    List(List<'t>),
    ListOpt(Option<ListOpt<'t>>),
    ListOpt0(Option<ListOpt0<'t>>),
    ListRest(ListRest<'t>),
    ListRestOpt(Option<ListRestOpt<'t>>),
    Num(Num<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ListGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ListGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ListGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ListGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ListGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `List: ListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn list(&mut self, _list_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_opt = pop_item!(self, list_opt, ListOpt, context);
        let list_built = List { list_opt };
        // Calling user action here
        self.user_grammar.list(&list_built)?;
        self.push(ASTType::List(list_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `ListOpt /* Option<T>::Some */: Num ListRest ListOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn list_opt_0(
        &mut self,
        _num: &ParseTreeType<'t>,
        _list_rest: &ParseTreeType<'t>,
        _list_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_opt0 = pop_item!(self, list_opt0, ListOpt0, context);
        let list_rest = pop_item!(self, list_rest, ListRest, context);
        let num = pop_item!(self, num, Num, context);
        let list_opt_0_built = ListOpt {
            num: Box::new(num),
            list_rest: Box::new(list_rest),
            list_opt0,
        };
        self.push(ASTType::ListOpt(Some(list_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `ListOpt0 /* Option<T>::Some */: ",";`
    ///
    #[parol_runtime::function_name::named]
    fn list_opt0_0(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let list_opt0_0_built = ListOpt0 { comma };
        self.push(ASTType::ListOpt0(Some(list_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `ListOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn list_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ListOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `ListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `ListRest: ListRestOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn list_rest(&mut self, _list_rest_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_rest_opt = pop_item!(self, list_rest_opt, ListRestOpt, context);
        let list_rest_built = ListRest { list_rest_opt };
        // Calling user action here
        self.user_grammar.list_rest(&list_rest_built)?;
        self.push(ASTType::ListRest(list_rest_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `ListRestOpt /* Option<T>::Some */: "," Num ListRest;`
    ///
    #[parol_runtime::function_name::named]
    fn list_rest_opt_0(
        &mut self,
        comma: &ParseTreeType<'t>,
        _num: &ParseTreeType<'t>,
        _list_rest: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let list_rest = pop_item!(self, list_rest, ListRest, context);
        let num = pop_item!(self, num, Num, context);
        let list_rest_opt_0_built = ListRestOpt {
            comma,
            num: Box::new(num),
            list_rest: Box::new(list_rest),
        };
        self.push(ASTType::ListRestOpt(Some(list_rest_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `ListRestOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn list_rest_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ListRestOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Num: "0|[1-9][0-9]*";`
    ///
    #[parol_runtime::function_name::named]
    fn num(&mut self, num: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let num = num.token()?.clone();
        let num_built = Num { num };
        // Calling user action here
        self.user_grammar.num(&num_built)?;
        self.push(ASTType::Num(num_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ListGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ListGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.list(&children[0]),
            1 => self.list_opt_0(&children[0], &children[1], &children[2]),
            2 => self.list_opt0_0(&children[0]),
            3 => self.list_opt0_1(),
            4 => self.list_opt_1(),
            5 => self.list_rest(&children[0]),
            6 => self.list_rest_opt_0(&children[0], &children[1], &children[2]),
            7 => self.list_rest_opt_1(),
            8 => self.num(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
