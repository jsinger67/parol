use crate::boolean_grammar_trait::{
    BinaryOperator, Boolean, BooleanGrammarTrait, Expression, ExpressionList, Expressions,
    ExpressionsList, Factor, FactorBoolean, FactorParenthesized, Term, UnaryOperator,
};
use parol_runtime::Result;
use std::fmt::{Debug, Display, Error, Formatter};
use std::marker::PhantomData;

///
/// Data structure that implements the semantic actions for our boolean grammar
///
#[derive(Debug, Default)]
pub struct BooleanGrammar<'t> {
    expressions: Option<Expressions>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

impl BooleanGrammar<'_> {
    pub fn new() -> Self {
        BooleanGrammar::default()
    }

    // --------------------- Implementation of calculations --------------------
    fn calculate(&self) {
        if let Some(expressions) = &self.expressions {
            println!(
                "{} = {};",
                expressions.expression,
                if Self::calculate_expression(&expressions.expression) {
                    "TRUE"
                } else {
                    "FALSE"
                }
            );
            expressions.expressions_list.iter().for_each(|expr| {
                println!(
                    "{} = {};",
                    expr.expression,
                    if Self::calculate_expression(&expr.expression) {
                        "TRUE"
                    } else {
                        "FALSE"
                    }
                )
            });
        } else {
            println!("No expressions found");
        };
    }

    fn calculate_expression(expression: &Expression) -> bool {
        let result = Self::calculate_term(&expression.term);
        expression
            .expression_list
            .iter()
            .fold(result, |mut acc, term| {
                acc = Self::calculate_term_with_lhs(acc, term);
                acc
            })
    }

    fn calculate_term(term: &Term) -> bool {
        match &term.term_opt {
            Some(_) => !Self::calculate_factor(&term.factor),
            None => Self::calculate_factor(&term.factor),
        }
    }

    fn calculate_factor(factor: &Factor) -> bool {
        match factor {
            Factor::Boolean(factor_boolean) => Self::calculate_factor_boolean(factor_boolean),
            Factor::Parenthesized(factor_parenthesized) => {
                Self::calculate_expression(&factor_parenthesized.parenthesized.expression)
            }
        }
    }

    fn calculate_factor_boolean(factor_boolean: &FactorBoolean) -> bool {
        match factor_boolean.boolean {
            Boolean::True(_) => true,
            Boolean::False(_) => false,
        }
    }

    fn calculate_term_with_lhs(lhs: bool, term: &ExpressionList) -> bool {
        match term.binary_operator {
            BinaryOperator::AndOp(_) => lhs && Self::calculate_term(&term.term),
            BinaryOperator::OrOp(_) => lhs || Self::calculate_term(&term.term),
            BinaryOperator::XorOp(_) => lhs ^ Self::calculate_term(&term.term),
            BinaryOperator::NorOp(_) => !(lhs || Self::calculate_term(&term.term)),
            BinaryOperator::NandOp(_) => !(lhs && Self::calculate_term(&term.term)),
            BinaryOperator::XnorOp(_) => lhs == Self::calculate_term(&term.term),
        }
    }
}

impl Display for BooleanGrammar<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        writeln!(f, "{:?}", self.expressions)
    }
}

impl<'t> BooleanGrammarTrait<'t> for BooleanGrammar<'t> {
    /// Semantic action for non-terminal 'Expressions'
    fn expressions(&mut self, expression: &Expressions) -> Result<()> {
        self.expressions = Some(expression.clone());
        self.calculate();
        Ok(())
    }
}

// ------------------------ Display implementations ----------------------------

impl Display for BinaryOperator {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        match self {
            Self::AndOp(_) => write!(f, "AND"),
            Self::OrOp(_) => write!(f, "OR"),
            Self::XorOp(_) => write!(f, "XOR"),
            Self::NorOp(_) => write!(f, "NOR"),
            Self::NandOp(_) => write!(f, "NAND"),
            Self::XnorOp(_) => write!(f, "XNOR"),
        }
    }
}

impl Display for UnaryOperator {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, "NOT")
    }
}

impl Display for Expression {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, "{}", self.term)?;
        for expr in &self.expression_list {
            write!(f, " {} {}", expr.binary_operator, expr.term)?;
        }
        Ok(())
    }
}

impl Display for Term {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        match &self.term_opt {
            Some(op) => write!(f, "{} {}", op.unary_operator, self.factor),
            None => write!(f, "{}", self.factor),
        }
    }
}

impl Display for Factor {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        match &self {
            Factor::Boolean(factor_boolean) => write!(f, "{}", factor_boolean),
            Factor::Parenthesized(factor_parenthesized) => write!(f, "{}", factor_parenthesized),
        }
    }
}

impl Display for FactorBoolean {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        match self.boolean {
            Boolean::True(_) => write!(f, "TRUE"),
            Boolean::False(_) => write!(f, "FALSE"),
        }
    }
}

impl Display for FactorParenthesized {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, "({})", self.parenthesized.expression)
    }
}

impl Display for ExpressionsList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, "{}", self.expression)?;
        Ok(())
    }
}

impl Display for ExpressionList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::result::Result<(), Error> {
        write!(f, "{}", self.binary_operator)?;
        Ok(())
    }
}
