# calc_csharp

This example demonstrates a C# parser and semantic actions generated by `parol`.
It uses a calculator grammar and prints unassigned expression results plus the final variable environment.

Note: C# code generation currently supports only LL(k) grammars. Grammars with
`%grammar_type 'LALR(1)'` are rejected until the C# LALR(1) path is implemented.

## Run

From the repository root, execute:

```powershell
dotnet run --project .\examples\calc_csharp\calc_csharp.csproj -- examples/calc_csharp/test.txt
```

The sample input is in `examples/calc_csharp/test.txt`.

## Conversion principle (%nt_type mapping)

This example demonstrates the recommended modern type-mapping approach:

- `%nt_type` is the preferred way to define non-terminal type mappings.
- Grammar declaration: `%nt_type Number = CalcCsharp::CalcNumber`
- `parol` maps `Number` into `CalcNumber` through the generated mapping/conversion layer.
- Conversion happens through generated mapping/runtime conversion by using constructible target types.

In this example, `CalcNumber` provides constructors from `Token` and `Number` and stores the parsed `long` value.

## CI note

The project file imports `parol.targets`, which generates parser sources only when `parol` is available.
If `parol` is not on `PATH` (for example in CodeQL builds), generation is skipped with a warning and the checked-in generated files are used.

To use a custom executable path/name, pass:

```powershell
dotnet build .\examples\calc_csharp\calc_csharp.csproj /p:ParolCommand=parol
```
