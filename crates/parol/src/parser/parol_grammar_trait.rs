// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Parol'
    fn parol(&mut self, _arg: &Parol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prolog'
    fn prolog(&mut self, _arg: &Prolog<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartDeclaration'
    fn start_declaration(&mut self, _arg: &StartDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Declaration'
    fn declaration(&mut self, _arg: &Declaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerDirectives'
    fn scanner_directives(&mut self, _arg: &ScannerDirectives<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GrammarDefinition'
    fn grammar_definition(&mut self, _arg: &GrammarDefinition<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleColon'
    fn double_colon(&mut self, _arg: &DoubleColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Production'
    fn production(&mut self, _arg: &Production<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternations'
    fn alternations(&mut self, _arg: &Alternations<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alternation'
    fn alternation(&mut self, _arg: &Alternation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Symbol'
    fn symbol(&mut self, _arg: &Symbol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenLiteral'
    fn token_literal(&mut self, _arg: &TokenLiteral<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SimpleToken'
    fn simple_token(&mut self, _arg: &SimpleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenWithStates'
    fn token_with_states(&mut self, _arg: &TokenWithStates<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString'
    fn raw_string(&mut self, _arg: &RawString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Regex'
    fn regex(&mut self, _arg: &Regex<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Group'
    fn group(&mut self, _arg: &Group<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Optional'
    fn optional(&mut self, _arg: &Optional<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Repeat'
    fn repeat(&mut self, _arg: &Repeat<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonTerminal'
    fn non_terminal(&mut self, _arg: &NonTerminal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerState'
    fn scanner_state(&mut self, _arg: &ScannerState<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierList'
    fn identifier_list(&mut self, _arg: &IdentifierList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerSwitch'
    fn scanner_switch(&mut self, _arg: &ScannerSwitch<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ASTControl'
    fn a_s_t_control(&mut self, _arg: &ASTControl) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CutOperator'
    fn cut_operator(&mut self, _arg: &CutOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeDeclaration'
    fn user_type_declaration(&mut self, _arg: &UserTypeDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserTypeName'
    fn user_type_name(&mut self, _arg: &UserTypeName<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 7
///
/// `Declaration: '%title'^ /* Clipped */ String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentTitleString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 8
///
/// `Declaration: '%comment'^ /* Clipped */ String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentCommentString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 9
///
/// `Declaration: '%user_type'^ /* Clipped */ Identifier '='^ /* Clipped */ UserTypeName : UserType;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeName<'t> {
    pub identifier: Identifier<'t>,
    pub user_type_name: crate::parser::parol_grammar::UserDefinedTypeName,
}

///
/// Type derived for production 10
///
/// `Declaration: '%grammar_type'^ /* Clipped */ RawString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationPercentGrammarUnderscoreTypeRawString<'t> {
    pub raw_string: RawString<'t>,
}

///
/// Type derived for production 11
///
/// `Declaration: ScannerDirectives;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeclarationScannerDirectives<'t> {
    pub scanner_directives: ScannerDirectives<'t>,
}

///
/// Type derived for production 12
///
/// `ScannerDirectives: '%line_comment'^ /* Clipped */ TokenLiteral;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentLineUnderscoreCommentTokenLiteral<'t> {
    pub token_literal: TokenLiteral<'t>,
}

///
/// Type derived for production 13
///
/// `ScannerDirectives: '%block_comment'^ /* Clipped */ TokenLiteral TokenLiteral;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteral<'t> {
    pub token_literal: TokenLiteral<'t>,
    pub token_literal0: TokenLiteral<'t>,
}

///
/// Type derived for production 14
///
/// `ScannerDirectives: '%auto_newline_off'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOff {}

///
/// Type derived for production 15
///
/// `ScannerDirectives: '%auto_ws_off'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOff {}

///
/// Type derived for production 16
///
/// `ScannerDirectives: '%on'^ /* Clipped */ IdentifierList '%enter'^ /* Clipped */ Identifier;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerDirectivesPercentOnIdentifierListPercentEnterIdentifier<'t> {
    pub identifier_list: IdentifierList<'t>,
    pub identifier: Identifier<'t>,
}

///
/// Type derived for production 28
///
/// `Factor: Group;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorGroup<'t> {
    pub group: Group<'t>,
}

///
/// Type derived for production 29
///
/// `Factor: Repeat;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorRepeat<'t> {
    pub repeat: Repeat<'t>,
}

///
/// Type derived for production 30
///
/// `Factor: Optional;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOptional<'t> {
    pub optional: Optional<'t>,
}

///
/// Type derived for production 31
///
/// `Factor: Symbol;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorSymbol<'t> {
    pub symbol: Symbol<'t>,
}

///
/// Type derived for production 32
///
/// `Symbol: NonTerminal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolNonTerminal<'t> {
    pub non_terminal: NonTerminal<'t>,
}

///
/// Type derived for production 33
///
/// `Symbol: SimpleToken;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolSimpleToken<'t> {
    pub simple_token: SimpleToken<'t>,
}

///
/// Type derived for production 34
///
/// `Symbol: TokenWithStates;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolTokenWithStates<'t> {
    pub token_with_states: TokenWithStates<'t>,
}

///
/// Type derived for production 35
///
/// `Symbol: ScannerSwitch;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolScannerSwitch<'t> {
    pub scanner_switch: ScannerSwitch<'t>,
}

///
/// Type derived for production 36
///
/// `TokenLiteral: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 37
///
/// `TokenLiteral: RawString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralRawString<'t> {
    pub raw_string: RawString<'t>,
}

///
/// Type derived for production 38
///
/// `TokenLiteral: Regex;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLiteralRegex<'t> {
    pub regex: Regex<'t>,
}

///
/// Type derived for production 61
///
/// `ScannerSwitch: '%sc' '('^ /* Clipped */ ScannerSwitchOpt /* Option */ ')'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentScLParenScannerSwitchOptRParen<'t> {
    pub percent_sc: Token<'t>, /* %sc */
    pub scanner_switch_opt: Option<ScannerSwitchOpt<'t>>,
}

///
/// Type derived for production 62
///
/// `ScannerSwitch: '%push' '('^ /* Clipped */ Identifier ')'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentPushLParenIdentifierRParen<'t> {
    pub percent_push: Token<'t>, /* %push */
    pub identifier: Identifier<'t>,
}

///
/// Type derived for production 63
///
/// `ScannerSwitch: '%pop' '('^ /* Clipped */ ')'^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchPercentPopLParenRParen<'t> {
    pub percent_pop: Token<'t>, /* %pop */
}

///
/// Type derived for production 66
///
/// `ASTControl: CutOperator;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ASTControlCutOperator {
    pub cut_operator: CutOperator,
}

///
/// Type derived for production 67
///
/// `ASTControl: UserTypeDeclaration;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ASTControlUserTypeDeclaration {
    pub user_type_declaration: UserTypeDeclaration,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ASTControl
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTControl {
    CutOperator(ASTControlCutOperator),
    UserTypeDeclaration(ASTControlUserTypeDeclaration),
}

///
/// Type derived for non-terminal Alternation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Alternation<'t> {
    pub alternation_list: Vec<AlternationList<'t>>,
}

///
/// Type derived for non-terminal AlternationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlternationList<'t> {
    pub factor: Factor<'t>,
}

///
/// Type derived for non-terminal Alternations
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Alternations<'t> {
    pub alternation: Alternation<'t>,
    pub alternations_list: Vec<AlternationsList<'t>>,
}

///
/// Type derived for non-terminal AlternationsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlternationsList<'t> {
    pub alternation: Alternation<'t>,
}

///
/// Type derived for non-terminal CutOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CutOperator {}

///
/// Type derived for non-terminal Declaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Declaration<'t> {
    PercentTitleString(DeclarationPercentTitleString<'t>),
    PercentCommentString(DeclarationPercentCommentString<'t>),
    PercentUserUnderscoreTypeIdentifierEquUserTypeName(
        DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeName<'t>,
    ),
    PercentGrammarUnderscoreTypeRawString(DeclarationPercentGrammarUnderscoreTypeRawString<'t>),
    ScannerDirectives(DeclarationScannerDirectives<'t>),
}

///
/// Type derived for non-terminal DoubleColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleColon<'t> {
    pub double_colon: Token<'t>, /* :: */
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Group(FactorGroup<'t>),
    Repeat(FactorRepeat<'t>),
    Optional(FactorOptional<'t>),
    Symbol(FactorSymbol<'t>),
}

///
/// Type derived for non-terminal GrammarDefinition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GrammarDefinition<'t> {
    pub production: Production<'t>,
    pub grammar_definition_list: Vec<GrammarDefinitionList<'t>>,
}

///
/// Type derived for non-terminal GrammarDefinitionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GrammarDefinitionList<'t> {
    pub production: Production<'t>,
}

///
/// Type derived for non-terminal Group
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Group<'t> {
    pub l_paren: Token<'t>, /* ( */
    pub alternations: Alternations<'t>,
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Identifier<'t> {
    pub identifier: Token<'t>, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal IdentifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierList<'t> {
    pub identifier: Identifier<'t>,
    pub identifier_list_list: Vec<IdentifierListList<'t>>,
}

///
/// Type derived for non-terminal IdentifierListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierListList<'t> {
    pub identifier: Identifier<'t>,
}

///
/// Type derived for non-terminal NonTerminal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonTerminal<'t> {
    pub identifier: Identifier<'t>,
    pub non_terminal_opt: Option<NonTerminalOpt>,
}

///
/// Type derived for non-terminal NonTerminalOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NonTerminalOpt {
    pub a_s_t_control: ASTControl,
}

///
/// Type derived for non-terminal Optional
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Optional<'t> {
    pub l_bracket: Token<'t>, /* [ */
    pub alternations: Alternations<'t>,
    pub r_bracket: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal Parol
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parol<'t> {
    pub prolog: Prolog<'t>,
    pub grammar_definition: GrammarDefinition<'t>,
}

///
/// Type derived for non-terminal Production
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Production<'t> {
    pub identifier: Identifier<'t>,
    pub alternations: Alternations<'t>,
}

///
/// Type derived for non-terminal Prolog
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prolog<'t> {
    pub start_declaration: StartDeclaration<'t>,
    pub prolog_list: Vec<PrologList<'t>>,
    pub prolog_list0: Vec<PrologList0>,
}

///
/// Type derived for non-terminal PrologList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrologList<'t> {
    pub declaration: Declaration<'t>,
}

///
/// Type derived for non-terminal PrologList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrologList0 {
    pub scanner_state: crate::parser::parol_grammar::ScannerConfig,
}

///
/// Type derived for non-terminal RawString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawString<'t> {
    pub raw_string: Token<'t>, /* '(\\'|[^'])*?' */
}

///
/// Type derived for non-terminal Regex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Regex<'t> {
    pub regex: Token<'t>, /* \u{2F}(\\.|[^\\])*?\u{2F} */
}

///
/// Type derived for non-terminal Repeat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Repeat<'t> {
    pub l_brace: Token<'t>, /* { */
    pub alternations: Alternations<'t>,
    pub r_brace: Token<'t>, /* } */
}

///
/// Type derived for non-terminal ScannerDirectives
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerDirectives<'t> {
    PercentLineUnderscoreCommentTokenLiteral(
        ScannerDirectivesPercentLineUnderscoreCommentTokenLiteral<'t>,
    ),
    PercentBlockUnderscoreCommentTokenLiteralTokenLiteral(
        ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteral<'t>,
    ),
    PercentAutoUnderscoreNewlineUnderscoreOff(
        ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOff,
    ),
    PercentAutoUnderscoreWsUnderscoreOff(ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOff),
    PercentOnIdentifierListPercentEnterIdentifier(
        ScannerDirectivesPercentOnIdentifierListPercentEnterIdentifier<'t>,
    ),
}

///
/// Type derived for non-terminal ScannerState
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerState<'t> {
    pub identifier: Identifier<'t>,
    pub scanner_state_list: Vec<ScannerStateList<'t>>,
}

///
/// Type derived for non-terminal ScannerStateList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerStateList<'t> {
    pub scanner_directives: ScannerDirectives<'t>,
}

///
/// Type derived for non-terminal ScannerSwitch
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerSwitch<'t> {
    PercentScLParenScannerSwitchOptRParen(ScannerSwitchPercentScLParenScannerSwitchOptRParen<'t>),
    PercentPushLParenIdentifierRParen(ScannerSwitchPercentPushLParenIdentifierRParen<'t>),
    PercentPopLParenRParen(ScannerSwitchPercentPopLParenRParen<'t>),
}

///
/// Type derived for non-terminal ScannerSwitchOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScannerSwitchOpt<'t> {
    pub identifier: Identifier<'t>,
}

///
/// Type derived for non-terminal SimpleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleToken<'t> {
    pub token_literal: TokenLiteral<'t>,
    pub simple_token_opt: Option<SimpleTokenOpt>,
}

///
/// Type derived for non-terminal SimpleTokenOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SimpleTokenOpt {
    pub a_s_t_control: ASTControl,
}

///
/// Type derived for non-terminal StartDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StartDeclaration<'t> {
    pub identifier: Identifier<'t>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String<'t> {
    pub string: Token<'t>, /* "(\\.|[^\\])*?" */
}

///
/// Type derived for non-terminal Symbol
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Symbol<'t> {
    NonTerminal(SymbolNonTerminal<'t>),
    SimpleToken(SymbolSimpleToken<'t>),
    TokenWithStates(SymbolTokenWithStates<'t>),
    ScannerSwitch(SymbolScannerSwitch<'t>),
}

///
/// Type derived for non-terminal TokenLiteral
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TokenLiteral<'t> {
    String(TokenLiteralString<'t>),
    RawString(TokenLiteralRawString<'t>),
    Regex(TokenLiteralRegex<'t>),
}

///
/// Type derived for non-terminal TokenWithStates
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWithStates<'t> {
    pub identifier_list: IdentifierList<'t>,
    pub token_literal: TokenLiteral<'t>,
    pub token_with_states_opt: Option<TokenWithStatesOpt>,
}

///
/// Type derived for non-terminal TokenWithStatesOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWithStatesOpt {
    pub a_s_t_control: ASTControl,
}

///
/// Type derived for non-terminal UserTypeDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeDeclaration {
    pub user_type_name: crate::parser::parol_grammar::UserDefinedTypeName,
}

///
/// Type derived for non-terminal UserTypeName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeName<'t> {
    pub identifier: Identifier<'t>,
    pub user_type_name_list: Vec<UserTypeNameList<'t>>,
}

///
/// Type derived for non-terminal UserTypeNameList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UserTypeNameList<'t> {
    pub identifier: Identifier<'t>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    ASTControl(ASTControl),
    Alternation(Alternation<'t>),
    AlternationList(Vec<AlternationList<'t>>),
    Alternations(Alternations<'t>),
    AlternationsList(Vec<AlternationsList<'t>>),
    CutOperator(CutOperator),
    Declaration(Declaration<'t>),
    DoubleColon(DoubleColon<'t>),
    Factor(Factor<'t>),
    GrammarDefinition(GrammarDefinition<'t>),
    GrammarDefinitionList(Vec<GrammarDefinitionList<'t>>),
    Group(Group<'t>),
    Identifier(Identifier<'t>),
    IdentifierList(IdentifierList<'t>),
    IdentifierListList(Vec<IdentifierListList<'t>>),
    NonTerminal(NonTerminal<'t>),
    NonTerminalOpt(Option<NonTerminalOpt>),
    Optional(Optional<'t>),
    Parol(Parol<'t>),
    Production(Production<'t>),
    Prolog(Prolog<'t>),
    PrologList(Vec<PrologList<'t>>),
    PrologList0(Vec<PrologList0>),
    RawString(RawString<'t>),
    Regex(Regex<'t>),
    Repeat(Repeat<'t>),
    ScannerDirectives(ScannerDirectives<'t>),
    ScannerState(ScannerState<'t>),
    ScannerStateList(Vec<ScannerStateList<'t>>),
    ScannerSwitch(ScannerSwitch<'t>),
    ScannerSwitchOpt(Option<ScannerSwitchOpt<'t>>),
    SimpleToken(SimpleToken<'t>),
    SimpleTokenOpt(Option<SimpleTokenOpt>),
    StartDeclaration(StartDeclaration<'t>),
    String(String<'t>),
    Symbol(Symbol<'t>),
    TokenLiteral(TokenLiteral<'t>),
    TokenWithStates(TokenWithStates<'t>),
    TokenWithStatesOpt(Option<TokenWithStatesOpt>),
    UserTypeDeclaration(UserTypeDeclaration),
    UserTypeName(UserTypeName<'t>),
    UserTypeNameList(Vec<UserTypeNameList<'t>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Parol: Prolog GrammarDefinition;`
    ///
    #[parol_runtime::function_name::named]
    fn parol(
        &mut self,
        _prolog: &ParseTreeType<'t>,
        _grammar_definition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition = pop_item!(self, grammar_definition, GrammarDefinition, context);
        let prolog = pop_item!(self, prolog, Prolog, context);
        let parol_built = Parol {
            prolog,
            grammar_definition,
        };
        // Calling user action here
        self.user_grammar.parol(&parol_built)?;
        self.push(ASTType::Parol(parol_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `Prolog: StartDeclaration PrologList /* Vec */ PrologList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn prolog(
        &mut self,
        _start_declaration: &ParseTreeType<'t>,
        _prolog_list: &ParseTreeType<'t>,
        _prolog_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0 = pop_and_reverse_item!(self, prolog_list0, PrologList0, context);
        let prolog_list = pop_and_reverse_item!(self, prolog_list, PrologList, context);
        let start_declaration = pop_item!(self, start_declaration, StartDeclaration, context);
        let prolog_built = Prolog {
            start_declaration,
            prolog_list,
            prolog_list0,
        };
        // Calling user action here
        self.user_grammar.prolog(&prolog_built)?;
        self.push(ASTType::Prolog(prolog_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `PrologList0 /* Vec<T>::Push */: ScannerState : ScannerConfig PrologList0;`
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list0_0(
        &mut self,
        _scanner_state: &ParseTreeType<'t>,
        _prolog_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list0 = pop_item!(self, prolog_list0, PrologList0, context);
        let scanner_state = pop_item!(self, scanner_state, ScannerState, context);
        let prolog_list0_0_built = PrologList0 {
            scanner_state: (&scanner_state)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Add an element to the vector
        prolog_list0.push(prolog_list0_0_built);
        self.push(ASTType::PrologList0(prolog_list0), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `PrologList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list0_1_built = Vec::new();
        self.push(ASTType::PrologList0(prolog_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `PrologList /* Vec<T>::Push */: Declaration PrologList;`
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list_0(
        &mut self,
        _declaration: &ParseTreeType<'t>,
        _prolog_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut prolog_list = pop_item!(self, prolog_list, PrologList, context);
        let declaration = pop_item!(self, declaration, Declaration, context);
        let prolog_list_0_built = PrologList { declaration };
        // Add an element to the vector
        prolog_list.push(prolog_list_0_built);
        self.push(ASTType::PrologList(prolog_list), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `PrologList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn prolog_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prolog_list_1_built = Vec::new();
        self.push(ASTType::PrologList(prolog_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `StartDeclaration: '%start'^ /* Clipped */ Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn start_declaration(
        &mut self,
        _percent_start: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let start_declaration_built = StartDeclaration { identifier };
        // Calling user action here
        self.user_grammar
            .start_declaration(&start_declaration_built)?;
        self.push(ASTType::StartDeclaration(start_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Declaration: '%title'^ /* Clipped */ String;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_0(
        &mut self,
        _percent_title: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let declaration_0_built = DeclarationPercentTitleString { string };
        let declaration_0_built = Declaration::PercentTitleString(declaration_0_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_0_built)?;
        self.push(ASTType::Declaration(declaration_0_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Declaration: '%comment'^ /* Clipped */ String;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_1(
        &mut self,
        _percent_comment: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let declaration_1_built = DeclarationPercentCommentString { string };
        let declaration_1_built = Declaration::PercentCommentString(declaration_1_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_1_built)?;
        self.push(ASTType::Declaration(declaration_1_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Declaration: '%user_type'^ /* Clipped */ Identifier '='^ /* Clipped */ UserTypeName : UserType;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_2(
        &mut self,
        _percent_user_underscore_type: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _user_type_name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name = pop_item!(self, user_type_name, UserTypeName, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let declaration_2_built = DeclarationPercentUserUnderscoreTypeIdentifierEquUserTypeName {
            identifier,
            user_type_name: (&user_type_name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        let declaration_2_built =
            Declaration::PercentUserUnderscoreTypeIdentifierEquUserTypeName(declaration_2_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_2_built)?;
        self.push(ASTType::Declaration(declaration_2_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `Declaration: '%grammar_type'^ /* Clipped */ RawString;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_3(
        &mut self,
        _percent_grammar_underscore_type: &ParseTreeType<'t>,
        _raw_string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = pop_item!(self, raw_string, RawString, context);
        let declaration_3_built = DeclarationPercentGrammarUnderscoreTypeRawString { raw_string };
        let declaration_3_built =
            Declaration::PercentGrammarUnderscoreTypeRawString(declaration_3_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_3_built)?;
        self.push(ASTType::Declaration(declaration_3_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `Declaration: ScannerDirectives;`
    ///
    #[parol_runtime::function_name::named]
    fn declaration_4(&mut self, _scanner_directives: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives = pop_item!(self, scanner_directives, ScannerDirectives, context);
        let declaration_4_built = DeclarationScannerDirectives { scanner_directives };
        let declaration_4_built = Declaration::ScannerDirectives(declaration_4_built);
        // Calling user action here
        self.user_grammar.declaration(&declaration_4_built)?;
        self.push(ASTType::Declaration(declaration_4_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `ScannerDirectives: '%line_comment'^ /* Clipped */ TokenLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_0(
        &mut self,
        _percent_line_underscore_comment: &ParseTreeType<'t>,
        _token_literal: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let scanner_directives_0_built =
            ScannerDirectivesPercentLineUnderscoreCommentTokenLiteral { token_literal };
        let scanner_directives_0_built =
            ScannerDirectives::PercentLineUnderscoreCommentTokenLiteral(scanner_directives_0_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_0_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `ScannerDirectives: '%block_comment'^ /* Clipped */ TokenLiteral TokenLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_1(
        &mut self,
        _percent_block_underscore_comment: &ParseTreeType<'t>,
        _token_literal: &ParseTreeType<'t>,
        _token_literal0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_literal0 = pop_item!(self, token_literal0, TokenLiteral, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let scanner_directives_1_built =
            ScannerDirectivesPercentBlockUnderscoreCommentTokenLiteralTokenLiteral {
                token_literal,
                token_literal0,
            };
        let scanner_directives_1_built =
            ScannerDirectives::PercentBlockUnderscoreCommentTokenLiteralTokenLiteral(
                scanner_directives_1_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_1_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `ScannerDirectives: '%auto_newline_off'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_2(
        &mut self,
        _percent_auto_underscore_newline_underscore_off: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives_2_built =
            ScannerDirectivesPercentAutoUnderscoreNewlineUnderscoreOff {};
        let scanner_directives_2_built =
            ScannerDirectives::PercentAutoUnderscoreNewlineUnderscoreOff(
                scanner_directives_2_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_2_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `ScannerDirectives: '%auto_ws_off'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_3(
        &mut self,
        _percent_auto_underscore_ws_underscore_off: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_directives_3_built = ScannerDirectivesPercentAutoUnderscoreWsUnderscoreOff {};
        let scanner_directives_3_built =
            ScannerDirectives::PercentAutoUnderscoreWsUnderscoreOff(scanner_directives_3_built);
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_3_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `ScannerDirectives: '%on'^ /* Clipped */ IdentifierList '%enter'^ /* Clipped */ Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_directives_4(
        &mut self,
        _percent_on: &ParseTreeType<'t>,
        _identifier_list: &ParseTreeType<'t>,
        _percent_enter: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let identifier_list = pop_item!(self, identifier_list, IdentifierList, context);
        let scanner_directives_4_built =
            ScannerDirectivesPercentOnIdentifierListPercentEnterIdentifier {
                identifier_list,
                identifier,
            };
        let scanner_directives_4_built =
            ScannerDirectives::PercentOnIdentifierListPercentEnterIdentifier(
                scanner_directives_4_built,
            );
        // Calling user action here
        self.user_grammar
            .scanner_directives(&scanner_directives_4_built)?;
        self.push(
            ASTType::ScannerDirectives(scanner_directives_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `GrammarDefinition: '%%'^ /* Clipped */ Production GrammarDefinitionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition(
        &mut self,
        _percent_percent: &ParseTreeType<'t>,
        _production: &ParseTreeType<'t>,
        _grammar_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition_list = pop_and_reverse_item!(
            self,
            grammar_definition_list,
            GrammarDefinitionList,
            context
        );
        let production = pop_item!(self, production, Production, context);
        let grammar_definition_built = GrammarDefinition {
            production,
            grammar_definition_list,
        };
        // Calling user action here
        self.user_grammar
            .grammar_definition(&grammar_definition_built)?;
        self.push(
            ASTType::GrammarDefinition(grammar_definition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `GrammarDefinitionList /* Vec<T>::Push */: Production GrammarDefinitionList;`
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition_list_0(
        &mut self,
        _production: &ParseTreeType<'t>,
        _grammar_definition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut grammar_definition_list = pop_item!(
            self,
            grammar_definition_list,
            GrammarDefinitionList,
            context
        );
        let production = pop_item!(self, production, Production, context);
        let grammar_definition_list_0_built = GrammarDefinitionList { production };
        // Add an element to the vector
        grammar_definition_list.push(grammar_definition_list_0_built);
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `GrammarDefinitionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn grammar_definition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_definition_list_1_built = Vec::new();
        self.push(
            ASTType::GrammarDefinitionList(grammar_definition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `DoubleColon: '::';`
    ///
    #[parol_runtime::function_name::named]
    fn double_colon(&mut self, double_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_colon = double_colon.token()?.clone();
        let double_colon_built = DoubleColon { double_colon };
        // Calling user action here
        self.user_grammar.double_colon(&double_colon_built)?;
        self.push(ASTType::DoubleColon(double_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `Production: Identifier ':'^ /* Clipped */ Alternations ';'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn production(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _alternations: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations = pop_item!(self, alternations, Alternations, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let production_built = Production {
            identifier,
            alternations,
        };
        // Calling user action here
        self.user_grammar.production(&production_built)?;
        self.push(ASTType::Production(production_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Alternations: Alternation AlternationsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn alternations(
        &mut self,
        _alternation: &ParseTreeType<'t>,
        _alternations_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list =
            pop_and_reverse_item!(self, alternations_list, AlternationsList, context);
        let alternation = pop_item!(self, alternation, Alternation, context);
        let alternations_built = Alternations {
            alternation,
            alternations_list,
        };
        // Calling user action here
        self.user_grammar.alternations(&alternations_built)?;
        self.push(ASTType::Alternations(alternations_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `AlternationsList /* Vec<T>::Push */: '|'^ /* Clipped */ Alternation AlternationsList;`
    ///
    #[parol_runtime::function_name::named]
    fn alternations_list_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _alternation: &ParseTreeType<'t>,
        _alternations_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut alternations_list = pop_item!(self, alternations_list, AlternationsList, context);
        let alternation = pop_item!(self, alternation, Alternation, context);
        let alternations_list_0_built = AlternationsList { alternation };
        // Add an element to the vector
        alternations_list.push(alternations_list_0_built);
        self.push(ASTType::AlternationsList(alternations_list), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `AlternationsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn alternations_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternations_list_1_built = Vec::new();
        self.push(
            ASTType::AlternationsList(alternations_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `Alternation: AlternationList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn alternation(&mut self, _alternation_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list =
            pop_and_reverse_item!(self, alternation_list, AlternationList, context);
        let alternation_built = Alternation { alternation_list };
        // Calling user action here
        self.user_grammar.alternation(&alternation_built)?;
        self.push(ASTType::Alternation(alternation_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `AlternationList /* Vec<T>::Push */: Factor AlternationList;`
    ///
    #[parol_runtime::function_name::named]
    fn alternation_list_0(
        &mut self,
        _factor: &ParseTreeType<'t>,
        _alternation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut alternation_list = pop_item!(self, alternation_list, AlternationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let alternation_list_0_built = AlternationList { factor };
        // Add an element to the vector
        alternation_list.push(alternation_list_0_built);
        self.push(ASTType::AlternationList(alternation_list), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `AlternationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn alternation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alternation_list_1_built = Vec::new();
        self.push(ASTType::AlternationList(alternation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `Factor: Group;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group = pop_item!(self, group, Group, context);
        let factor_0_built = FactorGroup { group };
        let factor_0_built = Factor::Group(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `Factor: Repeat;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _repeat: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat = pop_item!(self, repeat, Repeat, context);
        let factor_1_built = FactorRepeat { repeat };
        let factor_1_built = Factor::Repeat(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `Factor: Optional;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(&mut self, _optional: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let optional = pop_item!(self, optional, Optional, context);
        let factor_2_built = FactorOptional { optional };
        let factor_2_built = Factor::Optional(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `Factor: Symbol;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(&mut self, _symbol: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let symbol = pop_item!(self, symbol, Symbol, context);
        let factor_3_built = FactorSymbol { symbol };
        let factor_3_built = Factor::Symbol(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `Symbol: NonTerminal;`
    ///
    #[parol_runtime::function_name::named]
    fn symbol_0(&mut self, _non_terminal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal = pop_item!(self, non_terminal, NonTerminal, context);
        let symbol_0_built = SymbolNonTerminal { non_terminal };
        let symbol_0_built = Symbol::NonTerminal(symbol_0_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_0_built)?;
        self.push(ASTType::Symbol(symbol_0_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `Symbol: SimpleToken;`
    ///
    #[parol_runtime::function_name::named]
    fn symbol_1(&mut self, _simple_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token = pop_item!(self, simple_token, SimpleToken, context);
        let symbol_1_built = SymbolSimpleToken { simple_token };
        let symbol_1_built = Symbol::SimpleToken(symbol_1_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_1_built)?;
        self.push(ASTType::Symbol(symbol_1_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `Symbol: TokenWithStates;`
    ///
    #[parol_runtime::function_name::named]
    fn symbol_2(&mut self, _token_with_states: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_with_states = pop_item!(self, token_with_states, TokenWithStates, context);
        let symbol_2_built = SymbolTokenWithStates { token_with_states };
        let symbol_2_built = Symbol::TokenWithStates(symbol_2_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_2_built)?;
        self.push(ASTType::Symbol(symbol_2_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `Symbol: ScannerSwitch;`
    ///
    #[parol_runtime::function_name::named]
    fn symbol_3(&mut self, _scanner_switch: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_switch = pop_item!(self, scanner_switch, ScannerSwitch, context);
        let symbol_3_built = SymbolScannerSwitch { scanner_switch };
        let symbol_3_built = Symbol::ScannerSwitch(symbol_3_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_3_built)?;
        self.push(ASTType::Symbol(symbol_3_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `TokenLiteral: String;`
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_0(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let token_literal_0_built = TokenLiteralString { string };
        let token_literal_0_built = TokenLiteral::String(token_literal_0_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_0_built)?;
        self.push(ASTType::TokenLiteral(token_literal_0_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `TokenLiteral: RawString;`
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_1(&mut self, _raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = pop_item!(self, raw_string, RawString, context);
        let token_literal_1_built = TokenLiteralRawString { raw_string };
        let token_literal_1_built = TokenLiteral::RawString(token_literal_1_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_1_built)?;
        self.push(ASTType::TokenLiteral(token_literal_1_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `TokenLiteral: Regex;`
    ///
    #[parol_runtime::function_name::named]
    fn token_literal_2(&mut self, _regex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let regex = pop_item!(self, regex, Regex, context);
        let token_literal_2_built = TokenLiteralRegex { regex };
        let token_literal_2_built = TokenLiteral::Regex(token_literal_2_built);
        // Calling user action here
        self.user_grammar.token_literal(&token_literal_2_built)?;
        self.push(ASTType::TokenLiteral(token_literal_2_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `SimpleToken: TokenLiteral SimpleTokenOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_token(
        &mut self,
        _token_literal: &ParseTreeType<'t>,
        _simple_token_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let simple_token_opt = pop_item!(self, simple_token_opt, SimpleTokenOpt, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let simple_token_built = SimpleToken {
            token_literal,
            simple_token_opt,
        };
        // Calling user action here
        self.user_grammar.simple_token(&simple_token_built)?;
        self.push(ASTType::SimpleToken(simple_token_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `SimpleTokenOpt /* Option<T>::Some */: ASTControl;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_token_opt_0(&mut self, _a_s_t_control: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let simple_token_opt_0_built = SimpleTokenOpt { a_s_t_control };
        self.push(
            ASTType::SimpleTokenOpt(Some(simple_token_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `SimpleTokenOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn simple_token_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SimpleTokenOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `TokenWithStates: '<'^ /* Clipped */ IdentifierList '>'^ /* Clipped */ TokenLiteral TokenWithStatesOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states(
        &mut self,
        _l_t: &ParseTreeType<'t>,
        _identifier_list: &ParseTreeType<'t>,
        _g_t: &ParseTreeType<'t>,
        _token_literal: &ParseTreeType<'t>,
        _token_with_states_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_with_states_opt =
            pop_item!(self, token_with_states_opt, TokenWithStatesOpt, context);
        let token_literal = pop_item!(self, token_literal, TokenLiteral, context);
        let identifier_list = pop_item!(self, identifier_list, IdentifierList, context);
        let token_with_states_built = TokenWithStates {
            identifier_list,
            token_literal,
            token_with_states_opt,
        };
        // Calling user action here
        self.user_grammar
            .token_with_states(&token_with_states_built)?;
        self.push(ASTType::TokenWithStates(token_with_states_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `TokenWithStatesOpt /* Option<T>::Some */: ASTControl;`
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states_opt_0(&mut self, _a_s_t_control: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let token_with_states_opt_0_built = TokenWithStatesOpt { a_s_t_control };
        self.push(
            ASTType::TokenWithStatesOpt(Some(token_with_states_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `TokenWithStatesOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_with_states_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenWithStatesOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `String: /"(\\.|[^\\])*?"/;`
    ///
    #[parol_runtime::function_name::named]
    fn string(&mut self, string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = string.token()?.clone();
        let string_built = String { string };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `RawString: /'(\\'|[^'])*?'/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string(&mut self, raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = raw_string.token()?.clone();
        let raw_string_built = RawString { raw_string };
        // Calling user action here
        self.user_grammar.raw_string(&raw_string_built)?;
        self.push(ASTType::RawString(raw_string_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `Regex: /\u{2F}(\\.|[^\\])*?\u{2F}/;`
    ///
    #[parol_runtime::function_name::named]
    fn regex(&mut self, regex: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let regex = regex.token()?.clone();
        let regex_built = Regex { regex };
        // Calling user action here
        self.user_grammar.regex(&regex_built)?;
        self.push(ASTType::Regex(regex_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `Group: '(' Alternations ')';`
    ///
    #[parol_runtime::function_name::named]
    fn group(
        &mut self,
        l_paren: &ParseTreeType<'t>,
        _alternations: &ParseTreeType<'t>,
        r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let r_paren = r_paren.token()?.clone();
        let alternations = pop_item!(self, alternations, Alternations, context);
        let group_built = Group {
            l_paren,
            alternations,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.group(&group_built)?;
        self.push(ASTType::Group(group_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `Optional: '[' Alternations ']';`
    ///
    #[parol_runtime::function_name::named]
    fn optional(
        &mut self,
        l_bracket: &ParseTreeType<'t>,
        _alternations: &ParseTreeType<'t>,
        r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token()?.clone();
        let r_bracket = r_bracket.token()?.clone();
        let alternations = pop_item!(self, alternations, Alternations, context);
        let optional_built = Optional {
            l_bracket,
            alternations,
            r_bracket,
        };
        // Calling user action here
        self.user_grammar.optional(&optional_built)?;
        self.push(ASTType::Optional(optional_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `Repeat: '{' Alternations '}';`
    ///
    #[parol_runtime::function_name::named]
    fn repeat(
        &mut self,
        l_brace: &ParseTreeType<'t>,
        _alternations: &ParseTreeType<'t>,
        r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token()?.clone();
        let r_brace = r_brace.token()?.clone();
        let alternations = pop_item!(self, alternations, Alternations, context);
        let repeat_built = Repeat {
            l_brace,
            alternations,
            r_brace,
        };
        // Calling user action here
        self.user_grammar.repeat(&repeat_built)?;
        self.push(ASTType::Repeat(repeat_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `NonTerminal: Identifier NonTerminalOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _non_terminal_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let non_terminal_opt = pop_item!(self, non_terminal_opt, NonTerminalOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let non_terminal_built = NonTerminal {
            identifier,
            non_terminal_opt,
        };
        // Calling user action here
        self.user_grammar.non_terminal(&non_terminal_built)?;
        self.push(ASTType::NonTerminal(non_terminal_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `NonTerminalOpt /* Option<T>::Some */: ASTControl;`
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal_opt_0(&mut self, _a_s_t_control: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_s_t_control = pop_item!(self, a_s_t_control, ASTControl, context);
        let non_terminal_opt_0_built = NonTerminalOpt { a_s_t_control };
        self.push(
            ASTType::NonTerminalOpt(Some(non_terminal_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `NonTerminalOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn non_terminal_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NonTerminalOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `Identifier: /[a-zA-Z_][a-zA-Z0-9_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier(&mut self, identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = identifier.token()?.clone();
        let identifier_built = Identifier { identifier };
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `ScannerState: '%scanner'^ /* Clipped */ Identifier '{'^ /* Clipped */ ScannerStateList /* Vec */ '}'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state(
        &mut self,
        _percent_scanner: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _scanner_state_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_state_list =
            pop_and_reverse_item!(self, scanner_state_list, ScannerStateList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_state_built = ScannerState {
            identifier,
            scanner_state_list,
        };
        // Calling user action here
        self.user_grammar.scanner_state(&scanner_state_built)?;
        self.push(ASTType::ScannerState(scanner_state_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `ScannerStateList /* Vec<T>::Push */: ScannerDirectives ScannerStateList;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state_list_0(
        &mut self,
        _scanner_directives: &ParseTreeType<'t>,
        _scanner_state_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scanner_state_list = pop_item!(self, scanner_state_list, ScannerStateList, context);
        let scanner_directives = pop_item!(self, scanner_directives, ScannerDirectives, context);
        let scanner_state_list_0_built = ScannerStateList { scanner_directives };
        // Add an element to the vector
        scanner_state_list.push(scanner_state_list_0_built);
        self.push(ASTType::ScannerStateList(scanner_state_list), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `ScannerStateList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_state_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_state_list_1_built = Vec::new();
        self.push(
            ASTType::ScannerStateList(scanner_state_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `IdentifierList: Identifier IdentifierListList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_list(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _identifier_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_list_list =
            pop_and_reverse_item!(self, identifier_list_list, IdentifierListList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let identifier_list_built = IdentifierList {
            identifier,
            identifier_list_list,
        };
        // Calling user action here
        self.user_grammar.identifier_list(&identifier_list_built)?;
        self.push(ASTType::IdentifierList(identifier_list_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `IdentifierListList /* Vec<T>::Push */: ','^ /* Clipped */ Identifier IdentifierListList;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _identifier_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut identifier_list_list =
            pop_item!(self, identifier_list_list, IdentifierListList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let identifier_list_list_0_built = IdentifierListList { identifier };
        // Add an element to the vector
        identifier_list_list.push(identifier_list_list_0_built);
        self.push(ASTType::IdentifierListList(identifier_list_list), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `IdentifierListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_list_list_1_built = Vec::new();
        self.push(
            ASTType::IdentifierListList(identifier_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `ScannerSwitch: '%sc' '('^ /* Clipped */ ScannerSwitchOpt /* Option */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_0(
        &mut self,
        percent_sc: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _scanner_switch_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_sc = percent_sc.token()?.clone();
        let scanner_switch_opt = pop_item!(self, scanner_switch_opt, ScannerSwitchOpt, context);
        let scanner_switch_0_built = ScannerSwitchPercentScLParenScannerSwitchOptRParen {
            percent_sc,
            scanner_switch_opt,
        };
        let scanner_switch_0_built =
            ScannerSwitch::PercentScLParenScannerSwitchOptRParen(scanner_switch_0_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_0_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_0_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `ScannerSwitch: '%push' '('^ /* Clipped */ Identifier ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_1(
        &mut self,
        percent_push: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_push = percent_push.token()?.clone();
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_switch_1_built = ScannerSwitchPercentPushLParenIdentifierRParen {
            percent_push,
            identifier,
        };
        let scanner_switch_1_built =
            ScannerSwitch::PercentPushLParenIdentifierRParen(scanner_switch_1_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_1_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_1_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `ScannerSwitch: '%pop' '('^ /* Clipped */ ')'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_2(
        &mut self,
        percent_pop: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_pop = percent_pop.token()?.clone();
        let scanner_switch_2_built = ScannerSwitchPercentPopLParenRParen { percent_pop };
        let scanner_switch_2_built = ScannerSwitch::PercentPopLParenRParen(scanner_switch_2_built);
        // Calling user action here
        self.user_grammar.scanner_switch(&scanner_switch_2_built)?;
        self.push(ASTType::ScannerSwitch(scanner_switch_2_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `ScannerSwitchOpt /* Option<T>::Some */: Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_opt_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scanner_switch_opt_0_built = ScannerSwitchOpt { identifier };
        self.push(
            ASTType::ScannerSwitchOpt(Some(scanner_switch_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `ScannerSwitchOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_switch_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScannerSwitchOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `ASTControl: CutOperator;`
    ///
    #[parol_runtime::function_name::named]
    fn a_s_t_control_0(&mut self, _cut_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator = pop_item!(self, cut_operator, CutOperator, context);
        let a_s_t_control_0_built = ASTControlCutOperator { cut_operator };
        let a_s_t_control_0_built = ASTControl::CutOperator(a_s_t_control_0_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_0_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_0_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `ASTControl: UserTypeDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn a_s_t_control_1(&mut self, _user_type_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_declaration =
            pop_item!(self, user_type_declaration, UserTypeDeclaration, context);
        let a_s_t_control_1_built = ASTControlUserTypeDeclaration {
            user_type_declaration,
        };
        let a_s_t_control_1_built = ASTControl::UserTypeDeclaration(a_s_t_control_1_built);
        // Calling user action here
        self.user_grammar.a_s_t_control(&a_s_t_control_1_built)?;
        self.push(ASTType::ASTControl(a_s_t_control_1_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `CutOperator: '^'^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn cut_operator(&mut self, _cut_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cut_operator_built = CutOperator {};
        // Calling user action here
        self.user_grammar.cut_operator(&cut_operator_built)?;
        self.push(ASTType::CutOperator(cut_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `UserTypeDeclaration: ':'^ /* Clipped */ UserTypeName : UserType;`
    ///
    #[parol_runtime::function_name::named]
    fn user_type_declaration(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _user_type_name: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name = pop_item!(self, user_type_name, UserTypeName, context);
        let user_type_declaration_built = UserTypeDeclaration {
            user_type_name: (&user_type_name)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .user_type_declaration(&user_type_declaration_built)?;
        self.push(
            ASTType::UserTypeDeclaration(user_type_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `UserTypeName: Identifier UserTypeNameList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _user_type_name_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list =
            pop_and_reverse_item!(self, user_type_name_list, UserTypeNameList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let user_type_name_built = UserTypeName {
            identifier,
            user_type_name_list,
        };
        // Calling user action here
        self.user_grammar.user_type_name(&user_type_name_built)?;
        self.push(ASTType::UserTypeName(user_type_name_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `UserTypeNameList /* Vec<T>::Push */: DoubleColon^ /* Clipped */ Identifier UserTypeNameList;`
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name_list_0(
        &mut self,
        _double_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _user_type_name_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut user_type_name_list =
            pop_item!(self, user_type_name_list, UserTypeNameList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        self.pop(context);
        let user_type_name_list_0_built = UserTypeNameList { identifier };
        // Add an element to the vector
        user_type_name_list.push(user_type_name_list_0_built);
        self.push(ASTType::UserTypeNameList(user_type_name_list), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `UserTypeNameList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn user_type_name_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_type_name_list_1_built = Vec::new();
        self.push(
            ASTType::UserTypeNameList(user_type_name_list_1_built),
            context,
        );
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.parol(&children[0], &children[1]),
            1 => self.prolog(&children[0], &children[1], &children[2]),
            2 => self.prolog_list0_0(&children[0], &children[1]),
            3 => self.prolog_list0_1(),
            4 => self.prolog_list_0(&children[0], &children[1]),
            5 => self.prolog_list_1(),
            6 => self.start_declaration(&children[0], &children[1]),
            7 => self.declaration_0(&children[0], &children[1]),
            8 => self.declaration_1(&children[0], &children[1]),
            9 => self.declaration_2(&children[0], &children[1], &children[2], &children[3]),
            10 => self.declaration_3(&children[0], &children[1]),
            11 => self.declaration_4(&children[0]),
            12 => self.scanner_directives_0(&children[0], &children[1]),
            13 => self.scanner_directives_1(&children[0], &children[1], &children[2]),
            14 => self.scanner_directives_2(&children[0]),
            15 => self.scanner_directives_3(&children[0]),
            16 => self.scanner_directives_4(&children[0], &children[1], &children[2], &children[3]),
            17 => self.grammar_definition(&children[0], &children[1], &children[2]),
            18 => self.grammar_definition_list_0(&children[0], &children[1]),
            19 => self.grammar_definition_list_1(),
            20 => self.double_colon(&children[0]),
            21 => self.production(&children[0], &children[1], &children[2], &children[3]),
            22 => self.alternations(&children[0], &children[1]),
            23 => self.alternations_list_0(&children[0], &children[1], &children[2]),
            24 => self.alternations_list_1(),
            25 => self.alternation(&children[0]),
            26 => self.alternation_list_0(&children[0], &children[1]),
            27 => self.alternation_list_1(),
            28 => self.factor_0(&children[0]),
            29 => self.factor_1(&children[0]),
            30 => self.factor_2(&children[0]),
            31 => self.factor_3(&children[0]),
            32 => self.symbol_0(&children[0]),
            33 => self.symbol_1(&children[0]),
            34 => self.symbol_2(&children[0]),
            35 => self.symbol_3(&children[0]),
            36 => self.token_literal_0(&children[0]),
            37 => self.token_literal_1(&children[0]),
            38 => self.token_literal_2(&children[0]),
            39 => self.simple_token(&children[0], &children[1]),
            40 => self.simple_token_opt_0(&children[0]),
            41 => self.simple_token_opt_1(),
            42 => self.token_with_states(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            43 => self.token_with_states_opt_0(&children[0]),
            44 => self.token_with_states_opt_1(),
            45 => self.string(&children[0]),
            46 => self.raw_string(&children[0]),
            47 => self.regex(&children[0]),
            48 => self.group(&children[0], &children[1], &children[2]),
            49 => self.optional(&children[0], &children[1], &children[2]),
            50 => self.repeat(&children[0], &children[1], &children[2]),
            51 => self.non_terminal(&children[0], &children[1]),
            52 => self.non_terminal_opt_0(&children[0]),
            53 => self.non_terminal_opt_1(),
            54 => self.identifier(&children[0]),
            55 => self.scanner_state(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            56 => self.scanner_state_list_0(&children[0], &children[1]),
            57 => self.scanner_state_list_1(),
            58 => self.identifier_list(&children[0], &children[1]),
            59 => self.identifier_list_list_0(&children[0], &children[1], &children[2]),
            60 => self.identifier_list_list_1(),
            61 => self.scanner_switch_0(&children[0], &children[1], &children[2], &children[3]),
            62 => self.scanner_switch_1(&children[0], &children[1], &children[2], &children[3]),
            63 => self.scanner_switch_2(&children[0], &children[1], &children[2]),
            64 => self.scanner_switch_opt_0(&children[0]),
            65 => self.scanner_switch_opt_1(),
            66 => self.a_s_t_control_0(&children[0]),
            67 => self.a_s_t_control_1(&children[0]),
            68 => self.cut_operator(&children[0]),
            69 => self.user_type_declaration(&children[0], &children[1]),
            70 => self.user_type_name(&children[0], &children[1]),
            71 => self.user_type_name_list_0(&children[0], &children[1], &children[2]),
            72 => self.user_type_name_list_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
