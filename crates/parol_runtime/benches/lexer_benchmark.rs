use std::{borrow::Cow, cell::RefCell, path::Path};

use criterion::{Criterion, Throughput, criterion_group, criterion_main};
use criterion::{Criterion, Throughput, criterion_group, criterion_main};
use parol_runtime::{
    TerminalIndex, TokenStream,
    lexer::{ERROR_TOKEN, UNMATCHABLE_TOKEN},
};
use scnr2::scanner;

scanner! {
    ParolScanner {
        mode INITIAL {
            token r"\r\n|\r|\n" => 1;
            token r"[\s--\r\n]+" => 2;
            token r"//.*(\r\n|\r|\n)?" => 3;
            token r"/\*([^*]|\*[^/])*\*/" => 4;
            token r"%start" => 5;
            token r"%title" => 6;
            token r"%comment" => 7;
            token r"%user_type" => 8;
            token r"=" => 9;
            token r"%nt_type" => 10;
            token r"=" => 11;
            token r"%t_type" => 12;
            token r"%grammar_type" => 13;
            token r"%line_comment" => 14;
            token r"%block_comment" => 15;
            token r"%auto_newline_off" => 16;
            token r"%auto_ws_off" => 17;
            token r"%on" => 18;
            token r"%enter" => 19;
            token r"%%" => 20;
            token r"::" => 21;
            token r":" => 22;
            token r";" => 23;
            token r"\|" => 24;
            token r"<" => 25;
            token r">" => 26;
            token r#""(\\.|[^"])*""# => 27;
            token r"'(\\.|[^'])*'" => 28;
            token r"/(\\.|[^\/])*/" => 29;
            token r"\(" => 30;
            token r"\)" => 31;
            token r"\[" => 32;
            token r"\]" => 33;
            token r"\{" => 34;
            token r"\}" => 35;
            token r"[a-zA-Z_][a-zA-Z0-9_]*" => 36;
            token r"%scanner" => 37;
            token r"," => 38;
            token r"%sc" => 39;
            token r"%push" => 40;
            token r"%pop" => 41;
            token r"@" => 42;
            token r"\^" => 43;
            token r"\?=" => 44;
            token r"\?!" => 45;
            token r"." => 46;
        }
    }
}

const LEXER_INPUT: &str = include_str!("./input_1.txt");

// The regex generated by parol for `verly` grammar
const PATTERNS: &[(&str, Option<(bool, &str)>)] = &[
    /*   0 */ (UNMATCHABLE_TOKEN, None),
    /*   1 */ (UNMATCHABLE_TOKEN, None),
    /*   2 */ (UNMATCHABLE_TOKEN, None),
    /*   3 */ (UNMATCHABLE_TOKEN, None),
    /*   4 */ (UNMATCHABLE_TOKEN, None),
    /*   5 */ (r"(//.*(\r\n|\r|\n)|/\*([^*]|\*[^/])*\*/\s*)+", None),
    /*   6 */
    (
        r"\u{0022}(\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}",
        None,
    ),
    /*   7 */
    (
        r"[0-9]+(_[0-9]+)*\.[0-9]+(_[0-9]+)*[eE][+-]?[0-9]+(_[0-9]+)*",
        None,
    ),
    /*   8 */ (r"[0-9]+(_[0-9]+)*\.[0-9]+(_[0-9]+)*", None),
    /*   9 */
    (
        r"([0-9]+(_[0-9]+)*)?'s?[bodh][0-9a-fA-FxzXZ]+(_[0-9a-fA-FxzXZ]+)*",
        None,
    ),
    /*  10 */ (r"([0-9]+(_[0-9]+)*)?'[01xzXZ]", None),
    /*  11 */ (r"[0-9]+(_[0-9]+)*", None),
    /*  12 */ (r"\-:", None),
    /*  13 */ (r"\->", None),
    /*  14 */ (r"\+:", None),
    /*  15 */ (r"\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=", None),
    /*  16 */ (r"\*\*", None),
    /*  17 */ (r"/|%", None),
    /*  18 */ (r"\+|-", None),
    /*  19 */ (r"<<<|>>>|<<|>>", None),
    /*  20 */ (r"<=|>=|<:|>:", Some((false, ":"))),
    /*  21 */ (r"===|==\?|!==|!=\?|==|!=", None),
    /*  22 */ (r"&&", None),
    /*  23 */ (r"\|\|", None),
    /*  24 */ (r"&", None),
    /*  25 */ (r"\^~|\^|~\^", None),
    /*  26 */ (r"\|", None),
    /*  27 */ (r"~&|~\||!|~", None),
    /*  28 */ (r"`", None),
    /*  29 */ (r"::<", None),
    /*  30 */ (r"::", None),
    /*  31 */ (r":", None),
    /*  32 */ (r",", None),
    /*  33 */ (r"\.\.=", None),
    /*  34 */ (r"\.\.", None),
    /*  35 */ (r"\.", None),
    /*  36 */ (r"=", None),
    /*  37 */ (r"\#", None),
    /*  38 */ (r"<", None),
    /*  39 */ (r"'\{", None),
    /*  40 */ (r"\{", None),
    /*  41 */ (r"\[", None),
    /*  42 */ (r"\(", None),
    /*  43 */ (r">", None),
    /*  44 */ (r"\}", None),
    /*  45 */ (r"\]", None),
    /*  46 */ (r"\)", None),
    /*  47 */ (r";", None),
    /*  48 */ (r"\*", None),
    /*  49 */ (r"always_comb", None),
    /*  50 */ (r"always_ff", None),
    /*  51 */ (r"assign", None),
    /*  52 */ (r"as", None),
    /*  53 */ (r"bit", None),
    /*  54 */ (r"case", None),
    /*  55 */ (r"clock", None),
    /*  56 */ (r"clock_posedge", None),
    /*  57 */ (r"clock_negedge", None),
    /*  58 */ (r"const", None),
    /*  59 */ (r"default", None),
    /*  60 */ (r"else", None),
    /*  61 */ (r"embed", None),
    /*  62 */ (r"enum", None),
    /*  63 */ (r"export", None),
    /*  64 */ (r"f32", None),
    /*  65 */ (r"f64", None),
    /*  66 */ (r"final", None),
    /*  67 */ (r"for", None),
    /*  68 */ (r"function", None),
    /*  69 */ (r"i32", None),
    /*  70 */ (r"i64", None),
    /*  71 */ (r"if_reset", None),
    /*  72 */ (r"if", None),
    /*  73 */ (r"import", None),
    /*  74 */ (r"include", None),
    /*  75 */ (r"initial", None),
    /*  76 */ (r"inout", None),
    /*  77 */ (r"input", None),
    /*  78 */ (r"inside", None),
    /*  79 */ (r"inst", None),
    /*  80 */ (r"interface", None),
    /*  81 */ (r"in", None),
    /*  82 */ (r"let", None),
    /*  83 */ (r"logic", None),
    /*  84 */ (r"lsb", None),
    /*  85 */ (r"modport", None),
    /*  86 */ (r"module", None),
    /*  87 */ (r"msb", None),
    /*  88 */ (r"output", None),
    /*  89 */ (r"outside", None),
    /*  90 */ (r"package", None),
    /*  91 */ (r"param", None),
    /*  92 */ (r"proto", None),
    /*  93 */ (r"pub", None),
    /*  94 */ (r"ref", None),
    /*  95 */ (r"repeat", None),
    /*  96 */ (r"reset", None),
    /*  97 */ (r"reset_async_high", None),
    /*  98 */ (r"reset_async_low", None),
    /*  99 */ (r"reset_sync_high", None),
    /* 100 */ (r"reset_sync_low", None),
    /* 101 */ (r"return", None),
    /* 102 */ (r"break", None),
    /* 103 */ (r"signed", None),
    /* 104 */ (r"step", None),
    /* 105 */ (r"string", None),
    /* 106 */ (r"struct", None),
    /* 107 */ (r"switch", None),
    /* 108 */ (r"tri", None),
    /* 109 */ (r"type", None),
    /* 110 */ (r"u32", None),
    /* 111 */ (r"u64", None),
    /* 112 */ (r"union", None),
    /* 113 */ (r"unsafe", None),
    /* 114 */ (r"var", None),
    /* 115 */ (r"\$[a-zA-Z_][0-9a-zA-Z_$]*", None),
    /* 116 */ (r"(r#)?[a-zA-Z_][0-9a-zA-Z_$]*", None),
    /* 117 */ (r"[^{}]*", None),
    /* 118 */ (ERROR_TOKEN, None),
];

const MAX_K: usize = 3;
const ERROR_TOKEN_INDEX: TerminalIndex = PATTERNS.len() as TerminalIndex - 1;

use parol_scanner::ParolScanner;

fn tokenize() {
    let file_name: Cow<Path> = Path::new("./input_1.txt").to_owned().into();
    let scanner = ParolScanner::new();
    let token_stream = RefCell::new(
        TokenStream::new(
            LEXER_INPUT,
            file_name,
            &scanner.scanner_impl,
            &ParolScanner::match_function,
            MAX_K,
        )
        .unwrap(),
    );
    while !token_stream.borrow().all_input_consumed() {
        let tok = token_stream.borrow_mut().lookahead(0).unwrap();
        assert_ne!(
            tok.token_type, ERROR_TOKEN_INDEX,
            "Error token found: {:?}",
            tok
        );
        // Drop the skip tokens
        let _ = token_stream
            .borrow_mut()
            .take_skip_tokens()
            .into_iter()
            .collect::<Vec<_>>();

        token_stream.borrow_mut().consume().unwrap();
    }
}

fn tokenize_benchmark(c: &mut Criterion) {
    c.bench_function("tokenize", |b| b.iter(tokenize));
}

fn throughput_benchmark(c: &mut Criterion) {
    let mut group = c.benchmark_group("throughput");
    group.throughput(Throughput::Bytes(LEXER_INPUT.len() as u64));
    let file_name: Cow<Path> = Path::new("./input_1.txt").to_owned().into();
    group.bench_function("throughput", |b| {
        b.iter(|| {
            let scanner = ParolScanner::new();
            let token_stream = RefCell::new(
                TokenStream::new(
                    LEXER_INPUT,
                    file_name.clone(),
                    &scanner.scanner_impl,
                    &ParolScanner::match_function,
                    MAX_K,
                )
                .unwrap(),
            );
            while !token_stream.borrow().all_input_consumed() {
                let tok = token_stream.borrow_mut().lookahead(0).unwrap();
                assert_ne!(
                    tok.token_type, ERROR_TOKEN_INDEX,
                    "Error token found: {:?}",
                    tok
                );
                // Drop the skip tokens
                let _ = token_stream
                    .borrow_mut()
                    .take_skip_tokens()
                    .into_iter()
                    .collect::<Vec<_>>();

                token_stream.borrow_mut().consume().unwrap();
            }
        })
    });
}

criterion_group!(benchesscanner, tokenize_benchmark, throughput_benchmark);
criterion_main!(benchesscanner);
