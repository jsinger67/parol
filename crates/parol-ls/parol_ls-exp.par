%start ParolLs
%title "Parol grammar"
%comment "Parol's own grammar enhanced with comment processing"
%line_comment "//"
%block_comment "/\*" "\*/"
%t_type crate::parol_ls_grammar::OwnedToken

%%

/*  0 */ ParolLs: Prolog GrammarDefinition;
/*  1 */ Prolog: StartDeclaration PrologList /* Vec */ PrologList0 /* Vec */;
/*  2 */ PrologList0 /* Vec<T>::Push */: ScannerState PrologList0;
/*  3 */ PrologList0 /* Vec<T>::New */: ;
/*  4 */ PrologList /* Vec<T>::Push */: Declaration PrologList;
/*  5 */ PrologList /* Vec<T>::New */: ;
/*  6 */ StartDeclaration: "%start" Identifier;
/*  7 */ Declaration: "%title" String;
/*  8 */ Declaration: "%comment" String;
/*  9 */ Declaration: "%user_type" Identifier "=" UserTypeName;
/* 10 */ Declaration: "%nt_type" Identifier@nt_name "=" UserTypeName@nt_type;
/* 11 */ Declaration: "%t_type" UserTypeName@t_type;
/* 12 */ Declaration: '%grammar_type' LiteralString;
/* 13 */ Declaration: ScannerDirectives;
/* 14 */ ScannerDirectives: "%line_comment" TokenLiteral;
/* 15 */ ScannerDirectives: "%block_comment" TokenLiteral TokenLiteral;
/* 16 */ ScannerDirectives: "%auto_newline_off";
/* 17 */ ScannerDirectives: "%auto_ws_off";
/* 18 */ ScannerDirectives: '%on' IdentifierList ScannerStateDirectives;
/* 19 */ ScannerDirectives: "%allow_unmatched";
/* 20 */ ScannerStateDirectives: '%enter' Identifier;
/* 21 */ ScannerStateDirectives: '%push' Identifier;
/* 22 */ ScannerStateDirectives: '%pop';
/* 23 */ GrammarDefinition: "%%" Production GrammarDefinitionList /* Vec */;
/* 24 */ GrammarDefinitionList /* Vec<T>::Push */: Production GrammarDefinitionList;
/* 25 */ GrammarDefinitionList /* Vec<T>::New */: ;
/* 26 */ DoubleColon: "::";
/* 27 */ ProductionLHS: Identifier ":";
/* 28 */ Production: ProductionLHS Alternations ";";
/* 29 */ Alternations: Alternation AlternationsList /* Vec */;
/* 30 */ AlternationsList /* Vec<T>::Push */: '|' Alternation AlternationsList;
/* 31 */ AlternationsList /* Vec<T>::New */: ;
/* 32 */ Alternation: AlternationList /* Vec */;
/* 33 */ AlternationList /* Vec<T>::Push */: Factor AlternationList;
/* 34 */ AlternationList /* Vec<T>::New */: ;
/* 35 */ Factor: Group;
/* 36 */ Factor: Repeat;
/* 37 */ Factor: Optional;
/* 38 */ Factor: Symbol;
/* 39 */ Symbol: NonTerminal;
/* 40 */ Symbol: SimpleToken;
/* 41 */ Symbol: TokenWithStates;
/* 42 */ Symbol: ScannerSwitch;
/* 43 */ TokenLiteral: String;
/* 44 */ TokenLiteral: LiteralString;
/* 45 */ TokenLiteral: Regex;
/* 46 */ TokenExpression: TokenLiteral TokenExpressionOpt /* Option */;
/* 47 */ TokenExpressionOpt /* Option<T>::Some */: LookAhead;
/* 48 */ TokenExpressionOpt /* Option<T>::None */: ;
/* 49 */ SimpleToken: TokenExpression SimpleTokenOpt /* Option */;
/* 50 */ SimpleTokenOpt /* Option<T>::Some */: ASTControl;
/* 51 */ SimpleTokenOpt /* Option<T>::None */: ;
/* 52 */ TokenWithStates: "<" IdentifierList ">" TokenExpression TokenWithStatesOpt /* Option */;
/* 53 */ TokenWithStatesOpt /* Option<T>::Some */: ASTControl;
/* 54 */ TokenWithStatesOpt /* Option<T>::None */: ;
/* 55 */ Group: '(' Alternations ')';
/* 56 */ Optional: '[' Alternations ']';
/* 57 */ Repeat: '{' Alternations '}';
/* 58 */ NonTerminal: Identifier NonTerminalOpt /* Option */;
/* 59 */ NonTerminalOpt /* Option<T>::Some */: ASTControl;
/* 60 */ NonTerminalOpt /* Option<T>::None */: ;
/* 61 */ Identifier: /[a-zA-Z_][a-zA-Z0-9_]*/;
/* 62 */ String: /"(\\.|[^"])*"/;
/* 63 */ LiteralString: /'(\\.|[^'])*'/;
/* 64 */ ScannerState: "%scanner" Identifier '{' ScannerStateList /* Vec */ '}';
/* 65 */ ScannerStateList /* Vec<T>::Push */: ScannerDirectives ScannerStateList;
/* 66 */ ScannerStateList /* Vec<T>::New */: ;
/* 67 */ IdentifierList: Identifier IdentifierListList /* Vec */;
/* 68 */ IdentifierListList /* Vec<T>::Push */: "," Identifier IdentifierListList;
/* 69 */ IdentifierListList /* Vec<T>::New */: ;
/* 70 */ ScannerSwitch: "%sc" '(' ScannerSwitchOpt /* Option */ ')';
/* 71 */ ScannerSwitch: "%push" '(' Identifier ')';
/* 72 */ ScannerSwitch: "%pop" '(' ')';
/* 73 */ ScannerSwitchOpt /* Option<T>::Some */: Identifier;
/* 74 */ ScannerSwitchOpt /* Option<T>::None */: ;
/* 75 */ ASTControl: CutOperator;
/* 76 */ ASTControl: MemberName ASTControlOpt /* Option */;
/* 77 */ ASTControl: UserTypeDeclaration;
/* 78 */ ASTControlOpt /* Option<T>::Some */: UserTypeDeclaration;
/* 79 */ ASTControlOpt /* Option<T>::None */: ;
/* 80 */ MemberName: '@'^ /* Clipped */ Identifier;
/* 81 */ CutOperator: '^';
/* 82 */ UserTypeDeclaration: ":" UserTypeName;
/* 83 */ UserTypeName: Identifier UserTypeNameList /* Vec */;
/* 84 */ UserTypeNameList /* Vec<T>::Push */: DoubleColon Identifier UserTypeNameList;
/* 85 */ UserTypeNameList /* Vec<T>::New */: ;
/* 86 */ Regex: "/(\\.|[^\/])*/";
/* 87 */ LookAhead: LookAheadGroup TokenLiteral;
/* 88 */ LookAheadGroup: PositiveLookahead;
/* 89 */ LookAheadGroup: NegativeLookahead;
/* 90 */ PositiveLookahead: '?=';
/* 91 */ NegativeLookahead: '?!';
